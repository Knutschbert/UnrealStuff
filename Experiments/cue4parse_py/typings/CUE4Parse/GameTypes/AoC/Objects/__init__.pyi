from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FakePackage(CUE4Parse.UE4.Assets.IPackage):
    def __init__(self, name: 'str', mappings: 'CUE4Parse.MappingsProvider.TypeMappings') -> None: ...
    Name: 'str' = ...
    Provider: 'CUE4Parse.FileProvider.IFileProvider' = ...
    Mappings: 'CUE4Parse.MappingsProvider.TypeMappings' = ...
    Summary: 'CUE4Parse.UE4.Objects.UObject.FPackageFileSummary' = ...
    NameMap: 'List[CUE4Parse.UE4.Objects.UObject.FNameEntrySerialized]' = ...
    ImportMapLength: 'int' = ...
    ExportMapLength: 'int' = ...
    ExportsLazy: 'List[System.Lazy[CUE4Parse.UE4.Assets.Exports.UObject]]' = ...
    IsFullyLoaded: 'bool' = ...
    CanDeserialize: 'bool' = ...
    def HasFlags(self, flags: 'CUE4Parse.UE4.Objects.UObject.EPackageFlags') -> 'bool': ...
    def GetExportIndex(self, name: 'str', comparisonType: 'System.StringComparison') -> 'int': ...
    def ResolvePackageIndex(self, index: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex') -> 'CUE4Parse.UE4.Assets.ResolvedObject': ...

class FAoCDataChunk(System.ValueType):
    Hash: 'System.UInt64' = ...
    Offset: 'int' = ...
    Size: 'int' = ...
    FileCount: 'int' = ...
    checksum: 'System.UInt32' = ...

class FAoCDBCReader(CUE4Parse.UE4.Assets.Readers.FAssetArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, data: 'List[int]', mappings: 'CUE4Parse.MappingsProvider.TypeMappings', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    Chunks: 'List[CUE4Parse.GameTypes.AoC.Objects.FAoCDataChunk]' = ...
    def TryReadChunk(self, index: 'int') -> Tuple['bool', 'System.String', 'CUE4Parse.GameTypes.AoC.Objects.FAoCFile[]']: ...
    def ReadInstancedStruct(self) -> 'CUE4Parse.UE4.IUStruct': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def TestReadFName(self) -> 'bool': ...

class FAoCDBCReaderConverter(Newtonsoft.Json.JsonConverter[CUE4Parse.GameTypes.AoC.Objects.FAoCDBCReader]):
    def __init__(self) -> None: ...
    def ReadJson(self, reader: 'Newtonsoft.Json.JsonReader', objectType: 'System.Type', existingValue: 'CUE4Parse.GameTypes.AoC.Objects.FAoCDBCReader', hasExistingValue: 'bool', serializer: 'Newtonsoft.Json.JsonSerializer') -> 'CUE4Parse.GameTypes.AoC.Objects.FAoCDBCReader': ...
    def WriteJson(self, writer: 'Newtonsoft.Json.JsonWriter', value: 'CUE4Parse.GameTypes.AoC.Objects.FAoCDBCReader', serializer: 'Newtonsoft.Json.JsonSerializer') -> None: ...

class FAoCFile(CUE4Parse.UE4.Assets.Exports.AbstractPropertyHolder, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self, Ar: 'CUE4Parse.GameTypes.AoC.Objects.FAoCDBCReader', type: 'str') -> None: ...
    Name: 'str' = ...

class FAoCFileConverter(Newtonsoft.Json.JsonConverter[CUE4Parse.GameTypes.AoC.Objects.FAoCFile]):
    def __init__(self) -> None: ...
    def ReadJson(self, reader: 'Newtonsoft.Json.JsonReader', objectType: 'System.Type', existingValue: 'CUE4Parse.GameTypes.AoC.Objects.FAoCFile', hasExistingValue: 'bool', serializer: 'Newtonsoft.Json.JsonSerializer') -> 'CUE4Parse.GameTypes.AoC.Objects.FAoCFile': ...
    def WriteJson(self, writer: 'Newtonsoft.Json.JsonWriter', value: 'CUE4Parse.GameTypes.AoC.Objects.FAoCFile', serializer: 'Newtonsoft.Json.JsonSerializer') -> None: ...

