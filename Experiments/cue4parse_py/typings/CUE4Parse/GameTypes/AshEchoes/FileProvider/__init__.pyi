from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class AEDefaultFileProvider(CUE4Parse.FileProvider.DefaultFileProvider, CUE4Parse.FileProvider.IFileProvider, System.IDisposable, CUE4Parse.FileProvider.Vfs.IVfsFileProvider):
    def __init__(self, directory: 'str', searchOption: 'System.IO.SearchOption', versions: 'CUE4Parse.UE4.Versions.VersionContainer', pathComparer: 'System.StringComparer') -> None: ...
    def Initialize(self) -> None: ...
    def LoadVirtualPaths(self, version: 'CUE4Parse.UE4.Versions.FPackageFileVersion', cancellationToken: 'System.Threading.CancellationToken') -> 'int': ...

class FAEFileHeader(System.ValueType):
    Size: 'int' = ...
    Flags: 'int' = ...
    FileSize: 'int' = ...
    ChunkSize: 'System.UInt32' = ...
    Comp: 'System.UInt16' = ...
    Map: 'System.UInt16' = ...
    ChunksCount: 'int' = ...
    Compression: 'CUE4Parse.Compression.CompressionMethod' = ...

class FAEPakEntry(CUE4Parse.UE4.Pak.Objects.FPakEntry):
    def __init__(self, vfs: 'CUE4Parse.GameTypes.AshEchoes.FileProvider.AEPakFileReader', path: 'str', size: 'int') -> None: ...
    CompressedSize: 'int' = ...
    UncompressedSize: 'int' = ...
    CompressionBlocks: 'List[CUE4Parse.UE4.Pak.Objects.FPakCompressedBlock]' = ...
    CompressionBlockSize: 'System.UInt32' = ...
    StructSize: 'int' = ...
    IsEncrypted: 'bool' = ...
    CompressionMethod: 'CUE4Parse.Compression.CompressionMethod' = ...
    IsCompressed: 'bool' = ...
    def Read(self, header: 'Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader]') -> 'List[int]': ...
    def CreateReader(self, header: 'Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader]') -> 'CUE4Parse.UE4.Readers.FArchive': ...

class AEPakFileReader(CUE4Parse.UE4.VirtualFileSystem.AbstractAesVfsReader, CUE4Parse.UE4.VirtualFileSystem.IVfsReader, System.IDisposable, CUE4Parse.UE4.VirtualFileSystem.IAesVfsReader):
    def __init__(self, filePath: 'str', name: 'str', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    Ar: 'CUE4Parse.UE4.Readers.FArchive' = ...
    MountPoint: 'str' = ...
    HasDirectoryIndex: 'bool' = ...
    EncryptionKeyGuid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    IsEncrypted: 'bool' = ...
    Length: 'int' = ...
    def ReadIndex(self, pathComparer: 'System.StringComparer') -> None: ...
    def Mount(self, pathComparer: 'System.StringComparer') -> None: ...
    def Extract(self, entry: 'CUE4Parse.UE4.VirtualFileSystem.VfsEntry', header: 'Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader]') -> 'List[int]': ...
    def Dispose(self) -> None: ...
    def MountPointCheckBytes(self) -> 'List[int]': ...

class FAssetEntry:
    @overload
    def __init__(self, Ar: 'GenericReader.GenericBufferReader') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Guid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    Name: 'str' = ...
    Offset: 'System.UInt32' = ...
    Size: 'System.UInt32' = ...
    Hash: 'System.UInt32' = ...
    data: 'List[int]' = ...

class FFileEntry:
    def __init__(self, Ar: 'GenericReader.GenericBufferReader') -> None: ...
    Folder: 'str' = ...
    FileName: 'str' = ...
    Name: 'str' = ...
    Size: 'int' = ...

