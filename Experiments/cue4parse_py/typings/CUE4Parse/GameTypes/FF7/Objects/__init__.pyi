from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FEndTextResourceStrings(CUE4Parse.UE4.IUStruct):
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Text: 'str' = ...
    MetaData: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Objects.UObject.FName, str]' = ...

class FMemoryMappedImageArchive(CUE4Parse.UE4.Readers.FMemoryImageArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def DeserializeProperties(self, structProperties: 'List[CUE4Parse.GameTypes.FF7.Assets.Exports.FF7Property]') -> 'CUE4Parse.GameTypes.FF7.Assets.Objects.Properties.FF7StructProperty': ...
    def ReadPropertyTagType(self, underlyingType: 'CUE4Parse.GameTypes.FF7.Assets.Objects.Properties.FF7propertyType') -> 'CUE4Parse.UE4.Assets.Objects.Properties.FPropertyTagType': ...
    @overload
    def ReadArray(self) -> 'List[T]': ...
    @overload
    def ReadArray(self, getter: 'System.Func[T]') -> 'List[T]': ...
    @overload
    def ReadArray(self, getter: 'System.Func[T]', align: 'int') -> 'List[T]': ...
    def ReadTSparseArray(self, elementGetter: 'System.Func[ElementType]', elementStructSize: 'int') -> 'List[ElementType]': ...

class FMemoryMappedImageResult(CUE4Parse.UE4.Assets.Exports.Material.FMemoryImageResult):
    def __init__(self) -> None: ...
    def LoadFromArchive(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...

