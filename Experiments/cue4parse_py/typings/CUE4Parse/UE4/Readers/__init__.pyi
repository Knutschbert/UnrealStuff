from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FArchive(OffiUtils.RandomAccessStream, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    Versions: 'CUE4Parse.UE4.Versions.VersionContainer' = ...
    Game: 'CUE4Parse.UE4.Versions.EGame' = ...
    Ver: 'CUE4Parse.UE4.Versions.FPackageFileVersion' = ...
    Platform: 'CUE4Parse.UE4.Assets.Exports.Texture.ETexturePlatform' = ...
    Name: 'str' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAtAsync(self, position: 'int', memory: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def ReadBytesAt(self, position: 'int', length: 'int') -> 'List[int]': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    def Read(self) -> 'T': ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    @overload
    def ReadArray(self, array: 'List[T]', getter: 'System.Func[T]') -> None: ...
    @overload
    def ReadArray(self, length: 'int', getter: 'System.Func[T]') -> 'List[T]': ...
    @overload
    def ReadArray(self, getter: 'System.Func[T]') -> 'List[T]': ...
    @overload
    def ReadArray(self) -> 'List[T]': ...
    def Flush(self) -> None: ...
    def SetLength(self, value: 'int') -> None: ...
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def ReadBulkArray(self, elementSize: 'int', elementCount: 'int', getter: 'System.Func[T]') -> 'List[T]': ...
    @overload
    def ReadBulkArray(self) -> 'List[T]': ...
    @overload
    def ReadBulkArray(self, getter: 'System.Func[T]') -> 'List[T]': ...
    def SkipBulkArrayData(self) -> None: ...
    def SkipFixedArray(self, size: 'int') -> None: ...
    @overload
    def ReadMap(self, length: 'int', getter: 'System.Func[System.ValueTuple[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @overload
    def ReadMap(self, length: 'int', keyGetter: 'System.Func[TKey]', valueGetter: 'System.Func[TValue]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @overload
    def ReadMap(self, keyGetter: 'System.Func[TKey]', valueGetter: 'System.Func[TValue]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @overload
    def ReadMap(self, getter: 'System.Func[System.ValueTuple[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    def ReadBoolean(self) -> 'bool': ...
    def ReadFlag(self) -> 'bool': ...
    def ReadIntPacked(self) -> 'System.UInt32': ...
    def SerializeBits(self, v: 'System.Void*', lengthBits: 'int') -> None: ...
    def Read7BitEncodedInt(self) -> 'int': ...
    def ReadString(self) -> 'str': ...
    def SkipFString(self) -> None: ...
    def ReadFString(self) -> 'str': ...
    def ReadFUtf8String(self) -> 'str': ...
    def ReadFReal(self) -> 'float': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def ReadUObject(self) -> 'CUE4Parse.UE4.Assets.Exports.UObject': ...
    def SerializeCompressedNew(self, dest: 'List[int]', length: 'int', compressionFormatToDecodeOldV1Files: 'str', flags: 'CUE4Parse.UE4.Objects.Core.Misc.ECompressionFlags', bTreatBufferAsFileReader: 'bool') -> 'System.Int64': ...
    def CheckReadSize(self, length: 'int') -> None: ...
    def Clone(self) -> 'Any': ...

class FArchiveBigEndian(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, baseArchive: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Name: 'str' = ...
    Position: 'int' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def ReadString(self) -> 'str': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    def Clone(self) -> 'Any': ...

class FArchiveLoadCompressedProxy(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', compressedData: 'List[int]', compressionFormat: 'str', flags: 'CUE4Parse.UE4.Objects.Core.Misc.ECompressionFlags', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    Name: 'str' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Clone(self) -> 'Any': ...
    def Read(self, dstData: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...

class FByteArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', data: 'List[int]', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    def Clone(self) -> 'Any': ...

class FFrozenMemoryImagePtr(System.ValueType):
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FMemoryImageArchive') -> None: ...
    _packed: 'System.UInt64' = ...
    IsFrozen: 'bool' = ...
    OffsetFromThis: 'int' = ...
    TypeIndex: 'int' = ...

class FMemoryImageArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive', arrayAlign: 'int') -> None: ...
    InnerArchive: 'CUE4Parse.UE4.Readers.FArchive' = ...
    Names: 'Dict[int, System.ValueTuple[CUE4Parse.UE4.Objects.UObject.FName, bool]]' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    @overload
    def ReadArray(self) -> 'List[T]': ...
    @overload
    def ReadArray(self, getter: 'System.Func[T]') -> 'List[T]': ...
    def ReadArrayOfPtrs(self, getter: 'System.Func[T]') -> 'List[T]': ...
    def ReadHashTable(self) -> 'List[int]': ...
    def ReadFString(self) -> 'str': ...
    def Clone(self) -> 'Any': ...
    def ReadTMap(self, keyGetter: 'System.Func[KeyType]', valueGetter: 'System.Func[ValueType]', keyStructSize: 'int', valueStructSize: 'int') -> 'List[System.ValueTuple[KeyType, ValueType]]': ...
    def ReadTSet(self, elementGetter: 'System.Func[ElementType]', elementStructSize: 'int') -> 'List[ElementType]': ...
    def ReadTSparseArray(self, elementGetter: 'System.Func[ElementType]', elementStructSize: 'int') -> 'List[ElementType]': ...
    def ReadTBitArray(self) -> 'System.Collections.BitArray': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def ReadMaterialParameterType(self) -> 'CUE4Parse.UE4.Assets.Exports.Material.EMaterialParameterType': ...

class FPointerArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', ptr: 'System.Byte*', length: 'int', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    def Clone(self) -> 'Any': ...

class FStreamArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', baseStream: 'System.IO.Stream', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...
    def Close(self) -> None: ...

class FRandomAccessStreamArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', baseStream: 'OffiUtils.RandomAccessStream', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAtAsync(self, position: 'int', memory: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...
    def Close(self) -> None: ...

class FRandomAccessFileStreamArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    @overload
    def __init__(self, filePath: 'str', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    @overload
    def __init__(self, fileInfo: 'System.IO.FileInfo', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    @overload
    def __init__(self, filePath: 'str', fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadAt(self, position: 'int', buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAtAsync(self, position: 'int', memory: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...
    def Close(self) -> None: ...

