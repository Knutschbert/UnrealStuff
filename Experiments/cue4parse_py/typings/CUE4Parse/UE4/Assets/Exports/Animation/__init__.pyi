from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class AnimationCompressionFormat(enum.Enum):
    ACF_None = ...
    ACF_Float96NoW = ...
    ACF_Fixed48NoW = ...
    ACF_IntervalFixed32NoW = ...
    ACF_Fixed32NoW = ...
    ACF_Float32NoW = ...
    ACF_Identity = ...
    ACF_MAX = ...

class AnimationCompressionUtils:
    Quant16BitDiv: 'float' = ...
    Quant16BitOffs: 'int' = ...
    Quant10BitDiv: 'float' = ...
    Quant10BitOffs: 'int' = ...
    Quant11BitDiv: 'float' = ...
    Quant11BitOffs: 'int' = ...
    @staticmethod
    def ReadQuatFixed48NoW(Ar: 'CUE4Parse.UE4.Readers.FArchive', componentMask: 'int') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def ReadQuatFixed32NoW(Ar: 'CUE4Parse.UE4.Readers.FArchive') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def ReadQuatFloat96NoW(Ar: 'CUE4Parse.UE4.Readers.FArchive') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def ReadVectorFixed48(Ar: 'CUE4Parse.UE4.Readers.FArchive') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def ReadVectorIntervalFixed32(Ar: 'CUE4Parse.UE4.Readers.FArchive', mins: 'CUE4Parse.UE4.Objects.Core.Math.FVector', ranges: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def ReadQuatIntervalFixed32NoW(Ar: 'CUE4Parse.UE4.Readers.FArchive', mins: 'CUE4Parse.UE4.Objects.Core.Math.FVector', ranges: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def ReadQuatFloat32NoW(Ar: 'CUE4Parse.UE4.Readers.FArchive') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def DecodeFixed48_PerTrackComponent(value: 'System.UInt16', log2: 'int') -> 'float': ...

class AnimationKeyFormat(enum.Enum):
    AKF_ConstantKeyLerp = ...
    AKF_VariableKeyLerp = ...
    AKF_PerTrackCompression = ...
    AKF_MAX = ...

class UAnimBoneCompressionCodec(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def GetCodec(self, ddcHandle: 'str') -> 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimBoneCompressionCodec': ...
    def GetCodecDDCHandle(self) -> 'str': ...
    def AllocateAnimData(self) -> 'CUE4Parse.UE4.Assets.Exports.Animation.ICompressedAnimData': ...

class UAnimBoneCompressionSettings(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    Codecs: 'List[CUE4Parse.UE4.Objects.UObject.FPackageIndex]' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...
    def GetCodec(self, ddcHandle: 'str') -> 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimBoneCompressionCodec': ...

class UAnimComposite(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompositeBase, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    AnimationTrack: 'CUE4Parse.UE4.Assets.Exports.Animation.FAnimTrack' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

class UAnimCompositeBase(CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequenceBase, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    pass

class FAnimSegment:
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    AnimReference: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    StartPos: 'float' = ...
    AnimStartTime: 'float' = ...
    AnimEndTime: 'float' = ...
    AnimPlayRate: 'float' = ...
    LoopingCount: 'int' = ...
    def GetValidPlayRate(self) -> 'float': ...
    def GetLength(self) -> 'float': ...

class FAnimTrack:
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    AnimSegments: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FAnimSegment]' = ...
    def GetLength(self) -> 'float': ...

class UAnimCompress(CUE4Parse.UE4.Assets.Exports.Animation.UAnimBoneCompressionCodec, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    def AllocateAnimData(self) -> 'CUE4Parse.UE4.Assets.Exports.Animation.ICompressedAnimData': ...

class UAnimCompress_BitwiseCompressOnly(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompress, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class UAnimCompress_PerTrackCompression(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompress, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class AnimCompress_RemoveLinearKeys(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompress, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class UAnimCompress_Constant(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompress, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class AnimCompress_LeastDestructive(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompress, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class FCompressedOffsetData(FCompressedOffsetDataBase[int]):
    @overload
    def __init__(self, stripSize: 'int') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...

class FCompressedAnimDataBase:
    def __init__(self) -> None: ...
    CompressedTrackOffsets: 'List[int]' = ...
    CompressedScaleOffsets: 'CUE4Parse.UE4.Assets.Exports.Animation.FCompressedOffsetData' = ...
    CompressedByteStream: 'List[int]' = ...
    KeyEncodingFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationKeyFormat' = ...
    TranslationCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...
    RotationCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...
    ScaleCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...

class ICompressedAnimData:
    CompressedNumberOfFrames: 'int' = ...
    def SerializeCompressedData(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    def Bind(self, bulkData: 'List[int]') -> None: ...

class FUECompressedAnimData(CUE4Parse.UE4.Assets.Exports.Animation.FCompressedAnimDataBase, CUE4Parse.UE4.Assets.Exports.Animation.ICompressedAnimData):
    def __init__(self) -> None: ...
    CompressedNumberOfFrames: 'int' = ...
    def InitViewsFromBuffer(self, bulkData: 'List[int]') -> None: ...
    def SerializeCompressedData(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    def Bind(self, bulkData: 'List[int]') -> None: ...
    def ToString(self) -> 'str': ...

class UAnimCurveCompressionCodec(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    InstanceGuid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...
    def GetCodec(self, path: 'str') -> 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec': ...
    def ConvertCurves(self, animSeq: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequence') -> 'List[CUE4Parse.UE4.Assets.Exports.Animation.FFloatCurve]': ...

class FCurveDesc(System.ValueType):
    CompressionFormat: 'CUE4Parse.UE4.Objects.Engine.Curves.ERichCurveCompressionFormat' = ...
    KeyTimeCompressionFormat: 'CUE4Parse.UE4.Objects.Engine.Curves.ERichCurveKeyTimeCompressionFormat' = ...
    PreInfinityExtrap: 'CUE4Parse.UE4.Objects.Engine.Curves.ERichCurveExtrapolation' = ...
    PostInfinityExtrap: 'CUE4Parse.UE4.Objects.Engine.Curves.ERichCurveExtrapolation' = ...
    NumKeys: 'int' = ...
    KeyDataOffset: 'int' = ...
    ConstantValue: 'float' = ...

class UAnimCurveCompressionCodec_CompressedRichCurve(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    ConverterMap: 'List[List[CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec_CompressedRichCurve.CompressedCurveConverter]]' = ...
    def ConvertCurves(self, animSeq: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequence') -> 'List[CUE4Parse.UE4.Assets.Exports.Animation.FFloatCurve]': ...

class UAnimCurveCompressionCodec_UniformIndexable(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    def ConvertCurves(self, animSeq: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequence') -> 'List[CUE4Parse.UE4.Assets.Exports.Animation.FFloatCurve]': ...

class UAnimCurveCompressionCodec_UniformlySampled(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    def ConvertCurves(self, animSeq: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequence') -> 'List[CUE4Parse.UE4.Assets.Exports.Animation.FFloatCurve]': ...

class UAnimCurveCompressionSettings(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    Codec: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...
    def GetCodec(self, path: 'str') -> 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec': ...

class EAnimAssetCurveFlags(enum.Enum):
    AACF_NONE = ...
    AACF_Editable = ...
    AACF_Metadata = ...

class FAnimCurveBase:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    CurveName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    CurveTypeFlags: 'int' = ...

class FFloatCurve(CUE4Parse.UE4.Assets.Exports.Animation.FAnimCurveBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    FloatCurve: 'CUE4Parse.UE4.Objects.Engine.Curves.FRichCurve' = ...

class FRawCurveTracks(System.ValueType):
    def __init__(self, data: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    FloatCurves: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FFloatCurve]' = ...

class FAnimLinkableElement:
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    LinkedMontage: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    SlotIndex: 'int' = ...
    SegmentIndex: 'int' = ...
    LinkMethod: 'CUE4Parse.UE4.Assets.Exports.Animation.EAnimLinkMethod' = ...
    CachedLinkMethod: 'CUE4Parse.UE4.Assets.Exports.Animation.EAnimLinkMethod' = ...
    SegmentBeginTime: 'float' = ...
    SegmentLength: 'float' = ...
    LinkValue: 'float' = ...
    LinkedSequence: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...

class EAnimLinkMethod(enum.Enum):
    Absolute = ...
    Relative = ...
    Proportional = ...

class UAnimMontage(CUE4Parse.UE4.Assets.Exports.Animation.UAnimCompositeBase, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    CompositeSections: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FCompositeSection]' = ...
    SlotAnimTracks: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FSlotAnimationTrack]' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...
    def CalculateSequenceLength(self) -> 'float': ...

class FCompositeSection(CUE4Parse.UE4.Assets.Exports.Animation.FAnimLinkableElement):
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    SectionName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    NextSectionName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    MetaData: 'List[CUE4Parse.UE4.Assets.Exports.Animation.UAnimMetaData]' = ...

class FSlotAnimationTrack:
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    SlotName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    AnimTrack: 'CUE4Parse.UE4.Assets.Exports.Animation.FAnimTrack' = ...

class UAnimSequenceBase(CUE4Parse.UE4.Assets.Exports.Animation.UAnimationAsset, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    SequenceLength: 'float' = ...
    RateScale: 'float' = ...
    Notifies: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FAnimNotifyEvent]' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

class FAnimNotifyEvent(CUE4Parse.UE4.Assets.Exports.Animation.FAnimLinkableElement):
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    TriggerTimeOffset: 'float' = ...
    EndTriggerTimeOffset: 'float' = ...
    TriggerWeightThreshold: 'float' = ...
    NotifyName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    Notify: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    NotifyStateClass: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    Duration: 'float' = ...
    EndLink: 'CUE4Parse.UE4.Assets.Exports.Animation.FAnimLinkableElement' = ...
    bConvertedFromBranchingPoint: 'bool' = ...
    MontageTickType: 'CUE4Parse.UE4.Assets.Exports.Animation.EMontageNotifyTickType' = ...
    NotifyTriggerChance: 'float' = ...
    NotifyFilterType: 'CUE4Parse.UE4.Assets.Exports.Animation.EMontageNotifyTickType' = ...
    NotifyFilterLOD: 'int' = ...
    bTriggerOnDedicatedServer: 'bool' = ...
    bTriggerOnFollower: 'bool' = ...
    TrackIndex: 'int' = ...

class EMontageNotifyTickType(enum.Enum):
    Queued = ...
    BranchingPoint = ...

class EAdditiveAnimationType(enum.Enum):
    AAT_None = ...
    AAT_LocalSpaceBase = ...
    AAT_RotationOffsetMeshSpace = ...
    AAT_MAX = ...

class EAdditiveBasePoseType(enum.Enum):
    ABPT_None = ...
    ABPT_RefPose = ...
    ABPT_AnimScaled = ...
    ABPT_AnimFrame = ...
    ABPT_LocalAnimFrame = ...
    ABPT_MAX = ...

class EAnimInterpolationType(enum.Enum):
    Linear = ...
    Step = ...

class EBoneTranslationRetargetingMode(enum.Enum):
    Animation = ...
    Skeleton = ...
    AnimationScaled = ...
    AnimationRelative = ...
    OrientAndScale = ...

class FAnimCurveType(System.ValueType):
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    bMaterial: 'bool' = ...
    bMorphtarget: 'bool' = ...

class FBoneNode(System.ValueType, CUE4Parse.UE4.IUStruct):
    TranslationRetargetingMode: 'CUE4Parse.UE4.Assets.Exports.Animation.EBoneTranslationRetargetingMode' = ...

class FCompressedSegment(System.ValueType):
    StartFrame: 'int' = ...
    NumFrames: 'int' = ...
    ByteStreamOffset: 'int' = ...
    TranslationCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...
    RotationCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...
    ScaleCompressionFormat: 'CUE4Parse.UE4.Assets.Exports.Animation.AnimationCompressionFormat' = ...

class FDeltaBatchHeader(System.ValueType):
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    DataOffset: 'System.UInt32' = ...
    NumElements: 'System.UInt32' = ...
    bTangents: 'bool' = ...
    IndexBits: 'System.SByte' = ...
    PositionBits: 'CUE4Parse.UE4.Objects.Core.Math.TIntVector3[System.SByte]' = ...
    TangentZBits: 'CUE4Parse.UE4.Objects.Core.Math.TIntVector3[System.SByte]' = ...
    IndexMin: 'System.UInt32' = ...
    PositionMin: 'CUE4Parse.UE4.Objects.Core.Math.FIntVector' = ...
    TangentZMin: 'CUE4Parse.UE4.Objects.Core.Math.FIntVector' = ...

class FMeshBoneInfo(System.ValueType):
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    @overload
    def __init__(self, name: 'CUE4Parse.UE4.Objects.UObject.FName', parentIndex: 'int') -> None: ...
    Name: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    ParentIndex: 'int' = ...
    def ToString(self) -> 'str': ...

class FMorphTargetDelta:
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, pos: 'CUE4Parse.UE4.Objects.Core.Math.FVector', tan: 'CUE4Parse.UE4.Objects.Core.Math.FVector', index: 'System.UInt32') -> None: ...
    PositionDelta: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    TangentZDelta: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    SourceIdx: 'System.UInt32' = ...

class FMorphTargetLODModel:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, buffer: 'CUE4Parse.UE4.Assets.Exports.SkeletalMesh.FMorphTargetVertexInfoBuffers', index: 'int', sectionIndices: 'List[int]') -> None: ...
    Vertices: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FMorphTargetDelta]' = ...
    NumBaseMeshVerts: 'int' = ...
    SectionIndices: 'List[int]' = ...
    bGeneratedByEngine: 'bool' = ...
    SourceFilename: 'str' = ...

class FRawAnimSequenceTrack(CUE4Parse.UE4.IUStruct):
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    PosKeys: 'List[CUE4Parse.UE4.Objects.Core.Math.FVector]' = ...
    RotKeys: 'List[CUE4Parse.UE4.Objects.Core.Math.FQuat]' = ...
    ScaleKeys: 'List[CUE4Parse.UE4.Objects.Core.Math.FVector]' = ...

class FReferencePose(System.ValueType):
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    PoseName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    ReferencePose: 'List[CUE4Parse.UE4.Objects.Core.Math.FTransform]' = ...

class FReferenceSkeleton:
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    FinalRefBoneInfo: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FMeshBoneInfo]' = ...
    FinalRefBonePose: 'List[CUE4Parse.UE4.Objects.Core.Math.FTransform]' = ...
    FinalNameToIndexMap: 'System.Collections.Generic.Dictionary[str, int]' = ...
    def AdjustBoneScales(self, transforms: 'List[CUE4Parse.UE4.Objects.Core.Math.FTransform]') -> None: ...
    def GetBoneScale(self, transforms: 'List[CUE4Parse.UE4.Objects.Core.Math.FTransform]', boneIndex: 'int') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...

class FSmartNameMapping:
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    GuidMap: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Objects.UObject.FName, CUE4Parse.UE4.Objects.Core.Misc.FGuid]' = ...
    UidMap: 'System.Collections.Generic.Dictionary[System.UInt16, CUE4Parse.UE4.Objects.UObject.FName]' = ...
    CurveMetaDataMap: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Objects.UObject.FName, CUE4Parse.UE4.Objects.Engine.Curves.FCurveMetaData]' = ...

class FTrackToSkeletonMap(System.ValueType):
    BoneTreeIndex: 'int' = ...

class UAnimationAsset(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    Skeleton: 'CUE4Parse.UE4.Objects.UObject.FPackageIndex' = ...
    SkeletonGuid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

class UAnimMetaData(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...

class UAnimSequence(CUE4Parse.UE4.Assets.Exports.Animation.UAnimSequenceBase, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    NumFrames: 'int' = ...
    TrackToSkeletonMapTable: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FTrackToSkeletonMap]' = ...
    RawAnimationData: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FRawAnimSequenceTrack]' = ...
    BoneCompressionSettings: 'CUE4Parse.UE4.Assets.ResolvedObject' = ...
    CurveCompressionSettings: 'CUE4Parse.UE4.Assets.ResolvedObject' = ...
    CompressedTrackToSkeletonMapTable: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FTrackToSkeletonMap]' = ...
    CompressedCurveNames: 'List[CUE4Parse.UE4.Objects.Engine.Animation.FSmartName]' = ...
    CompressedCurveByteStream: 'List[int]' = ...
    CompressedCurveData: 'CUE4Parse.UE4.Assets.Exports.Animation.FRawCurveTracks' = ...
    CompressedDataStructure: 'CUE4Parse.UE4.Assets.Exports.Animation.ICompressedAnimData' = ...
    BoneCompressionCodec: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimBoneCompressionCodec' = ...
    CurveCompressionCodec: 'CUE4Parse.UE4.Assets.Exports.Animation.UAnimCurveCompressionCodec' = ...
    CompressedRawDataSize: 'int' = ...
    AdditiveAnimType: 'CUE4Parse.UE4.Assets.Exports.Animation.EAdditiveAnimationType' = ...
    RefPoseType: 'CUE4Parse.UE4.Assets.Exports.Animation.EAdditiveBasePoseType' = ...
    RefPoseSeq: 'CUE4Parse.UE4.Assets.ResolvedObject' = ...
    RefFrameIndex: 'int' = ...
    RetargetSource: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    RetargetSourceAssetReferencePose: 'List[CUE4Parse.UE4.Objects.Core.Math.FTransform]' = ...
    Interpolation: 'CUE4Parse.UE4.Assets.Exports.Animation.EAnimInterpolationType' = ...
    bUseRawDataOnly: 'bool' = ...
    EnsuredCurveData: 'bool' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...
    def IsValidAdditive(self) -> 'bool': ...
    def GetNumTracks(self) -> 'int': ...
    def GetTrackBoneIndex(self, trackIndex: 'int') -> 'int': ...
    def GetTrackMap(self) -> 'List[CUE4Parse.UE4.Assets.Exports.Animation.FTrackToSkeletonMap]': ...
    def FindTrackForBoneIndex(self, boneIndex: 'int') -> 'int': ...

class UMorphTarget(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    MorphLODModels: 'List[CUE4Parse.UE4.Assets.Exports.Animation.FMorphTargetLODModel]' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

class URig(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    SourceSkeleton: 'CUE4Parse.UE4.Assets.Exports.Animation.FReferenceSkeleton' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

class USkeleton(CUE4Parse.UE4.Assets.Exports.UObject, CUE4Parse.UE4.Assets.Exports.IPropertyHolder):
    def __init__(self) -> None: ...
    BoneTree: 'List[CUE4Parse.UE4.Assets.Exports.Animation.EBoneTranslationRetargetingMode]' = ...
    ReferenceSkeleton: 'CUE4Parse.UE4.Assets.Exports.Animation.FReferenceSkeleton' = ...
    Guid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    VirtualBoneGuid: 'CUE4Parse.UE4.Objects.Core.Misc.FGuid' = ...
    AnimRetargetSources: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Objects.UObject.FName, CUE4Parse.UE4.Assets.Exports.Animation.FReferencePose]' = ...
    NameMappings: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Objects.UObject.FName, CUE4Parse.UE4.Assets.Exports.Animation.FSmartNameMapping]' = ...
    ExistingMarkerNames: 'List[CUE4Parse.UE4.Objects.UObject.FName]' = ...
    Sockets: 'List[CUE4Parse.UE4.Objects.UObject.FPackageIndex]' = ...
    VirtualBones: 'List[FVirtualBone]' = ...
    BoneCount: 'int' = ...
    def Deserialize(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive', validPos: 'int') -> None: ...

from . import PoseSearch as PoseSearch
from . import DeformerGraph as DeformerGraph
from . import CurveExpression as CurveExpression
from . import ACL as ACL
