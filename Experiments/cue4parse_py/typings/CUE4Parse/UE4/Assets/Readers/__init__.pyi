from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FAssetArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, baseArchive: 'CUE4Parse.UE4.Readers.FArchive', owner: 'CUE4Parse.UE4.Assets.IPackage', absoluteOffset: 'int', payloads: 'System.Collections.Generic.Dictionary[CUE4Parse.UE4.Assets.Utils.PayloadType, System.Func[Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader], CUE4Parse.UE4.Assets.Readers.FAssetArchive]]') -> None: ...
    Owner: 'CUE4Parse.UE4.Assets.IPackage' = ...
    AbsoluteOffset: 'int' = ...
    HasUnversionedProperties: 'bool' = ...
    IsFilterEditorOnly: 'bool' = ...
    IsLoadingFromCookedPackage: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    AbsolutePosition: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def TestReadFName(self) -> 'bool': ...
    def ReadObject(self) -> 'System.Lazy[T]': ...
    def ReadUObject(self) -> 'CUE4Parse.UE4.Assets.Exports.UObject': ...
    def TryGetPayload(self, type: 'CUE4Parse.UE4.Assets.Utils.PayloadType', header: 'Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader]') -> Tuple['bool', 'CUE4Parse.UE4.Assets.Readers.FAssetArchive']: ...
    def GetPayload(self, type: 'CUE4Parse.UE4.Assets.Utils.PayloadType', header: 'Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader]') -> 'CUE4Parse.UE4.Assets.Readers.FAssetArchive': ...
    @overload
    def AddPayload(self, type: 'CUE4Parse.UE4.Assets.Utils.PayloadType', payload: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    @overload
    def AddPayload(self, type: 'CUE4Parse.UE4.Assets.Utils.PayloadType', absoluteOffset: 'int', payload: 'System.Func[Optional[CUE4Parse.UE4.Assets.Objects.FByteBulkDataHeader], CUE4Parse.UE4.Readers.FArchive]') -> None: ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def ReadAt(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadAtAsync(self, position: 'int', buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAtAsync(self, position: 'int', memory: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SeekAbsolute(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    def Clone(self) -> 'Any': ...

class FBitArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', data: 'List[int]') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, length: 'System.UInt32') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def ReadIntVector(self, bits: 'CUE4Parse.UE4.Objects.Core.Math.TIntVector3[System.UInt32]') -> 'CUE4Parse.UE4.Objects.Core.Math.FIntVector': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...

class FKismetArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, name: 'str', data: 'List[int]', owner: 'CUE4Parse.UE4.Assets.IPackage', versions: 'CUE4Parse.UE4.Versions.VersionContainer') -> None: ...
    Owner: 'CUE4Parse.UE4.Assets.IPackage' = ...
    Index: 'int' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    def ReadExpression(self) -> 'CUE4Parse.UE4.Kismet.KismetExpression': ...
    def XFERSTRING(self) -> 'str': ...
    def XFERUNICODESTRING(self) -> 'str': ...
    def ReadExpressionArray(self, endToken: 'CUE4Parse.UE4.Kismet.EExprToken') -> 'List[CUE4Parse.UE4.Kismet.KismetExpression]': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...

class FObjectAndNameAsStringProxyArchive(CUE4Parse.UE4.Assets.Readers.FAssetArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive', owner: 'CUE4Parse.UE4.Assets.IPackage', absoluteOffset: 'int') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    Name: 'str' = ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self) -> 'T': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def ReadBytes(self, length: 'int') -> 'List[int]': ...
    def Serialize(self, ptr: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def ReadArray(self, length: 'int') -> 'List[T]': ...
    @overload
    def ReadArray(self, array: 'List[T]') -> None: ...
    def Clone(self) -> 'Any': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...
    def ReadObject(self) -> 'System.Lazy[T]': ...

class FRigHierarchyArchive(CUE4Parse.UE4.Readers.FArchive, System.IDisposable, System.IAsyncDisposable, System.ICloneable):
    def __init__(self, baseArchive: 'CUE4Parse.UE4.Readers.FArchive', names: 'List[CUE4Parse.UE4.Objects.UObject.FName]') -> None: ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Name: 'str' = ...
    Position: 'int' = ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def Clone(self) -> 'Any': ...
    def ReadFName(self) -> 'CUE4Parse.UE4.Objects.UObject.FName': ...

