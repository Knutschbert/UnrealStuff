from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FGameplayTagContainer(System.ValueType, CUE4Parse.UE4.IUStruct, List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag], System.Collections.IEnumerable):
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    @overload
    def __init__(self, gameplayTags: 'List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]') -> None: ...
    GameplayTags: 'List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]' = ...
    def HasTag(self, tagToCheck: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag') -> 'bool': ...
    def HasAny(self, containerToCheck: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagContainer') -> 'bool': ...
    def HasAll(self, containerToCheck: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagContainer') -> 'bool': ...
    def MatchesQuery(self, query: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagQuery') -> 'bool': ...
    def IsValid(self) -> 'bool': ...
    def IsEmpty(self) -> 'bool': ...
    def GetValue(self, category: 'str') -> 'Optional[CUE4Parse.UE4.Objects.UObject.FName]': ...
    def GetEnumerator(self) -> 'System.Collections.Generic.IEnumerator[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]': ...
    def ToString(self) -> 'str': ...

class FGameplayTag(System.ValueType):
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Assets.Readers.FAssetArchive') -> None: ...
    @overload
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    @overload
    def __init__(self, tagName: 'CUE4Parse.UE4.Objects.UObject.FName') -> None: ...
    TagName: 'CUE4Parse.UE4.Objects.UObject.FName' = ...
    def IsValid(self) -> 'bool': ...
    @overload
    def Equals(self, other: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class EGameplayTagQueryStreamVersion(enum.Enum):
    InitialVersion = ...
    LatestVersion = ...
    VersionPlusOne = ...

class FGameplayTagQuery:
    def __init__(self, fallback: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    TokenStreamVersion: 'CUE4Parse.UE4.Objects.GameplayTags.EGameplayTagQueryStreamVersion' = ...
    TagDictionary: 'List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]' = ...
    QueryTokenStream: 'List[int]' = ...
    UserDescription: 'str' = ...
    AutoDescription: 'str' = ...
    def Matches(self, tags: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagContainer') -> 'bool': ...
    def GetTagFromIndex(self, idx: 'int') -> 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag': ...

class EGameplayTagQueryExprType(enum.Enum):
    Undefined = ...
    AnyTagsMatch = ...
    AllTagsMatch = ...
    NoTagsMatch = ...
    AnyExprMatch = ...
    AllExprMatch = ...
    NoExprMatch = ...

class FQueryEvaluator:
    def __init__(self, query: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagQuery') -> None: ...
    def Eval(self, tags: 'CUE4Parse.UE4.Objects.GameplayTags.FGameplayTagContainer') -> 'bool': ...

class FGameplayTagContainerUtility:
    @staticmethod
    def TryGetGameplayTag(gameplayTags: 'List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]', startWith: 'str') -> Tuple['bool', 'CUE4Parse.UE4.Objects.UObject.FName']: ...
    @staticmethod
    def GetAllGameplayTags(gameplayTags: 'List[CUE4Parse.UE4.Objects.GameplayTags.FGameplayTag]', startWith: 'List[str]') -> 'System.Collections.Generic.IList[str]': ...

