from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FBox(System.ValueType, CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self, min: 'CUE4Parse.UE4.Objects.Core.Math.FVector', max: 'CUE4Parse.UE4.Objects.Core.Math.FVector', isValid: 'int') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, points: 'List[CUE4Parse.UE4.Objects.Core.Math.FVector]') -> None: ...
    @overload
    def __init__(self, box: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> None: ...
    Min: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    Max: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    IsValid: 'int' = ...
    __getitem__: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    @overload
    def Equals(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ComputeSquaredDistanceToPoint(self, point: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    @overload
    def ExpandBy(self, w: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    @overload
    def ExpandBy(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    @overload
    def ExpandBy(self, neg: 'CUE4Parse.UE4.Objects.Core.Math.FVector', pos: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    def ShiftBy(self, offset: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    def MoveTo(self, destination: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    def GetCenter(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetCenterAndExtents(self) -> Tuple['CUE4Parse.UE4.Objects.Core.Math.FVector', 'CUE4Parse.UE4.Objects.Core.Math.FVector']: ...
    def GetClosestPointTo(self, point: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetExtent(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetSize(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetVolume(self) -> 'float': ...
    def Intersects(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'bool': ...
    def IntersectsXY(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'bool': ...
    def Overlap(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    @overload
    def IsInside(self, in: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'bool': ...
    @overload
    def IsInside(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'bool': ...
    def IsInsideOrOn(self, in: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'bool': ...
    @overload
    def IsInsideXY(self, in: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'bool': ...
    @overload
    def IsInsideXY(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> 'bool': ...
    @overload
    def TransformBy(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    @overload
    def TransformBy(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FTransform') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    def ToString(self) -> 'str': ...
    @staticmethod
    def BuildAABB(origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector', extent: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...

class FBox2D(CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Min: 'CUE4Parse.UE4.Objects.Core.Math.FVector2D' = ...
    Max: 'CUE4Parse.UE4.Objects.Core.Math.FVector2D' = ...
    bIsValid: 'int' = ...
    def ToString(self) -> 'str': ...

class FBoxSphereBounds:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector', boxExtent: 'CUE4Parse.UE4.Objects.Core.Math.FVector', sphereRadius: 'float') -> None: ...
    @overload
    def __init__(self, box: 'CUE4Parse.UE4.Objects.Core.Math.FBox', sphere: 'CUE4Parse.UE4.Objects.Core.Math.FSphere') -> None: ...
    @overload
    def __init__(self, box: 'CUE4Parse.UE4.Objects.Core.Math.FBox') -> None: ...
    @overload
    def __init__(self, sphere: 'CUE4Parse.UE4.Objects.Core.Math.FSphere') -> None: ...
    Origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    BoxExtent: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    SphereRadius: 'float' = ...
    def GetBox(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FBox': ...
    @overload
    def TransformBy(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix') -> 'CUE4Parse.UE4.Objects.Core.Math.FBoxSphereBounds': ...
    @overload
    def TransformBy(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FTransform') -> 'CUE4Parse.UE4.Objects.Core.Math.FBoxSphereBounds': ...
    def ToString(self) -> 'str': ...

class FColor(System.ValueType, CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self, b: 'int') -> None: ...
    @overload
    def __init__(self, r: 'int', g: 'int', b: 'int') -> None: ...
    @overload
    def __init__(self, r: 'int', g: 'int', b: 'int', a: 'int') -> None: ...
    B: 'int' = ...
    G: 'int' = ...
    R: 'int' = ...
    A: 'int' = ...
    Gray: 'CUE4Parse.UE4.Objects.Core.Math.FColor' = ...
    Hex: 'str' = ...
    def Serialize(self, Ar: 'CUE4Parse.UE4.Writers.FArchiveWriter') -> None: ...
    def ToString(self) -> 'str': ...
    @staticmethod
    def Requantize16to8(value16: 'int') -> 'int': ...
    def ToPackedARGB(self) -> 'int': ...

class FFloat16(CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, FP16Value: 'CUE4Parse.UE4.Objects.Core.Math.FFloat16') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Encoded: 'System.UInt16' = ...

class FHalfVector(System.ValueType):
    def __init__(self, x: 'System.Half', y: 'System.Half', z: 'System.Half') -> None: ...
    X: 'System.Half' = ...
    Y: 'System.Half' = ...
    Z: 'System.Half' = ...

class FHalfVector4(System.ValueType):
    def __init__(self, x: 'System.Half', y: 'System.Half', z: 'System.Half', w: 'System.Half') -> None: ...
    X: 'System.Half' = ...
    Y: 'System.Half' = ...
    Z: 'System.Half' = ...
    W: 'System.Half' = ...

class FIntPoint(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, x: 'int', y: 'int') -> None: ...
    X: 'int' = ...
    Y: 'int' = ...
    def ToString(self) -> 'str': ...

class FIntRect(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, min: 'CUE4Parse.UE4.Objects.Core.Math.FIntPoint', max: 'CUE4Parse.UE4.Objects.Core.Math.FIntPoint') -> None: ...
    Min: 'CUE4Parse.UE4.Objects.Core.Math.FIntPoint' = ...
    Max: 'CUE4Parse.UE4.Objects.Core.Math.FIntPoint' = ...

class FIntVector(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, x: 'int', y: 'int', z: 'int') -> None: ...
    X: 'int' = ...
    Y: 'int' = ...
    Z: 'int' = ...
    Zero: 'CUE4Parse.UE4.Objects.Core.Math.FIntVector' = ...
    def ToString(self) -> 'str': ...

class FLinearColor(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, r: 'float', g: 'float', b: 'float', a: 'float') -> None: ...
    R: 'float' = ...
    G: 'float' = ...
    B: 'float' = ...
    A: 'float' = ...
    Gray: 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor' = ...
    Hex: 'str' = ...
    def ToFColor(self, sRGB: 'bool') -> 'CUE4Parse.UE4.Objects.Core.Math.FColor': ...
    def ToSRGB(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor': ...
    def ToString(self) -> 'str': ...
    def WithAlpha(self, alpha: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor': ...
    def LinearRGBToHsv(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor': ...
    def HSVToLinearRGB(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor': ...

class FPlane(System.ValueType, CUE4Parse.UE4.IUStruct, System.IEquatable[CUE4Parse.UE4.Objects.Core.Math.FPlane]):
    @overload
    def __init__(self, base: 'CUE4Parse.UE4.Objects.Core.Math.FVector', normal: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float', w: 'float') -> None: ...
    @overload
    def __init__(self, vector: 'TIntVector3[float]', w: 'float') -> None: ...
    @overload
    def __init__(self, vector: 'TIntVector3[float]', w: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Vector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    W: 'float' = ...
    X: 'float' = ...
    Y: 'float' = ...
    Z: 'float' = ...
    def PlaneDot(self, p: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    @overload
    def Equals(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FPlane', tolerance: 'float') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FPlane') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class EForceInit(enum.Enum):
    ForceInit = ...
    ForceInitToZero = ...

class FQuat(System.ValueType, CUE4Parse.UE4.IUStruct, System.IEquatable[CUE4Parse.UE4.Objects.Core.Math.FQuat]):
    @overload
    def __init__(self, zeroOrNot: 'CUE4Parse.UE4.Objects.Core.Math.EForceInit') -> None: ...
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float', w: 'float') -> None: ...
    @overload
    def __init__(self, quat: 'TIntVector4[float]') -> None: ...
    @overload
    def __init__(self, quat: 'TIntVector4[float]') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix') -> None: ...
    @overload
    def __init__(self, rotator: 'CUE4Parse.UE4.Objects.Core.Math.FRotator') -> None: ...
    @overload
    def __init__(self, axis: 'CUE4Parse.UE4.Objects.Core.Math.FVector', angleRad: 'float') -> None: ...
    X: 'float' = ...
    Y: 'float' = ...
    Z: 'float' = ...
    W: 'float' = ...
    Identity: 'CUE4Parse.UE4.Objects.Core.Math.FQuat' = ...
    THRESH_QUAT_NORMALIZED: 'float' = ...
    IsNormalized: 'bool' = ...
    Size: 'float' = ...
    SizeSquared: 'float' = ...
    @overload
    def Equals(self, q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', tolerance: 'float') -> 'bool': ...
    @overload
    def Equals(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def IsIdentity(self, tolerance: 'float') -> 'bool': ...
    def IsVectorZero(self) -> 'bool': ...
    @staticmethod
    def AsVector128(value: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'System.Runtime.Intrinsics.Vector128[float]': ...
    def Normalize(self, tolerance: 'float') -> None: ...
    def GetNormalized(self, tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def RotateVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def UnrotateVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def Inverse(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @overload
    def Conjugate(self) -> None: ...
    @staticmethod
    @overload
    def Conjugate(quat: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def FindBetweenNormals(a: 'CUE4Parse.UE4.Objects.Core.Math.FVector', b: 'CUE4Parse.UE4.Objects.Core.Math.FVector', normAb: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def Rotator(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    def ContainsNaN(self) -> 'bool': ...
    def ToString(self) -> 'str': ...
    def Serialize(self, Ar: 'CUE4Parse.UE4.Writers.FArchiveWriter') -> None: ...
    @staticmethod
    def FastLerp(q1: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', q2: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', alpha: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def Slerp_NotNormalized(quat1: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', quat2: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', Slerp: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def Slerp(quat1: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', quat2: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', slerp: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def GetHashCode(self) -> 'int': ...

class FRotator(System.ValueType, CUE4Parse.UE4.IUStruct, System.IEquatable[CUE4Parse.UE4.Objects.Core.Math.FRotator]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, forceInit: 'CUE4Parse.UE4.Objects.Core.Math.EForceInit') -> None: ...
    @overload
    def __init__(self, f: 'float') -> None: ...
    @overload
    def __init__(self, pitch: 'float', yaw: 'float', roll: 'float') -> None: ...
    @overload
    def __init__(self, pitch: 'float', yaw: 'float', roll: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Pitch: 'float' = ...
    Yaw: 'float' = ...
    Roll: 'float' = ...
    ZeroRotator: 'CUE4Parse.UE4.Objects.Core.Math.FRotator' = ...
    def RotateVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def UnrotateVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def Vector(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def Quaternion(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def Normalize(self) -> None: ...
    def GetNormalized(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    @staticmethod
    def ClampAxis(angle: 'float') -> 'float': ...
    @staticmethod
    def NormalizeAxis(angle: 'float') -> 'float': ...
    @staticmethod
    def CompressAxisToByte(angle: 'float') -> 'int': ...
    @staticmethod
    def DecompressAxisFromByte(angle: 'int') -> 'float': ...
    @staticmethod
    def CompressAxisToShort(angle: 'float') -> 'System.UInt16': ...
    @staticmethod
    def DecompressAxisFromShort(angle: 'System.UInt16') -> 'float': ...
    @overload
    def Equals(self, r: 'CUE4Parse.UE4.Objects.Core.Math.FRotator', tolerance: 'float') -> 'bool': ...
    @overload
    def Equals(self, r: 'CUE4Parse.UE4.Objects.Core.Math.FRotator') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def Serialize(self, Ar: 'CUE4Parse.UE4.Writers.FArchiveWriter') -> None: ...
    def ToString(self) -> 'str': ...
    def GetHashCode(self) -> 'int': ...

class FSphere(CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float', w: 'float') -> None: ...
    @overload
    def __init__(self, center: 'CUE4Parse.UE4.Objects.Core.Math.FVector', w: 'float') -> None: ...
    @overload
    def __init__(self, center: 'TIntVector3[float]', w: 'float') -> None: ...
    @overload
    def __init__(self, center: 'TIntVector3[float]', w: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    Center: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    W: 'float' = ...

class FTransform(System.ValueType, CUE4Parse.UE4.IUStruct, System.ICloneable):
    @overload
    def __init__(self, init: 'CUE4Parse.UE4.Objects.Core.Math.EForceInit') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, translation: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, rotation: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> None: ...
    @overload
    def __init__(self, rotation: 'CUE4Parse.UE4.Objects.Core.Math.FRotator') -> None: ...
    @overload
    def __init__(self, rotation: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', translation: 'CUE4Parse.UE4.Objects.Core.Math.FVector', scale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, rotation: 'CUE4Parse.UE4.Objects.Core.Math.FRotator', translation: 'CUE4Parse.UE4.Objects.Core.Math.FVector', scale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, data: 'CUE4Parse.UE4.Assets.Objects.FStructFallback') -> None: ...
    @overload
    def __init__(self, inX: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inY: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inZ: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inW: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    Rotation: 'CUE4Parse.UE4.Objects.Core.Math.FQuat' = ...
    Translation: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    Scale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    Identity: 'CUE4Parse.UE4.Objects.Core.Math.FTransform' = ...
    IsRotationNormalized: 'bool' = ...
    def SetFromMatrix(self, inMatrix: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix') -> None: ...
    def SetRotation(self, rotation: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> None: ...
    def SetLocation(self, origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    def SetScale3D(self, scale: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    def Rotator(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    def GetDeterminant(self) -> 'float': ...
    def Equals(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FTransform', tolerance: 'float') -> 'bool': ...
    def ContainsNaN(self) -> 'bool': ...
    @staticmethod
    def AnyHasNegativeScale(scale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector', otherScale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'bool': ...
    @overload
    def ScaleTranslation(self, scale3D: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def ScaleTranslation(self, scale: 'float') -> None: ...
    def RemoveScaling(self, tolerance: 'float') -> None: ...
    def GetMaximumAxisScale(self) -> 'float': ...
    def GetMinimumAxisScale(self) -> 'float': ...
    def CopyTranslation(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def CopyRotation(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def CopyScale3D(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def Inverse(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def GetRelativeTransform(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FTransform') -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    @staticmethod
    def SubstractTranslations(a: 'CUE4Parse.UE4.Objects.Core.Math.FTransform', b: 'CUE4Parse.UE4.Objects.Core.Math.FTransform') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetRelativeTransformUsingMatrixWithScale(self) -> Tuple['CUE4Parse.UE4.Objects.Core.Math.FTransform', 'CUE4Parse.UE4.Objects.Core.Math.FTransform']: ...
    @staticmethod
    def ConstructTransformFromMatrixWithDesiredScale(aMatrix: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix', bMatrix: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix', desiredScale: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def ToMatrixWithScale(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FMatrix': ...
    @staticmethod
    def GetSafeScaleReciprocal(scale: 'CUE4Parse.UE4.Objects.Core.Math.FVector', tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def MultiplyUsingMatrixWithScale() -> Tuple['CUE4Parse.UE4.Objects.Core.Math.FTransform', 'CUE4Parse.UE4.Objects.Core.Math.FTransform', 'CUE4Parse.UE4.Objects.Core.Math.FTransform']: ...
    def TransformPosition(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def TransformPositionNoScale(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def InverseTransformPosition(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def InverseTransformPositionNoScale(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def TransformVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def TransformVectorNoScale(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def TransformRotation(self, q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def InverseTransformRotation(self, q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @overload
    def GetScaled(self, scale: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    @overload
    def GetScaled(self, scale: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FTransform': ...
    def GetScaledAxis(self, axis: 'CUE4Parse.UE4.Objects.Core.Math.EAxis') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetUnitAxis(self, axis: 'CUE4Parse.UE4.Objects.Core.Math.EAxis') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def ToString(self) -> 'str': ...
    def Clone(self) -> 'Any': ...

class FTwoVectors(System.ValueType, CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self, v1: 'CUE4Parse.UE4.Objects.Core.Math.FVector', v2: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    V1: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    V2: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    def ToString(self) -> 'str': ...

class FUInt128(CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a: 'System.UInt64') -> None: ...
    @overload
    def __init__(self, a: 'System.UInt64', b: 'System.UInt64') -> None: ...
    @overload
    def __init__(self, A: 'System.UInt32', B: 'System.UInt32', C: 'System.UInt32', D: 'System.UInt32') -> None: ...
    Hi: 'System.UInt64' = ...
    Lo: 'System.UInt64' = ...
    def SetQuadPart(self, part: 'System.UInt32', value: 'System.UInt32') -> None: ...
    def GetQuadPart(self, part: 'System.UInt32') -> 'System.UInt32': ...
    def DivideInternal(self, dividend: 'System.UInt32', divisor: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    def IsGreater(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FUInt128') -> 'bool': ...
    def IsLess(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FUInt128') -> 'bool': ...
    def Divide(self, divisor: 'System.UInt32') -> Tuple['CUE4Parse.UE4.Objects.Core.Math.FUInt128', 'System.UInt32']: ...
    def ToString(self) -> 'str': ...

class FUIntVector(System.ValueType, CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self, x: 'System.UInt32', y: 'System.UInt32', z: 'System.UInt32') -> None: ...
    @overload
    def __init__(self, x: 'int', y: 'int', z: 'int') -> None: ...
    X: 'System.UInt32' = ...
    Y: 'System.UInt32' = ...
    Z: 'System.UInt32' = ...
    Zero: 'CUE4Parse.UE4.Objects.Core.Math.FUIntVector' = ...
    def ToString(self) -> 'str': ...

class FVector(System.ValueType, CUE4Parse.UE4.IUStruct, System.IEquatable[CUE4Parse.UE4.Objects.Core.Math.FVector]):
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float') -> None: ...
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, f: 'float') -> None: ...
    @overload
    def __init__(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector2D', z: 'float') -> None: ...
    @overload
    def __init__(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector4') -> None: ...
    @overload
    def __init__(self, color: 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor') -> None: ...
    @overload
    def __init__(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FIntVector') -> None: ...
    @overload
    def __init__(self, p: 'CUE4Parse.UE4.Objects.Core.Math.FIntPoint') -> None: ...
    X: 'float' = ...
    Y: 'float' = ...
    Z: 'float' = ...
    ZeroVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    OneVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    UpVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    ForwardVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    RightVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector' = ...
    ThreshVectorNormalized: 'float' = ...
    __getitem__: 'float' = ...
    @overload
    def Set(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @overload
    def Set(self, x: 'float', y: 'float', z: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetSignVector(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @overload
    def Scale(self, scale: 'float') -> None: ...
    @overload
    def Scale(self, scale: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector', tolerance: 'float') -> 'bool': ...
    @overload
    def Equals(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def AllComponentsEqual(self, tolerance: 'float') -> 'bool': ...
    def Max(self) -> 'float': ...
    def AbsMax(self) -> 'float': ...
    def Min(self) -> 'float': ...
    def AbsMin(self) -> 'float': ...
    def ComponentMax(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def ComponentMin(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def Abs(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def Size(self) -> 'float': ...
    def SizeSquared(self) -> 'float': ...
    def Size2D(self) -> 'float': ...
    def SizeSquared2D(self) -> 'float': ...
    def ContainsNaN(self) -> 'bool': ...
    def IsNearlyZero(self, tolerance: 'float') -> 'bool': ...
    def IsZero(self) -> 'bool': ...
    def IsUnit(self, lengthSquaredTolerance: 'float') -> 'bool': ...
    def IsNormalized(self) -> 'bool': ...
    def Normalize(self, tolerance: 'float') -> 'bool': ...
    def GetClampedToMaxSize(self, maxSize: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetSafeNormal(self, tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetSafeNormal2D(self, tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def CosineAngle2D(self, b: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    def ProjectOnTo(self, a: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def ProjectOnToNormal(self, normal: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def ToOrientationRotator(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    def ToOrientationQuat(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def Rotation(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    def ToString(self) -> 'str': ...
    @staticmethod
    def CrossProduct(a: 'CUE4Parse.UE4.Objects.Core.Math.FVector', b: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def DotProduct(a: 'CUE4Parse.UE4.Objects.Core.Math.FVector', b: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    @staticmethod
    def ComputeSquaredDistanceFromBoxToPoint(mins: 'CUE4Parse.UE4.Objects.Core.Math.FVector', maxs: 'CUE4Parse.UE4.Objects.Core.Math.FVector', point: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    @staticmethod
    def PointPlaneDist(point: 'CUE4Parse.UE4.Objects.Core.Math.FVector', planeBase: 'CUE4Parse.UE4.Objects.Core.Math.FVector', planeNormal: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    @staticmethod
    def PointPlaneProject(point: 'CUE4Parse.UE4.Objects.Core.Math.FVector', planeBase: 'CUE4Parse.UE4.Objects.Core.Math.FVector', planeNormal: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def VectorPlaneProject(delta: 'CUE4Parse.UE4.Objects.Core.Math.FVector', normal: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    def DistSquared(v1: 'CUE4Parse.UE4.Objects.Core.Math.FVector', v2: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'float': ...
    def Serialize(self, Ar: 'CUE4Parse.UE4.Writers.FArchiveWriter') -> None: ...

class FVector2D(System.ValueType, CUE4Parse.UE4.IUStruct, System.Numerics.IMultiplyOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D], System.Numerics.IMultiplyOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, float, CUE4Parse.UE4.Objects.Core.Math.FVector2D], System.Numerics.ISubtractionOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D], System.Numerics.ISubtractionOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, float, CUE4Parse.UE4.Objects.Core.Math.FVector2D], System.Numerics.IAdditionOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D, CUE4Parse.UE4.Objects.Core.Math.FVector2D], System.Numerics.IAdditionOperators[CUE4Parse.UE4.Objects.Core.Math.FVector2D, float, CUE4Parse.UE4.Objects.Core.Math.FVector2D]):
    @overload
    def __init__(self, x: 'float', y: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    X: 'float' = ...
    Y: 'float' = ...
    ZeroVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector2D' = ...
    def ToString(self) -> 'str': ...

class FVector3SignedShortScale(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, x: 'System.Int16', y: 'System.Int16', z: 'System.Int16', w: 'System.Int16') -> None: ...
    X: 'System.Int16' = ...
    Y: 'System.Int16' = ...
    Z: 'System.Int16' = ...
    W: 'System.Int16' = ...

class FVector3UnsignedShortScale(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, x: 'System.UInt16', y: 'System.UInt16', z: 'System.UInt16', w: 'System.UInt16') -> None: ...
    X: 'System.UInt16' = ...
    Y: 'System.UInt16' = ...
    Z: 'System.UInt16' = ...
    W: 'System.UInt16' = ...

class FVector3Packed32(System.ValueType, CUE4Parse.UE4.IUStruct):
    Data: 'System.UInt32' = ...
    X: 'float' = ...
    Y: 'float' = ...
    Z: 'float' = ...

class FVector3UnsignedShort(System.ValueType, CUE4Parse.UE4.IUStruct):
    def __init__(self, x: 'System.Half', y: 'System.Half', z: 'System.Half', w: 'System.Half') -> None: ...
    X: 'System.Half' = ...
    Y: 'System.Half' = ...
    Z: 'System.Half' = ...
    W: 'System.Half' = ...

class FVector4(System.ValueType, CUE4Parse.UE4.IUStruct, System.IEquatable[CUE4Parse.UE4.Objects.Core.Math.FVector4]):
    @overload
    def __init__(self, x: 'float', y: 'float', z: 'float', w: 'float') -> None: ...
    @overload
    def __init__(self, x: 'float') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector', w: 'float') -> None: ...
    @overload
    def __init__(self, color: 'CUE4Parse.UE4.Objects.Core.Math.FLinearColor') -> None: ...
    X: 'float' = ...
    Y: 'float' = ...
    Z: 'float' = ...
    W: 'float' = ...
    ZeroVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector4' = ...
    OneVector: 'CUE4Parse.UE4.Objects.Core.Math.FVector4' = ...
    @staticmethod
    def AsFVector() -> Tuple['CUE4Parse.UE4.Objects.Core.Math.FVector', 'CUE4Parse.UE4.Objects.Core.Math.FVector4']: ...
    def Equals(self, other: 'CUE4Parse.UE4.Objects.Core.Math.FVector4') -> 'bool': ...
    def ToString(self) -> 'str': ...

class EAxis(enum.Enum):
    None = ...
    X = ...
    Y = ...
    Z = ...

class FMatrix3x4(System.ValueType, CUE4Parse.UE4.IUStruct):
    M00: 'float' = ...
    M01: 'float' = ...
    M02: 'float' = ...
    M10: 'float' = ...
    M11: 'float' = ...
    M12: 'float' = ...
    M20: 'float' = ...
    M21: 'float' = ...
    M22: 'float' = ...
    M30: 'float' = ...
    M31: 'float' = ...
    M32: 'float' = ...

class FMatrix(CUE4Parse.UE4.IUStruct):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, m: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix') -> None: ...
    @overload
    def __init__(self, m00: 'float', m01: 'float', m02: 'float', m03: 'float', m10: 'float', m11: 'float', m12: 'float', m13: 'float', m20: 'float', m21: 'float', m22: 'float', m23: 'float', m30: 'float', m31: 'float', m32: 'float', m33: 'float') -> None: ...
    @overload
    def __init__(self, inX: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inY: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inZ: 'CUE4Parse.UE4.Objects.Core.Math.FVector', inW: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive') -> None: ...
    @overload
    def __init__(self, Ar: 'CUE4Parse.UE4.Readers.FArchive', readDouble: 'bool') -> None: ...
    M00: 'float' = ...
    M01: 'float' = ...
    M02: 'float' = ...
    M03: 'float' = ...
    M10: 'float' = ...
    M11: 'float' = ...
    M12: 'float' = ...
    M13: 'float' = ...
    M20: 'float' = ...
    M21: 'float' = ...
    M22: 'float' = ...
    M23: 'float' = ...
    M30: 'float' = ...
    M31: 'float' = ...
    M32: 'float' = ...
    M33: 'float' = ...
    Identity: 'CUE4Parse.UE4.Objects.Core.Math.FMatrix' = ...
    __getitem__: 'float' = ...
    def TransformFVector4(self, p: 'CUE4Parse.UE4.Objects.Core.Math.FVector4') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector4': ...
    def TransformPosition(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector4': ...
    def InverseTransformPosition(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def TransformVector(self, v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector4': ...
    def GetTransposed(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FMatrix': ...
    def Determinant(self) -> 'float': ...
    def RotDeterminant(self) -> 'float': ...
    def InverseFast(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FMatrix': ...
    def Inverse(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FMatrix': ...
    def RemoveScaling(self, tolerance: 'float') -> None: ...
    def ExtractScaling(self, tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetMaximumAxisScale(self) -> 'float': ...
    def GetOrigin(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def GetScaledAxis(self, axis: 'CUE4Parse.UE4.Objects.Core.Math.EAxis') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def SetAxis(self, i: 'int', axis: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...
    def Rotator(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FRotator': ...
    def GetScaleVector(self, tolerance: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    def ToQuat(self) -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    def MakeFrustumPlane(self, A: 'float', B: 'float', C: 'float', D: 'float') -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumNearPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumFarPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumLeftPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumRightPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumTopPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def GetFrustumBottomPlane(self) -> Tuple['bool', 'CUE4Parse.UE4.Objects.Core.Math.FPlane']: ...
    def ToString(self) -> 'str': ...

class FQuatRotationTranslationMatrix(CUE4Parse.UE4.Objects.Core.Math.FMatrix, CUE4Parse.UE4.IUStruct):
    def __init__(self, q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...

class FQuatRotationMatrix(CUE4Parse.UE4.Objects.Core.Math.FQuatRotationTranslationMatrix, CUE4Parse.UE4.IUStruct):
    def __init__(self, q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> None: ...

class FRotationMatrix(CUE4Parse.UE4.Objects.Core.Math.FRotationTranslationMatrix, CUE4Parse.UE4.IUStruct):
    def __init__(self, rot: 'CUE4Parse.UE4.Objects.Core.Math.FRotator') -> None: ...

class FRotationTranslationMatrix(CUE4Parse.UE4.Objects.Core.Math.FMatrix, CUE4Parse.UE4.IUStruct):
    def __init__(self, rot: 'CUE4Parse.UE4.Objects.Core.Math.FRotator', origin: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> None: ...

class ERangeBoundTypes(enum.Enum):
    Exclusive = ...
    Inclusive = ...
    Open = ...

class UnrealMathSSE:
    QMULTI_SIGN_MASK0: 'System.Runtime.Intrinsics.Vector128[float]' = ...
    QMULTI_SIGN_MASK1: 'System.Runtime.Intrinsics.Vector128[float]' = ...
    QMULTI_SIGN_MASK2: 'System.Runtime.Intrinsics.Vector128[float]' = ...
    @staticmethod
    def ShuffleMask(A0: 'int', A1: 'int', B2: 'int', B3: 'int') -> 'int': ...
    @staticmethod
    def RoundToInt(val: 'float') -> 'int': ...
    @staticmethod
    def VectorReplicate(vec: 'System.Runtime.Intrinsics.Vector128[float]', elementIndex: 'int') -> 'System.Runtime.Intrinsics.Vector128[float]': ...
    @staticmethod
    def VectorMultiply(vec1: 'System.Runtime.Intrinsics.Vector128[float]', vec2: 'System.Runtime.Intrinsics.Vector128[float]') -> 'System.Runtime.Intrinsics.Vector128[float]': ...
    @staticmethod
    def VectorSwizzle(vec: 'System.Runtime.Intrinsics.Vector128[float]', x: 'int', y: 'int', z: 'int', w: 'int') -> 'System.Runtime.Intrinsics.Vector128[float]': ...
    @staticmethod
    def VectorMultiplyAdd(vec1: 'System.Runtime.Intrinsics.Vector128[float]', vec2: 'System.Runtime.Intrinsics.Vector128[float]', vec3: 'System.Runtime.Intrinsics.Vector128[float]') -> 'System.Runtime.Intrinsics.Vector128[float]': ...
    @staticmethod
    def VectorQuaternionMultiply2(quat1: 'CUE4Parse.UE4.Objects.Core.Math.FQuat', quat2: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...

class UnrealMath:
    SmallNumber: 'float' = ...
    KindaSmallNumber: 'float' = ...
    @staticmethod
    def Min3(a: 'float', b: 'float', c: 'float') -> 'float': ...
    @staticmethod
    def Max3(a: 'float', b: 'float', c: 'float') -> 'float': ...
    @staticmethod
    def IsNearlyEqual(a: 'float', b: 'float', err: 'float') -> 'bool': ...
    @staticmethod
    @overload
    def IsNearlyZero(x: 'float', tolerance: 'float') -> 'bool': ...
    @staticmethod
    @overload
    def IsNearlyZero(x: 'float', tolerance: 'float') -> 'bool': ...
    @staticmethod
    def Fmod(x: 'float', y: 'float') -> 'float': ...
    @staticmethod
    def CountBits(bits: 'System.UInt64') -> 'int': ...
    @staticmethod
    def Lerp(a: 'T', b: 'T', alpha: 'float') -> 'T': ...

