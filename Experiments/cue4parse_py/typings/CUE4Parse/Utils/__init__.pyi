from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class AlignUtils:
    @staticmethod
    @overload
    def Align(ptr: 'int', alignment: 'int') -> 'int': ...
    @staticmethod
    @overload
    def Align(ptr: 'int', alignment: 'int') -> 'int': ...
    @staticmethod
    @overload
    def Align(ptr: 'System.UInt32', alignment: 'int') -> 'int': ...

class ArrayUtils:
    @staticmethod
    def SubByteArray(byteArray: 'List[int]', len: 'int') -> 'List[int]': ...
    @staticmethod
    def Contains(array: 'System.Collections.BitArray', search: 'bool') -> 'bool': ...
    @staticmethod
    def GetOrFalse(array: 'System.Collections.BitArray', index: 'int') -> 'bool': ...
    @staticmethod
    def SetRangeFromRange(array: 'System.Collections.BitArray', index: 'int', numBitsToSet: 'int', readBits: 'System.Collections.BitArray', readOffsetBits: 'int') -> None: ...

class CityHash:
    @staticmethod
    def CityHash64(buffer: 'List[int]') -> 'System.UInt64': ...

class CRC32:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, reverseBits: 'bool') -> None: ...
    @overload
    def __init__(self, polynomial: 'int', reverseBits: 'bool') -> None: ...
    TotalBytesRead: 'int' = ...
    Crc32Result: 'int' = ...
    def GetCrc32(self, input: 'System.IO.Stream') -> 'int': ...
    def GetCrc32AndCopy(self, input: 'System.IO.Stream', output: 'System.IO.Stream') -> 'int': ...
    def ComputeCrc32(self, w: 'int', b: 'int') -> 'int': ...
    def SlurpBlock(self, block: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def UpdateCRC(self, b: 'int') -> None: ...
    @overload
    def UpdateCRC(self, b: 'int', n: 'int') -> None: ...
    def Combine(self, crc: 'int', length: 'int') -> None: ...
    def Reset(self) -> None: ...

class CrcCalculatorStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', length: 'int') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', length: 'int', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', length: 'int', leaveOpen: 'bool', crc32: 'CUE4Parse.Utils.CRC32') -> None: ...
    TotalBytesSlurped: 'int' = ...
    Crc: 'int' = ...
    LeaveOpen: 'bool' = ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    def Flush(self) -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def Close(self) -> None: ...

class CUE4ParseNatives:
    LibraryName: 'str' = ...
    @staticmethod
    def IsFeatureAvailable(featureName: 'str') -> 'bool': ...

class DictUtils:
    @staticmethod
    @overload
    def GetOrAdd(dictionary: 'System.Collections.Generic.IDictionary[TKey, TValue]', key: 'TKey', valueCreator: 'System.Func[TValue]') -> 'TValue': ...
    @staticmethod
    @overload
    def GetOrAdd(dictionary: 'System.Collections.Generic.IDictionary[TKey, TValue]', key: 'TKey') -> 'TValue': ...

class EnumUtils:
    @staticmethod
    def ToStringBitfield(inEnum: 'T', prefixed: 'bool') -> 'str': ...
    @staticmethod
    def GetValueByName(name: 'str') -> 'T': ...

class HexUtils:
    @staticmethod
    def ParseHexBinary(hex: 'str') -> 'List[int]': ...

class ListUtils:
    @staticmethod
    def Pop(list: 'List[T]') -> 'T': ...

class MathUtils:
    @staticmethod
    def IsNumericType(o: 'Any') -> 'bool': ...
    @staticmethod
    def InvSqrt(x: 'float') -> 'float': ...
    @staticmethod
    @overload
    def DivideAndRoundUp(dividend: 'int', divisor: 'int') -> 'int': ...
    @staticmethod
    @overload
    def DivideAndRoundUp(dividend: 'System.UInt32', divisor: 'System.UInt32') -> 'System.UInt32': ...
    @staticmethod
    def ToDegrees(radVal: 'float') -> 'float': ...
    @staticmethod
    def ToRadians(degVal: 'float') -> 'float': ...
    @staticmethod
    def Square(val: 'float') -> 'float': ...
    @staticmethod
    @overload
    def TruncToInt(f: 'float') -> 'int': ...
    @staticmethod
    @overload
    def TruncToInt(f: 'float') -> 'int': ...
    @staticmethod
    def FloorToInt(f: 'float') -> 'int': ...
    @staticmethod
    def RoundToInt(f: 'float') -> 'int': ...
    @staticmethod
    @overload
    def Clamp(i: 'int', min: 'int', max: 'int') -> 'int': ...
    @staticmethod
    @overload
    def Clamp(f: 'float', min: 'float', max: 'float') -> 'float': ...
    @staticmethod
    def FloatSelect(comparand: 'float', valueGEZero: 'float', valueLTZero: 'float') -> 'float': ...
    @staticmethod
    @overload
    def Lerp(a: 'CUE4Parse.UE4.Objects.Core.Math.FVector', b: 'CUE4Parse.UE4.Objects.Core.Math.FVector', alpha: 'float') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    @overload
    def Lerp(a: 'float', b: 'float', alpha: 'float') -> 'float': ...
    @staticmethod
    def MortonCode2(x: 'System.UInt32') -> 'System.UInt32': ...
    @staticmethod
    def ReverseMortonCode2(x: 'System.UInt32') -> 'System.UInt32': ...
    @staticmethod
    def ToVector2(v: 'CUE4Parse.UE4.Objects.Core.Math.FVector2D') -> 'System.Numerics.Vector2': ...
    @staticmethod
    def ToVector3(v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'System.Numerics.Vector3': ...
    @staticmethod
    @overload
    def ToVector4(v: 'CUE4Parse.UE4.Objects.Core.Math.FVector') -> 'System.Numerics.Vector4': ...
    @staticmethod
    @overload
    def ToVector4(v: 'CUE4Parse.UE4.Objects.Core.Math.FVector4') -> 'System.Numerics.Vector4': ...
    @staticmethod
    def ToFVector2D(v: 'System.Numerics.Vector2') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector2D': ...
    @staticmethod
    def ToFVector(v: 'System.Numerics.Vector3') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector': ...
    @staticmethod
    @overload
    def ToFVector4(v: 'System.Numerics.Vector3') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector4': ...
    @staticmethod
    @overload
    def ToFVector4(v: 'System.Numerics.Vector4') -> 'CUE4Parse.UE4.Objects.Core.Math.FVector4': ...
    @staticmethod
    def ToQuaternion(q: 'CUE4Parse.UE4.Objects.Core.Math.FQuat') -> 'System.Numerics.Quaternion': ...
    @staticmethod
    def ToFQuat(q: 'System.Numerics.Quaternion') -> 'CUE4Parse.UE4.Objects.Core.Math.FQuat': ...
    @staticmethod
    def Ulpc(value: 'float') -> 'float': ...

class CubicCurve2D:
    def __init__(self) -> None: ...
    @staticmethod
    def SolveCubic() -> Tuple['int', 'System.Double[]', 'System.Double[]']: ...

class LzmaSpeed(enum.Enum):
    Fastest = ...
    VeryFast = ...
    Fast = ...
    Medium = ...
    Slow = ...
    VerySlow = ...

class DictionarySize(enum.Enum):
    VerySmall = ...
    Small = ...
    Medium = ...
    Large = ...
    Larger = ...
    VeryLarge = ...

class Lzma:
    @staticmethod
    def Compress(input: 'System.IO.Stream', output: 'System.IO.Stream', speed: 'CUE4Parse.Utils.LzmaSpeed', dictionarySize: 'CUE4Parse.Utils.DictionarySize', onProgress: 'System.Action[int, int]') -> None: ...
    @staticmethod
    def Decompress(input: 'System.IO.Stream', output: 'System.IO.Stream', onProgress: 'System.Action[int, int]') -> None: ...

class StringUtils:
    @staticmethod
    def ParseAesKey(s: 'str') -> 'CUE4Parse.Encryption.Aes.FAesKey': ...
    @staticmethod
    def TryParseAesKey(s: 'str') -> Tuple['bool', 'CUE4Parse.Encryption.Aes.FAesKey']: ...
    @staticmethod
    @overload
    def SubstringBefore(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    @overload
    def SubstringBefore(s: 'str', delimiter: 'str', comparisonType: 'System.StringComparison') -> 'str': ...
    @staticmethod
    @overload
    def SubstringAfter(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    @overload
    def SubstringAfter(s: 'str', delimiter: 'str', comparisonType: 'System.StringComparison') -> 'str': ...
    @staticmethod
    @overload
    def SubstringAfter(s: 'System.Span[System.Char]', delimiter: 'System.ReadOnlySpan[System.Char]') -> 'System.Span[System.Char]': ...
    @staticmethod
    @overload
    def SubstringBeforeLast(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    @overload
    def SubstringBeforeLast(s: 'str', delimiter: 'str', comparisonType: 'System.StringComparison') -> 'str': ...
    @staticmethod
    def SubstringBeforeWithLast(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    @overload
    def SubstringAfterLast(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    @overload
    def SubstringAfterLast(s: 'str', delimiter: 'str', comparisonType: 'System.StringComparison') -> 'str': ...
    @staticmethod
    def SubstringAfterWithLast(s: 'str', delimiter: 'System.Char') -> 'str': ...
    @staticmethod
    def Contains(orig: 'str', value: 'str', comparisonType: 'System.StringComparison') -> 'bool': ...

class UnsafePrint:
    @staticmethod
    @overload
    def BytesToHex(bytes: 'System.Byte*', length: 'System.UInt32') -> 'str': ...
    @staticmethod
    @overload
    def BytesToHex(bytes: 'List[int]') -> 'str': ...

