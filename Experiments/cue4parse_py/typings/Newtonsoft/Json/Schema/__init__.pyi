from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class Extensions:
    @staticmethod
    @overload
    def IsValid(source: 'Newtonsoft.Json.Linq.JToken', schema: 'Newtonsoft.Json.Schema.JsonSchema') -> 'bool': ...
    @staticmethod
    @overload
    def IsValid(source: 'Newtonsoft.Json.Linq.JToken', schema: 'Newtonsoft.Json.Schema.JsonSchema') -> Tuple['bool', 'System.Collections.Generic.IList_1[[System.String, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    @staticmethod
    @overload
    def Validate(source: 'Newtonsoft.Json.Linq.JToken', schema: 'Newtonsoft.Json.Schema.JsonSchema') -> None: ...
    @staticmethod
    @overload
    def Validate(source: 'Newtonsoft.Json.Linq.JToken', schema: 'Newtonsoft.Json.Schema.JsonSchema', validationEventHandler: 'Newtonsoft.Json.Schema.ValidationEventHandler') -> None: ...

class JsonSchema:
    def __init__(self) -> None: ...
    Id: 'str' = ...
    Title: 'str' = ...
    Required: 'Optional[bool]' = ...
    ReadOnly: 'Optional[bool]' = ...
    Hidden: 'Optional[bool]' = ...
    Transient: 'Optional[bool]' = ...
    Description: 'str' = ...
    Type: 'Optional[Newtonsoft.Json.Schema.JsonSchemaType]' = ...
    Pattern: 'str' = ...
    MinimumLength: 'Optional[int]' = ...
    MaximumLength: 'Optional[int]' = ...
    DivisibleBy: 'Optional[float]' = ...
    Minimum: 'Optional[float]' = ...
    Maximum: 'Optional[float]' = ...
    ExclusiveMinimum: 'Optional[bool]' = ...
    ExclusiveMaximum: 'Optional[bool]' = ...
    MinimumItems: 'Optional[int]' = ...
    MaximumItems: 'Optional[int]' = ...
    Items: 'System.Collections.Generic.IList[Newtonsoft.Json.Schema.JsonSchema]' = ...
    PositionalItemsValidation: 'bool' = ...
    AdditionalItems: 'Newtonsoft.Json.Schema.JsonSchema' = ...
    AllowAdditionalItems: 'bool' = ...
    UniqueItems: 'bool' = ...
    Properties: 'System.Collections.Generic.IDictionary[str, Newtonsoft.Json.Schema.JsonSchema]' = ...
    AdditionalProperties: 'Newtonsoft.Json.Schema.JsonSchema' = ...
    PatternProperties: 'System.Collections.Generic.IDictionary[str, Newtonsoft.Json.Schema.JsonSchema]' = ...
    AllowAdditionalProperties: 'bool' = ...
    Requires: 'str' = ...
    Enum: 'System.Collections.Generic.IList[Newtonsoft.Json.Linq.JToken]' = ...
    Disallow: 'Optional[Newtonsoft.Json.Schema.JsonSchemaType]' = ...
    Default: 'Newtonsoft.Json.Linq.JToken' = ...
    Extends: 'System.Collections.Generic.IList[Newtonsoft.Json.Schema.JsonSchema]' = ...
    Format: 'str' = ...
    @staticmethod
    @overload
    def Read(reader: 'Newtonsoft.Json.JsonReader') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @staticmethod
    @overload
    def Read(reader: 'Newtonsoft.Json.JsonReader', resolver: 'Newtonsoft.Json.Schema.JsonSchemaResolver') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @staticmethod
    @overload
    def Parse(json: 'str') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @staticmethod
    @overload
    def Parse(json: 'str', resolver: 'Newtonsoft.Json.Schema.JsonSchemaResolver') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @overload
    def WriteTo(self, writer: 'Newtonsoft.Json.JsonWriter') -> None: ...
    @overload
    def WriteTo(self, writer: 'Newtonsoft.Json.JsonWriter', resolver: 'Newtonsoft.Json.Schema.JsonSchemaResolver') -> None: ...
    def ToString(self) -> 'str': ...

class JsonSchemaException(Newtonsoft.Json.JsonException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...
    LineNumber: 'int' = ...
    LinePosition: 'int' = ...
    Path: 'str' = ...

class JsonSchemaGenerator:
    def __init__(self) -> None: ...
    UndefinedSchemaIdHandling: 'Newtonsoft.Json.Schema.UndefinedSchemaIdHandling' = ...
    ContractResolver: 'Newtonsoft.Json.Serialization.IContractResolver' = ...
    @overload
    def Generate(self, type: 'System.Type') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @overload
    def Generate(self, type: 'System.Type', resolver: 'Newtonsoft.Json.Schema.JsonSchemaResolver') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @overload
    def Generate(self, type: 'System.Type', rootSchemaNullable: 'bool') -> 'Newtonsoft.Json.Schema.JsonSchema': ...
    @overload
    def Generate(self, type: 'System.Type', resolver: 'Newtonsoft.Json.Schema.JsonSchemaResolver', rootSchemaNullable: 'bool') -> 'Newtonsoft.Json.Schema.JsonSchema': ...

class JsonSchemaResolver:
    def __init__(self) -> None: ...
    LoadedSchemas: 'System.Collections.Generic.IList[Newtonsoft.Json.Schema.JsonSchema]' = ...
    def GetSchema(self, reference: 'str') -> 'Newtonsoft.Json.Schema.JsonSchema': ...

class JsonSchemaType(enum.Enum):
    None = ...
    String = ...
    Float = ...
    Integer = ...
    Boolean = ...
    Object = ...
    Array = ...
    Null = ...
    Any = ...

class UndefinedSchemaIdHandling(enum.Enum):
    None = ...
    UseTypeName = ...
    UseAssemblyQualifiedName = ...

class ValidationEventArgs(System.EventArgs):
    Exception: 'Newtonsoft.Json.Schema.JsonSchemaException' = ...
    Path: 'str' = ...
    Message: 'str' = ...

class ValidationEventHandler(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, sender: 'Any', e: 'Newtonsoft.Json.Schema.ValidationEventArgs') -> None: ...
    def BeginInvoke(self, sender: 'Any', e: 'Newtonsoft.Json.Schema.ValidationEventArgs', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

