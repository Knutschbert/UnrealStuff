from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class CompositeResolverAttribute(System.Attribute):
    def __init__(self, formattersAndResolvers: 'List[System.Type]') -> None: ...
    IncludeLocalFormatters: 'bool' = ...

class ExtensionHeader(System.ValueType, System.IEquatable[MessagePack.ExtensionHeader]):
    @overload
    def __init__(self, typeCode: 'System.SByte', length: 'System.UInt32') -> None: ...
    @overload
    def __init__(self, typeCode: 'System.SByte', length: 'int') -> None: ...
    TypeCode: 'System.SByte' = ...
    Length: 'System.UInt32' = ...
    def Equals(self, other: 'MessagePack.ExtensionHeader') -> 'bool': ...

class ExtensionResult(System.ValueType):
    @overload
    def __init__(self, typeCode: 'System.SByte', data: 'System.Memory[int]') -> None: ...
    @overload
    def __init__(self, typeCode: 'System.SByte', data: 'System.Buffers.ReadOnlySequence[int]') -> None: ...
    TypeCode: 'System.SByte' = ...
    Data: 'System.Buffers.ReadOnlySequence[int]' = ...
    Header: 'MessagePack.ExtensionHeader' = ...

class GeneratedMessagePackResolverAttribute(System.Attribute):
    def __init__(self) -> None: ...
    UseMapMode: 'bool' = ...

class IFormatterResolver:
    def GetFormatter(self) -> 'MessagePack.Formatters.IMessagePackFormatter[T]': ...

class FormatterResolverExtensions:
    @staticmethod
    def GetFormatterWithVerify(resolver: 'MessagePack.IFormatterResolver') -> 'MessagePack.Formatters.IMessagePackFormatter[T]': ...
    @staticmethod
    def GetFormatterDynamic(resolver: 'MessagePack.IFormatterResolver', type: 'System.Type') -> 'Any': ...

class FormatterNotRegisteredException(MessagePack.MessagePackSerializationException, System.Runtime.Serialization.ISerializable):
    def __init__(self, message: 'str') -> None: ...

class TinyJsonException(MessagePack.MessagePackSerializationException, System.Runtime.Serialization.ISerializable):
    def __init__(self, message: 'str') -> None: ...

class MessagePackType(enum.Enum):
    Unknown = ...
    Integer = ...
    Nil = ...
    Boolean = ...
    Float = ...
    String = ...
    Binary = ...
    Array = ...
    Map = ...
    Extension = ...

class MessagePackCode:
    MinFixInt: 'int' = ...
    MaxFixInt: 'int' = ...
    MinFixMap: 'int' = ...
    MaxFixMap: 'int' = ...
    MinFixArray: 'int' = ...
    MaxFixArray: 'int' = ...
    MinFixStr: 'int' = ...
    MaxFixStr: 'int' = ...
    Nil: 'int' = ...
    NeverUsed: 'int' = ...
    False: 'int' = ...
    True: 'int' = ...
    Bin8: 'int' = ...
    Bin16: 'int' = ...
    Bin32: 'int' = ...
    Ext8: 'int' = ...
    Ext16: 'int' = ...
    Ext32: 'int' = ...
    Float32: 'int' = ...
    Float64: 'int' = ...
    UInt8: 'int' = ...
    UInt16: 'int' = ...
    UInt32: 'int' = ...
    UInt64: 'int' = ...
    Int8: 'int' = ...
    Int16: 'int' = ...
    Int32: 'int' = ...
    Int64: 'int' = ...
    FixExt1: 'int' = ...
    FixExt2: 'int' = ...
    FixExt4: 'int' = ...
    FixExt8: 'int' = ...
    FixExt16: 'int' = ...
    Str8: 'int' = ...
    Str16: 'int' = ...
    Str32: 'int' = ...
    Array16: 'int' = ...
    Array32: 'int' = ...
    Map16: 'int' = ...
    Map32: 'int' = ...
    MinNegativeFixInt: 'int' = ...
    MaxNegativeFixInt: 'int' = ...
    @staticmethod
    def ToMessagePackType(code: 'int') -> 'MessagePack.MessagePackType': ...
    @staticmethod
    def ToFormatName(code: 'int') -> 'str': ...

class ReservedMessagePackExtensionTypeCode:
    DateTime: 'System.SByte' = ...

class MessagePackRange:
    MinFixNegativeInt: 'int' = ...
    MaxFixNegativeInt: 'int' = ...
    MaxFixPositiveInt: 'int' = ...
    MinFixStringLength: 'int' = ...
    MaxFixStringLength: 'int' = ...
    MaxFixMapCount: 'int' = ...
    MaxFixArrayCount: 'int' = ...

class MessagePackCompression(enum.Enum):
    None = ...
    Lz4Block = ...
    Lz4BlockArray = ...

class MessagePackPrimitives:
    @staticmethod
    def TryReadNil(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Int32']: ...
    @staticmethod
    def TryReadArrayHeader(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt32', 'System.Int32']: ...
    @staticmethod
    def TryReadMapHeader(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt32', 'System.Int32']: ...
    @staticmethod
    def TryReadBool(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Boolean', 'System.Int32']: ...
    @staticmethod
    def TryReadChar(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Char', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadDateTime(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.DateTime', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadDateTime(source: 'System.ReadOnlySpan[int]', header: 'MessagePack.ExtensionHeader') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.DateTime', 'System.Int32']: ...
    @staticmethod
    def TryReadExtensionHeader(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'MessagePack.ExtensionHeader', 'System.Int32']: ...
    @staticmethod
    def TryReadBinHeader(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt32', 'System.Int32']: ...
    @staticmethod
    def TryReadStringHeader(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt32', 'System.Int32']: ...
    @staticmethod
    def TryReadByte(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Byte', 'System.Int32']: ...
    @staticmethod
    def TryReadUInt16(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt16', 'System.Int32']: ...
    @staticmethod
    def TryReadUInt32(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt32', 'System.Int32']: ...
    @staticmethod
    def TryReadUInt64(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.UInt64', 'System.Int32']: ...
    @staticmethod
    def TryReadSByte(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.SByte', 'System.Int32']: ...
    @staticmethod
    def TryReadInt16(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Int16', 'System.Int32']: ...
    @staticmethod
    def TryReadInt32(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    def TryReadInt64(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Int64', 'System.Int32']: ...
    @staticmethod
    def TryReadSingle(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Single', 'System.Int32']: ...
    @staticmethod
    def TryReadDouble(source: 'System.ReadOnlySpan[int]') -> Tuple['MessagePack.MessagePackPrimitives.DecodeResult', 'System.Double', 'System.Int32']: ...
    @staticmethod
    def TryWriteNil(destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteArrayHeader(destination: 'System.Span[int]', count: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteMapHeader(destination: 'System.Span[int]', count: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.SByte') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.Int16') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.UInt16') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.UInt64') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'float') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'float') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'bool') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.Char') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryWrite(destination: 'System.Span[int]', value: 'System.DateTime') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteInt8(destination: 'System.Span[int]', value: 'System.SByte') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteInt16(destination: 'System.Span[int]', value: 'System.Int16') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteInt32(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteInt64(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteUInt8(destination: 'System.Span[int]', value: 'int') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteUInt16(destination: 'System.Span[int]', value: 'System.UInt16') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteUInt32(destination: 'System.Span[int]', value: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteUInt64(destination: 'System.Span[int]', value: 'System.UInt64') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteBinHeader(destination: 'System.Span[int]', length: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteStringHeader(destination: 'System.Span[int]', byteCount: 'System.UInt32') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def TryWriteExtensionFormatHeader(destination: 'System.Span[int]', extensionHeader: 'MessagePack.ExtensionHeader') -> Tuple['bool', 'System.Int32']: ...

class MessagePackReader(System.ValueType):
    @overload
    def __init__(self, memory: 'System.ReadOnlyMemory[int]') -> None: ...
    @overload
    def __init__(self, readOnlySequence: 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]') -> None: ...
    CancellationToken: 'System.Threading.CancellationToken' = ...
    Depth: 'int' = ...
    Sequence: 'System.Buffers.ReadOnlySequence[int]' = ...
    Position: 'System.SequencePosition' = ...
    Consumed: 'int' = ...
    End: 'bool' = ...
    IsNil: 'bool' = ...
    NextMessagePackType: 'MessagePack.MessagePackType' = ...
    NextCode: 'int' = ...
    def Clone(self) -> Tuple['MessagePack.MessagePackReader', 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    def CreatePeekReader(self) -> 'MessagePack.MessagePackReader': ...
    def Skip(self) -> None: ...
    def ReadNil(self) -> 'MessagePack.Nil': ...
    def TryReadNil(self) -> 'bool': ...
    @overload
    def ReadRaw(self, length: 'int') -> 'System.Buffers.ReadOnlySequence[int]': ...
    @overload
    def ReadRaw(self) -> 'System.Buffers.ReadOnlySequence[int]': ...
    def ReadArrayHeader(self) -> 'int': ...
    def TryReadArrayHeader(self) -> Tuple['bool', 'System.Int32']: ...
    def ReadMapHeader(self) -> 'int': ...
    def TryReadMapHeader(self) -> Tuple['bool', 'System.Int32']: ...
    def ReadBoolean(self) -> 'bool': ...
    def ReadChar(self) -> 'System.Char': ...
    def ReadSingle(self) -> 'float': ...
    def ReadDouble(self) -> 'float': ...
    @overload
    def ReadDateTime(self) -> 'System.DateTime': ...
    @overload
    def ReadDateTime(self, header: 'MessagePack.ExtensionHeader') -> 'System.DateTime': ...
    def ReadBytes(self) -> 'Optional[System.Buffers.ReadOnlySequence[int]]': ...
    def ReadStringSequence(self) -> 'Optional[System.Buffers.ReadOnlySequence[int]]': ...
    def TryReadStringSpan(self) -> Tuple['bool', 'System.ReadOnlySpan_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    def ReadString(self) -> 'str': ...
    def ReadExtensionFormatHeader(self) -> 'MessagePack.ExtensionHeader': ...
    def TryReadExtensionFormatHeader(self) -> Tuple['bool', 'MessagePack.ExtensionHeader']: ...
    def ReadExtensionFormat(self) -> 'MessagePack.ExtensionResult': ...
    def ReadByte(self) -> 'int': ...
    def ReadUInt16(self) -> 'System.UInt16': ...
    def ReadUInt32(self) -> 'System.UInt32': ...
    def ReadUInt64(self) -> 'System.UInt64': ...
    def ReadSByte(self) -> 'System.SByte': ...
    def ReadInt16(self) -> 'System.Int16': ...
    def ReadInt32(self) -> 'int': ...
    def ReadInt64(self) -> 'int': ...

class MessagePackSecurity:
    TrustedData: 'MessagePack.MessagePackSecurity' = ...
    UntrustedData: 'MessagePack.MessagePackSecurity' = ...
    HashCollisionResistant: 'bool' = ...
    MaximumObjectGraphDepth: 'int' = ...
    def WithMaximumObjectGraphDepth(self, maximumObjectGraphDepth: 'int') -> 'MessagePack.MessagePackSecurity': ...
    def WithHashCollisionResistant(self, hashCollisionResistant: 'bool') -> 'MessagePack.MessagePackSecurity': ...
    @overload
    def GetEqualityComparer(self) -> 'System.Collections.Generic.IEqualityComparer[T]': ...
    @overload
    def GetEqualityComparer(self) -> 'System.Collections.IEqualityComparer': ...
    def DepthStep(self) -> 'MessagePack.MessagePackReader': ...

class MessagePackSerializationException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...

class MessagePackSerializer:
    DefaultOptions: 'MessagePack.MessagePackSerializerOptions' = ...
    @staticmethod
    @overload
    def Serialize(writer: 'System.Buffers.IBufferWriter[int]', value: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def Serialize(value: 'T', options: 'MessagePack.MessagePackSerializerOptions') -> 'MessagePack.MessagePackWriter': ...
    @staticmethod
    @overload
    def Serialize(value: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'List[int]': ...
    @staticmethod
    @overload
    def Serialize(stream: 'System.IO.Stream', value: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def Serialize(type: 'System.Type', obj: 'Any', options: 'MessagePack.MessagePackSerializerOptions') -> 'MessagePack.MessagePackWriter': ...
    @staticmethod
    @overload
    def Serialize(type: 'System.Type', writer: 'System.Buffers.IBufferWriter[int]', obj: 'Any', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def Serialize(type: 'System.Type', obj: 'Any', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'List[int]': ...
    @staticmethod
    @overload
    def Serialize(type: 'System.Type', stream: 'System.IO.Stream', obj: 'Any', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def SerializeAsync(stream: 'System.IO.Stream', value: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def SerializeAsync(type: 'System.Type', stream: 'System.IO.Stream', obj: 'Any', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Deserialize(options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> Tuple['T', 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    @staticmethod
    @overload
    def Deserialize(options: 'MessagePack.MessagePackSerializerOptions') -> Tuple['T', 'MessagePack.MessagePackReader']: ...
    @staticmethod
    @overload
    def Deserialize(buffer: 'System.ReadOnlyMemory[int]', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'T': ...
    @staticmethod
    @overload
    def Deserialize(buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> Tuple['T', 'System.Int32']: ...
    @staticmethod
    @overload
    def Deserialize(buffer: 'System.ReadOnlyMemory[int]', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> Tuple['T', 'System.Int32']: ...
    @staticmethod
    @overload
    def Deserialize(stream: 'System.IO.Stream', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'T': ...
    @staticmethod
    @overload
    def Deserialize(type: 'System.Type', options: 'MessagePack.MessagePackSerializerOptions') -> Tuple['Any', 'MessagePack.MessagePackReader']: ...
    @staticmethod
    @overload
    def Deserialize(type: 'System.Type', stream: 'System.IO.Stream', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'Any': ...
    @staticmethod
    @overload
    def Deserialize(type: 'System.Type', bytes: 'System.ReadOnlyMemory[int]', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'Any': ...
    @staticmethod
    @overload
    def Deserialize(type: 'System.Type', bytes: 'System.Buffers.ReadOnlySequence[int]', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'Any': ...
    @staticmethod
    @overload
    def DeserializeAsync(stream: 'System.IO.Stream', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[T]': ...
    @staticmethod
    @overload
    def DeserializeAsync(type: 'System.Type', stream: 'System.IO.Stream', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[Any]': ...
    @staticmethod
    @overload
    def SerializeToJson(textWriter: 'System.IO.TextWriter', obj: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def SerializeToJson(obj: 'T', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'str': ...
    @staticmethod
    @overload
    def ConvertToJson(bytes: 'System.ReadOnlyMemory[int]', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'str': ...
    @staticmethod
    @overload
    def ConvertToJson(options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> Tuple['str', 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    @staticmethod
    @overload
    def ConvertToJson(jsonWriter: 'System.IO.TextWriter', options: 'MessagePack.MessagePackSerializerOptions') -> 'MessagePack.MessagePackReader': ...
    @staticmethod
    @overload
    def ConvertFromJson(str: 'str', options: 'MessagePack.MessagePackSerializerOptions') -> 'MessagePack.MessagePackWriter': ...
    @staticmethod
    @overload
    def ConvertFromJson(str: 'str', options: 'MessagePack.MessagePackSerializerOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'List[int]': ...
    @staticmethod
    @overload
    def ConvertFromJson(reader: 'System.IO.TextReader', options: 'MessagePack.MessagePackSerializerOptions') -> 'MessagePack.MessagePackWriter': ...

class MessagePackSerializerOptions:
    def __init__(self, resolver: 'MessagePack.IFormatterResolver') -> None: ...
    Standard: 'MessagePack.MessagePackSerializerOptions' = ...
    Resolver: 'MessagePack.IFormatterResolver' = ...
    Compression: 'MessagePack.MessagePackCompression' = ...
    CompressionMinLength: 'int' = ...
    SuggestedContiguousMemorySize: 'int' = ...
    OldSpec: 'Optional[bool]' = ...
    OmitAssemblyVersion: 'bool' = ...
    AllowAssemblyVersionMismatch: 'bool' = ...
    Security: 'MessagePack.MessagePackSecurity' = ...
    SequencePool: 'MessagePack.SequencePool' = ...
    def LoadType(self, typeName: 'str') -> 'System.Type': ...
    def ThrowIfDeserializingTypeIsDisallowed(self, type: 'System.Type') -> None: ...
    def WithResolver(self, resolver: 'MessagePack.IFormatterResolver') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithCompression(self, compression: 'MessagePack.MessagePackCompression') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithCompressionMinLength(self, compressionMinLength: 'int') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithSuggestedContiguousMemorySize(self, suggestedContiguousMemorySize: 'int') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithOldSpec(self, oldSpec: 'Optional[bool]') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithOmitAssemblyVersion(self, omitAssemblyVersion: 'bool') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithAllowAssemblyVersionMismatch(self, allowAssemblyVersionMismatch: 'bool') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithSecurity(self, security: 'MessagePack.MessagePackSecurity') -> 'MessagePack.MessagePackSerializerOptions': ...
    def WithPool(self, pool: 'MessagePack.SequencePool') -> 'MessagePack.MessagePackSerializerOptions': ...

class MessagePackStreamReader(System.IDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', leaveOpen: 'bool', sequencePool: 'MessagePack.SequencePool') -> None: ...
    RemainingBytes: 'System.Buffers.ReadOnlySequence[int]' = ...
    def ReadArrayHeaderAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def ReadArrayAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Collections.Generic.IAsyncEnumerable[System.Buffers.ReadOnlySequence[int]]': ...
    def ReadAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[Optional[System.Buffers.ReadOnlySequence[int]]]': ...
    def DiscardBufferedData(self) -> None: ...
    def Dispose(self) -> None: ...
    def ReadMapHeaderAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class MessagePackWriter(System.ValueType):
    def __init__(self, writer: 'System.Buffers.IBufferWriter[int]') -> None: ...
    CancellationToken: 'System.Threading.CancellationToken' = ...
    OldSpec: 'bool' = ...
    def Clone(self, writer: 'System.Buffers.IBufferWriter[int]') -> 'MessagePack.MessagePackWriter': ...
    def Flush(self) -> None: ...
    def WriteNil(self) -> None: ...
    @overload
    def WriteRaw(self, rawMessagePackBlock: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteRaw(self) -> 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]': ...
    @overload
    def WriteArrayHeader(self, count: 'int') -> None: ...
    @overload
    def WriteArrayHeader(self, count: 'System.UInt32') -> None: ...
    @overload
    def WriteMapHeader(self, count: 'int') -> None: ...
    @overload
    def WriteMapHeader(self, count: 'System.UInt32') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.SByte') -> None: ...
    @overload
    def Write(self, value: 'System.UInt16') -> None: ...
    @overload
    def Write(self, value: 'System.Int16') -> None: ...
    @overload
    def Write(self, value: 'System.UInt32') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.UInt64') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'bool') -> None: ...
    @overload
    def Write(self, value: 'System.Char') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, dateTime: 'System.DateTime') -> None: ...
    @overload
    def Write(self, src: 'List[int]') -> None: ...
    @overload
    def Write(self, src: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Write(self) -> 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]': ...
    @overload
    def Write(self, value: 'str') -> None: ...
    @overload
    def Write(self, value: 'System.ReadOnlySpan[System.Char]') -> None: ...
    def WriteUInt8(self, value: 'int') -> None: ...
    def WriteInt8(self, value: 'System.SByte') -> None: ...
    def WriteUInt16(self, value: 'System.UInt16') -> None: ...
    def WriteInt16(self, value: 'System.Int16') -> None: ...
    def WriteUInt32(self, value: 'System.UInt32') -> None: ...
    def WriteInt32(self, value: 'int') -> None: ...
    def WriteUInt64(self, value: 'System.UInt64') -> None: ...
    def WriteInt64(self, value: 'int') -> None: ...
    def WriteBinHeader(self, length: 'int') -> None: ...
    @overload
    def WriteString(self) -> 'System.Buffers.ReadOnlySequence_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]': ...
    @overload
    def WriteString(self, utf8stringBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteStringHeader(self, byteCount: 'int') -> None: ...
    def WriteExtensionFormatHeader(self, extensionHeader: 'MessagePack.ExtensionHeader') -> None: ...
    def WriteExtensionFormat(self, extensionData: 'MessagePack.ExtensionResult') -> None: ...
    def GetSpan(self, length: 'int') -> 'System.Span[int]': ...
    def Advance(self, length: 'int') -> None: ...
    @staticmethod
    @overload
    def GetEncodedLength(value: 'int') -> 'int': ...
    @staticmethod
    @overload
    def GetEncodedLength(value: 'System.UInt64') -> 'int': ...

class Nil(System.ValueType, System.IEquatable[MessagePack.Nil]):
    Default: 'MessagePack.Nil' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'MessagePack.Nil') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class ReservedExtensionTypeCodes:
    UnityVector2: 'System.SByte' = ...
    UnityVector3: 'System.SByte' = ...
    UnityVector4: 'System.SByte' = ...
    UnityQuaternion: 'System.SByte' = ...
    UnityColor: 'System.SByte' = ...
    UnityBounds: 'System.SByte' = ...
    UnityRect: 'System.SByte' = ...
    UnityInt: 'System.SByte' = ...
    UnityFloat: 'System.SByte' = ...
    UnityDouble: 'System.SByte' = ...
    Lz4BlockArray: 'System.SByte' = ...
    Lz4Block: 'System.SByte' = ...
    TypelessFormatter: 'System.SByte' = ...

class SequencePool:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maxSize: 'int') -> None: ...
    @overload
    def __init__(self, maxSize: 'int', arrayPool: 'System.Buffers.ArrayPool[int]') -> None: ...
    @overload
    def __init__(self, maxSize: 'int', memoryPool: 'System.Buffers.MemoryPool[int]') -> None: ...
    def Clear(self) -> None: ...

class MessagePackKnownFormatterAttribute(System.Attribute):
    def __init__(self, formatterType: 'System.Type') -> None: ...
    FormatterType: 'System.Type' = ...

class MessagePackAssumedFormattableAttribute(System.Attribute):
    def __init__(self, formattableType: 'System.Type') -> None: ...
    FormattableType: 'System.Type' = ...

class ExcludeFormatterFromSourceGeneratedResolverAttribute(System.Attribute):
    def __init__(self) -> None: ...

class MessagePackObjectAttribute(System.Attribute):
    def __init__(self, keyAsPropertyName: 'bool') -> None: ...
    KeyAsPropertyName: 'bool' = ...
    SuppressSourceGeneration: 'bool' = ...
    AllowPrivate: 'bool' = ...

class KeyAttribute(System.Attribute):
    @overload
    def __init__(self, x: 'int') -> None: ...
    @overload
    def __init__(self, x: 'str') -> None: ...
    IntKey: 'Optional[int]' = ...
    StringKey: 'str' = ...

class IgnoreMemberAttribute(System.Attribute):
    def __init__(self) -> None: ...

class UnionAttribute(System.Attribute):
    @overload
    def __init__(self, key: 'int', subType: 'System.Type') -> None: ...
    @overload
    def __init__(self, key: 'int', subType: 'str') -> None: ...
    Key: 'int' = ...
    SubType: 'System.Type' = ...

class SerializationConstructorAttribute(System.Attribute):
    def __init__(self) -> None: ...

class MessagePackFormatterAttribute(System.Attribute):
    @overload
    def __init__(self, formatterType: 'System.Type') -> None: ...
    @overload
    def __init__(self, formatterType: 'System.Type', arguments: 'List[Any]') -> None: ...
    FormatterType: 'System.Type' = ...
    Arguments: 'List[Any]' = ...

class IMessagePackSerializationCallbackReceiver:
    def OnBeforeSerialize(self) -> None: ...
    def OnAfterDeserialize(self) -> None: ...

from . import Resolvers as Resolvers
from . import LZ4 as LZ4
from . import Internal as Internal
from . import ImmutableCollection as ImmutableCollection
from . import Formatters as Formatters
