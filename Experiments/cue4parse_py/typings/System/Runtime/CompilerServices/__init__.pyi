from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class RuntimeHelpers:
    OffsetToStringData: 'int' = ...
    @staticmethod
    def InitializeArray(array: 'System.Array', fldHandle: 'System.RuntimeFieldHandle') -> None: ...
    @staticmethod
    def GetObjectValue(obj: 'Any') -> 'Any': ...
    @staticmethod
    def RunClassConstructor(type: 'System.RuntimeTypeHandle') -> None: ...
    @staticmethod
    def RunModuleConstructor(module: 'System.ModuleHandle') -> None: ...
    @staticmethod
    @overload
    def PrepareMethod(method: 'System.RuntimeMethodHandle') -> None: ...
    @staticmethod
    @overload
    def PrepareMethod(method: 'System.RuntimeMethodHandle', instantiation: 'List[System.RuntimeTypeHandle]') -> None: ...
    @staticmethod
    def PrepareDelegate(d: 'System.Delegate') -> None: ...
    @staticmethod
    def GetHashCode(o: 'Any') -> 'int': ...
    @staticmethod
    def Equals(o1: 'Any', o2: 'Any') -> 'bool': ...
    @staticmethod
    def EnsureSufficientExecutionStack() -> None: ...
    @staticmethod
    def TryEnsureSufficientExecutionStack() -> 'bool': ...
    @staticmethod
    def GetUninitializedObject(type: 'System.Type') -> 'Any': ...
    @staticmethod
    def AllocateTypeAssociatedMemory(type: 'System.Type', size: 'int') -> 'System.IntPtr': ...
    @staticmethod
    def Box(type: 'System.RuntimeTypeHandle') -> Tuple['Any', 'System.Byte']: ...
    @staticmethod
    def SizeOf(type: 'System.RuntimeTypeHandle') -> 'int': ...
    @staticmethod
    def GetSubArray(array: 'List[T]', range: 'System.Range') -> 'List[T]': ...
    @staticmethod
    def ExecuteCodeWithGuaranteedCleanup(code: 'System.Runtime.CompilerServices.RuntimeHelpers.TryCode', backoutCode: 'System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode', userData: 'Any') -> None: ...
    @staticmethod
    def PrepareContractedDelegate(d: 'System.Delegate') -> None: ...
    @staticmethod
    def ProbeForSufficientStack() -> None: ...
    @staticmethod
    def PrepareConstrainedRegions() -> None: ...
    @staticmethod
    def PrepareConstrainedRegionsNoOP() -> None: ...
    @staticmethod
    def CreateSpan(fldHandle: 'System.RuntimeFieldHandle') -> 'System.ReadOnlySpan[T]': ...
    @staticmethod
    def IsReferenceOrContainsReferences() -> 'bool': ...

class AccessedThroughPropertyAttribute(System.Attribute):
    def __init__(self, propertyName: 'str') -> None: ...
    PropertyName: 'str' = ...

class AsyncIteratorMethodBuilder(System.ValueType):
    @staticmethod
    def Create() -> 'System.Runtime.CompilerServices.AsyncIteratorMethodBuilder': ...
    def MoveNext(self) -> 'TStateMachine': ...
    def AwaitOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def AwaitUnsafeOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def Complete(self) -> None: ...

class AsyncIteratorStateMachineAttribute(System.Runtime.CompilerServices.StateMachineAttribute):
    def __init__(self, stateMachineType: 'System.Type') -> None: ...

class AsyncMethodBuilderAttribute(System.Attribute):
    def __init__(self, builderType: 'System.Type') -> None: ...
    BuilderType: 'System.Type' = ...

class AsyncStateMachineAttribute(System.Runtime.CompilerServices.StateMachineAttribute):
    def __init__(self, stateMachineType: 'System.Type') -> None: ...

class AsyncTaskMethodBuilder(System.ValueType):
    Task: 'System.Threading.Tasks.Task' = ...
    @staticmethod
    def Create() -> 'System.Runtime.CompilerServices.AsyncTaskMethodBuilder': ...
    def Start(self) -> 'TStateMachine': ...
    def SetStateMachine(self, stateMachine: 'System.Runtime.CompilerServices.IAsyncStateMachine') -> None: ...
    def AwaitOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def AwaitUnsafeOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def SetResult(self) -> None: ...
    def SetException(self, exception: 'System.Exception') -> None: ...

class AsyncValueTaskMethodBuilder(System.ValueType):
    Task: 'System.Threading.Tasks.ValueTask' = ...
    @staticmethod
    def Create() -> 'System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder': ...
    def Start(self) -> 'TStateMachine': ...
    def SetStateMachine(self, stateMachine: 'System.Runtime.CompilerServices.IAsyncStateMachine') -> None: ...
    def SetResult(self) -> None: ...
    def SetException(self, exception: 'System.Exception') -> None: ...
    def AwaitOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def AwaitUnsafeOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...

class AsyncVoidMethodBuilder(System.ValueType):
    @staticmethod
    def Create() -> 'System.Runtime.CompilerServices.AsyncVoidMethodBuilder': ...
    def Start(self) -> 'TStateMachine': ...
    def SetStateMachine(self, stateMachine: 'System.Runtime.CompilerServices.IAsyncStateMachine') -> None: ...
    def AwaitOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def AwaitUnsafeOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def SetResult(self) -> None: ...
    def SetException(self, exception: 'System.Exception') -> None: ...

class CallerArgumentExpressionAttribute(System.Attribute):
    def __init__(self, parameterName: 'str') -> None: ...
    ParameterName: 'str' = ...

class CallerFilePathAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CallerLineNumberAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CallerMemberNameAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CallConvCdecl:
    def __init__(self) -> None: ...

class CallConvFastcall:
    def __init__(self) -> None: ...

class CallConvStdcall:
    def __init__(self) -> None: ...

class CallConvSwift:
    def __init__(self) -> None: ...

class CallConvSuppressGCTransition:
    def __init__(self) -> None: ...

class CallConvThiscall:
    def __init__(self) -> None: ...

class CallConvMemberFunction:
    def __init__(self) -> None: ...

class CollectionBuilderAttribute(System.Attribute):
    def __init__(self, builderType: 'System.Type', methodName: 'str') -> None: ...
    BuilderType: 'System.Type' = ...
    MethodName: 'str' = ...

class CompilationRelaxations(enum.Enum):
    NoStringInterning = ...

class CompilationRelaxationsAttribute(System.Attribute):
    @overload
    def __init__(self, relaxations: 'int') -> None: ...
    @overload
    def __init__(self, relaxations: 'System.Runtime.CompilerServices.CompilationRelaxations') -> None: ...
    CompilationRelaxations: 'int' = ...

class CompilerFeatureRequiredAttribute(System.Attribute):
    def __init__(self, featureName: 'str') -> None: ...
    RefStructs: 'str' = ...
    RequiredMembers: 'str' = ...
    FeatureName: 'str' = ...
    IsOptional: 'bool' = ...

class CompilerGeneratedAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CompilerGlobalScopeAttribute(System.Attribute):
    def __init__(self) -> None: ...

class ConfiguredAsyncDisposable(System.ValueType):
    def DisposeAsync(self) -> 'System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable': ...

class ConfiguredValueTaskAwaitable(System.ValueType):
    def GetAwaiter(self) -> 'System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter': ...

class ContractHelper:
    @staticmethod
    def RaiseContractFailedEvent(failureKind: 'System.Diagnostics.Contracts.ContractFailureKind', userMessage: 'str', conditionText: 'str', innerException: 'System.Exception') -> 'str': ...
    @staticmethod
    def TriggerFailure(kind: 'System.Diagnostics.Contracts.ContractFailureKind', displayMessage: 'str', userMessage: 'str', conditionText: 'str', innerException: 'System.Exception') -> None: ...

class CreateNewOnMetadataUpdateAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CustomConstantAttribute(System.Attribute):
    Value: 'Any' = ...

class DateTimeConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self, ticks: 'int') -> None: ...
    Value: 'Any' = ...

class DecimalConstantAttribute(System.Attribute):
    @overload
    def __init__(self, scale: 'int', sign: 'int', hi: 'System.UInt32', mid: 'System.UInt32', low: 'System.UInt32') -> None: ...
    @overload
    def __init__(self, scale: 'int', sign: 'int', hi: 'int', mid: 'int', low: 'int') -> None: ...
    Value: 'System.Decimal' = ...

class DefaultDependencyAttribute(System.Attribute):
    def __init__(self, loadHintArgument: 'System.Runtime.CompilerServices.LoadHint') -> None: ...
    LoadHint: 'System.Runtime.CompilerServices.LoadHint' = ...

class DependencyAttribute(System.Attribute):
    def __init__(self, dependentAssemblyArgument: 'str', loadHintArgument: 'System.Runtime.CompilerServices.LoadHint') -> None: ...
    DependentAssembly: 'str' = ...
    LoadHint: 'System.Runtime.CompilerServices.LoadHint' = ...

class DisablePrivateReflectionAttribute(System.Attribute):
    def __init__(self) -> None: ...

class DisableRuntimeMarshallingAttribute(System.Attribute):
    def __init__(self) -> None: ...

class DiscardableAttribute(System.Attribute):
    def __init__(self) -> None: ...

class EnumeratorCancellationAttribute(System.Attribute):
    def __init__(self) -> None: ...

class ExtensionAttribute(System.Attribute):
    def __init__(self) -> None: ...

class FixedAddressValueTypeAttribute(System.Attribute):
    def __init__(self) -> None: ...

class FixedBufferAttribute(System.Attribute):
    def __init__(self, elementType: 'System.Type', length: 'int') -> None: ...
    ElementType: 'System.Type' = ...
    Length: 'int' = ...

class FormattableStringFactory:
    @staticmethod
    def Create(format: 'str', arguments: 'List[Any]') -> 'System.FormattableString': ...

class IAsyncStateMachine:
    def MoveNext(self) -> None: ...
    def SetStateMachine(self, stateMachine: 'System.Runtime.CompilerServices.IAsyncStateMachine') -> None: ...

class ICastable:
    def IsInstanceOfInterface(self, interfaceType: 'System.RuntimeTypeHandle') -> Tuple['bool', 'System.Exception']: ...
    def GetImplType(self, interfaceType: 'System.RuntimeTypeHandle') -> 'System.RuntimeTypeHandle': ...

class IndexerNameAttribute(System.Attribute):
    def __init__(self, indexerName: 'str') -> None: ...

class INotifyCompletion:
    def OnCompleted(self, continuation: 'System.Action') -> None: ...

class ICriticalNotifyCompletion(System.Runtime.CompilerServices.INotifyCompletion):
    def UnsafeOnCompleted(self, continuation: 'System.Action') -> None: ...

class InternalsVisibleToAttribute(System.Attribute):
    def __init__(self, assemblyName: 'str') -> None: ...
    AssemblyName: 'str' = ...
    AllInternalsVisible: 'bool' = ...

class IsByRefLikeAttribute(System.Attribute):
    def __init__(self) -> None: ...

class InlineArrayAttribute(System.Attribute):
    def __init__(self, length: 'int') -> None: ...
    Length: 'int' = ...

class IsConst:
    pass

class IsExternalInit:
    pass

class IsReadOnlyAttribute(System.Attribute):
    def __init__(self) -> None: ...

class IsVolatile:
    pass

class InterpolatedStringHandlerAttribute(System.Attribute):
    def __init__(self) -> None: ...

class InterpolatedStringHandlerArgumentAttribute(System.Attribute):
    @overload
    def __init__(self, argument: 'str') -> None: ...
    @overload
    def __init__(self, arguments: 'List[str]') -> None: ...
    Arguments: 'List[str]' = ...

class DefaultInterpolatedStringHandler(System.ValueType):
    @overload
    def __init__(self, literalLength: 'int', formattedCount: 'int') -> None: ...
    @overload
    def __init__(self, literalLength: 'int', formattedCount: 'int', provider: 'System.IFormatProvider') -> None: ...
    @overload
    def __init__(self, literalLength: 'int', formattedCount: 'int', provider: 'System.IFormatProvider', initialBuffer: 'System.Span[System.Char]') -> None: ...
    def ToString(self) -> 'str': ...
    def ToStringAndClear(self) -> 'str': ...
    def AppendLiteral(self, value: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'T') -> None: ...
    @overload
    def AppendFormatted(self, value: 'T', format: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'T', alignment: 'int') -> None: ...
    @overload
    def AppendFormatted(self, value: 'T', alignment: 'int', format: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def AppendFormatted(self, value: 'System.ReadOnlySpan[System.Char]', alignment: 'int', format: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'str', alignment: 'int', format: 'str') -> None: ...
    @overload
    def AppendFormatted(self, value: 'Any', alignment: 'int', format: 'str') -> None: ...

class IsUnmanagedAttribute(System.Attribute):
    def __init__(self) -> None: ...

class IteratorStateMachineAttribute(System.Runtime.CompilerServices.StateMachineAttribute):
    def __init__(self, stateMachineType: 'System.Type') -> None: ...

class ITuple:
    Length: 'int' = ...
    __getitem__: 'Any' = ...

class LoadHint(enum.Enum):
    Default = ...
    Always = ...
    Sometimes = ...

class MethodCodeType(enum.Enum):
    IL = ...
    Native = ...
    OPTIL = ...
    Runtime = ...

class MethodImplAttribute(System.Attribute):
    @overload
    def __init__(self, methodImplOptions: 'System.Runtime.CompilerServices.MethodImplOptions') -> None: ...
    @overload
    def __init__(self, value: 'System.Int16') -> None: ...
    @overload
    def __init__(self) -> None: ...
    MethodCodeType: 'System.Runtime.CompilerServices.MethodCodeType' = ...
    Value: 'System.Runtime.CompilerServices.MethodImplOptions' = ...

class MethodImplOptions(enum.Enum):
    Unmanaged = ...
    NoInlining = ...
    ForwardRef = ...
    Synchronized = ...
    NoOptimization = ...
    PreserveSig = ...
    AggressiveInlining = ...
    AggressiveOptimization = ...
    InternalCall = ...

class ModuleInitializerAttribute(System.Attribute):
    def __init__(self) -> None: ...

class MetadataUpdateOriginalTypeAttribute(System.Attribute):
    def __init__(self, originalType: 'System.Type') -> None: ...
    OriginalType: 'System.Type' = ...

class NullableAttribute(System.Attribute):
    @overload
    def __init__(self, value: 'int') -> None: ...
    @overload
    def __init__(self, value: 'List[int]') -> None: ...
    NullableFlags: 'List[int]' = ...

class NullableContextAttribute(System.Attribute):
    def __init__(self, value: 'int') -> None: ...
    Flag: 'int' = ...

class NullablePublicOnlyAttribute(System.Attribute):
    def __init__(self, value: 'bool') -> None: ...
    IncludesInternals: 'bool' = ...

class ReferenceAssemblyAttribute(System.Attribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, description: 'str') -> None: ...
    Description: 'str' = ...

class ParamCollectionAttribute(System.Attribute):
    def __init__(self) -> None: ...

class PoolingAsyncValueTaskMethodBuilder(System.ValueType):
    Task: 'System.Threading.Tasks.ValueTask' = ...
    @staticmethod
    def Create() -> 'System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder': ...
    def Start(self) -> 'TStateMachine': ...
    def SetStateMachine(self, stateMachine: 'System.Runtime.CompilerServices.IAsyncStateMachine') -> None: ...
    def SetResult(self) -> None: ...
    def SetException(self, exception: 'System.Exception') -> None: ...
    def AwaitOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...
    def AwaitUnsafeOnCompleted(self) -> Tuple['TAwaiter', 'TStateMachine']: ...

class PreserveBaseOverridesAttribute(System.Attribute):
    def __init__(self) -> None: ...

class OverloadResolutionPriorityAttribute(System.Attribute):
    def __init__(self, priority: 'int') -> None: ...
    Priority: 'int' = ...

class RefSafetyRulesAttribute(System.Attribute):
    def __init__(self, version: 'int') -> None: ...
    Version: 'int' = ...

class RequiredMemberAttribute(System.Attribute):
    def __init__(self) -> None: ...

class RequiresLocationAttribute(System.Attribute):
    def __init__(self) -> None: ...

class RuntimeCompatibilityAttribute(System.Attribute):
    def __init__(self) -> None: ...
    WrapNonExceptionThrows: 'bool' = ...

class RuntimeFeature:
    PortablePdb: 'str' = ...
    DefaultImplementationsOfInterfaces: 'str' = ...
    UnmanagedSignatureCallingConvention: 'str' = ...
    CovariantReturnsOfClasses: 'str' = ...
    ByRefFields: 'str' = ...
    ByRefLikeGenerics: 'str' = ...
    VirtualStaticsInInterfaces: 'str' = ...
    NumericIntPtr: 'str' = ...
    IsDynamicCodeSupported: 'bool' = ...
    IsDynamicCodeCompiled: 'bool' = ...
    @staticmethod
    def IsSupported(feature: 'str') -> 'bool': ...

class RuntimeWrappedException(System.Exception, System.Runtime.Serialization.ISerializable):
    def __init__(self, thrownObject: 'Any') -> None: ...
    WrappedException: 'Any' = ...
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...

class ScopedRefAttribute(System.Attribute):
    def __init__(self) -> None: ...

class SkipLocalsInitAttribute(System.Attribute):
    def __init__(self) -> None: ...

class SpecialNameAttribute(System.Attribute):
    def __init__(self) -> None: ...

class StateMachineAttribute(System.Attribute):
    def __init__(self, stateMachineType: 'System.Type') -> None: ...
    StateMachineType: 'System.Type' = ...

class StringFreezingAttribute(System.Attribute):
    def __init__(self) -> None: ...

class IStrongBox:
    Value: 'Any' = ...

class SuppressIldasmAttribute(System.Attribute):
    def __init__(self) -> None: ...

class SwitchExpressionException(System.InvalidOperationException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, unmatchedValue: 'Any') -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...
    UnmatchedValue: 'Any' = ...
    Message: 'str' = ...
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...

class TaskAwaiter(System.ValueType, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ITaskAwaiter):
    IsCompleted: 'bool' = ...
    def OnCompleted(self, continuation: 'System.Action') -> None: ...
    def UnsafeOnCompleted(self, continuation: 'System.Action') -> None: ...
    def GetResult(self) -> None: ...

class ConfiguredTaskAwaitable(System.ValueType):
    def GetAwaiter(self) -> 'System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter': ...

class TupleElementNamesAttribute(System.Attribute):
    def __init__(self, transformNames: 'List[str]') -> None: ...
    TransformNames: 'System.Collections.Generic.IList[str]' = ...

class TypeForwardedFromAttribute(System.Attribute):
    def __init__(self, assemblyFullName: 'str') -> None: ...
    AssemblyFullName: 'str' = ...

class TypeForwardedToAttribute(System.Attribute):
    def __init__(self, destination: 'System.Type') -> None: ...
    Destination: 'System.Type' = ...

class Unsafe:
    @staticmethod
    def AsPointer() -> Tuple['System.Void*', 'T']: ...
    @staticmethod
    def SizeOf() -> 'int': ...
    @staticmethod
    @overload
    def As(o: 'Any') -> 'T': ...
    @staticmethod
    @overload
    def As() -> Tuple['TTo', 'TFrom']: ...
    @staticmethod
    @overload
    def Add(elementOffset: 'int') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Add(elementOffset: 'System.IntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Add(source: 'System.Void*', elementOffset: 'int') -> 'System.Void*': ...
    @staticmethod
    @overload
    def Add(elementOffset: 'System.UIntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def AddByteOffset(byteOffset: 'System.UIntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def AddByteOffset(byteOffset: 'System.IntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    def AreSame() -> Tuple['bool', 'T', 'T']: ...
    @staticmethod
    def BitCast(source: 'TFrom') -> 'TTo': ...
    @staticmethod
    @overload
    def Copy(destination: 'System.Void*') -> 'T': ...
    @staticmethod
    @overload
    def Copy(source: 'System.Void*') -> 'T': ...
    @staticmethod
    @overload
    def CopyBlock(destination: 'System.Void*', source: 'System.Void*', byteCount: 'System.UInt32') -> None: ...
    @staticmethod
    @overload
    def CopyBlock(byteCount: 'System.UInt32') -> Tuple['System.Byte', 'System.Byte']: ...
    @staticmethod
    @overload
    def CopyBlockUnaligned(destination: 'System.Void*', source: 'System.Void*', byteCount: 'System.UInt32') -> None: ...
    @staticmethod
    @overload
    def CopyBlockUnaligned(byteCount: 'System.UInt32') -> Tuple['System.Byte', 'System.Byte']: ...
    @staticmethod
    def IsAddressGreaterThan() -> Tuple['bool', 'T', 'T']: ...
    @staticmethod
    def IsAddressLessThan() -> Tuple['bool', 'T', 'T']: ...
    @staticmethod
    @overload
    def InitBlock(startAddress: 'System.Void*', value: 'int', byteCount: 'System.UInt32') -> None: ...
    @staticmethod
    @overload
    def InitBlock(value: 'int', byteCount: 'System.UInt32') -> 'System.Byte': ...
    @staticmethod
    @overload
    def InitBlockUnaligned(startAddress: 'System.Void*', value: 'int', byteCount: 'System.UInt32') -> None: ...
    @staticmethod
    @overload
    def InitBlockUnaligned(value: 'int', byteCount: 'System.UInt32') -> 'System.Byte': ...
    @staticmethod
    @overload
    def ReadUnaligned(source: 'System.Void*') -> 'T': ...
    @staticmethod
    @overload
    def ReadUnaligned() -> Tuple['T', 'System.Byte']: ...
    @staticmethod
    @overload
    def WriteUnaligned(destination: 'System.Void*', value: 'T') -> None: ...
    @staticmethod
    @overload
    def WriteUnaligned(value: 'T') -> 'System.Byte': ...
    @staticmethod
    def Read(source: 'System.Void*') -> 'T': ...
    @staticmethod
    def Write(destination: 'System.Void*', value: 'T') -> None: ...
    @staticmethod
    @overload
    def AsRef(source: 'System.Void*') -> 'T': ...
    @staticmethod
    @overload
    def AsRef() -> Tuple['T', 'T']: ...
    @staticmethod
    def ByteOffset() -> Tuple['System.IntPtr', 'T', 'T']: ...
    @staticmethod
    def NullRef() -> 'T': ...
    @staticmethod
    def IsNullRef() -> Tuple['bool', 'T']: ...
    @staticmethod
    def SkipInit() -> 'T': ...
    @staticmethod
    @overload
    def Subtract(elementOffset: 'int') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Subtract(source: 'System.Void*', elementOffset: 'int') -> 'System.Void*': ...
    @staticmethod
    @overload
    def Subtract(elementOffset: 'System.IntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Subtract(elementOffset: 'System.UIntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def SubtractByteOffset(byteOffset: 'System.IntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def SubtractByteOffset(byteOffset: 'System.UIntPtr') -> Tuple['T', 'T']: ...
    @staticmethod
    def Unbox(box: 'Any') -> 'T': ...

class UnsafeAccessorKind(enum.Enum):
    Constructor = ...
    Method = ...
    StaticMethod = ...
    Field = ...
    StaticField = ...

class UnsafeAccessorAttribute(System.Attribute):
    def __init__(self, kind: 'System.Runtime.CompilerServices.UnsafeAccessorKind') -> None: ...
    Kind: 'System.Runtime.CompilerServices.UnsafeAccessorKind' = ...
    Name: 'str' = ...

class UnsafeValueTypeAttribute(System.Attribute):
    def __init__(self) -> None: ...

class ValueTaskAwaiter(System.ValueType, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter):
    IsCompleted: 'bool' = ...
    def GetResult(self) -> None: ...
    def OnCompleted(self, continuation: 'System.Action') -> None: ...
    def UnsafeOnCompleted(self, continuation: 'System.Action') -> None: ...

class YieldAwaitable(System.ValueType):
    def GetAwaiter(self) -> 'System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter': ...

class IDispatchConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IUnknownConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IDispatchConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IUnknownConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IRuntimeVariables:
    Count: 'int' = ...
    __getitem__: 'Any' = ...

class RuntimeOps:
    @staticmethod
    def ExpandoTryGetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> Tuple['bool', 'System.Object']: ...
    @staticmethod
    def ExpandoTrySetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', value: 'Any', name: 'str', ignoreCase: 'bool') -> 'Any': ...
    @staticmethod
    def ExpandoTryDeleteValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> 'bool': ...
    @staticmethod
    def ExpandoCheckVersion(expando: 'System.Dynamic.ExpandoObject', version: 'Any') -> 'bool': ...
    @staticmethod
    def ExpandoPromoteClass(expando: 'System.Dynamic.ExpandoObject', oldClass: 'Any', newClass: 'Any') -> None: ...
    @staticmethod
    def Quote(expression: 'System.Linq.Expressions.Expression', hoistedLocals: 'Any', locals: 'List[Any]') -> 'System.Linq.Expressions.Expression': ...
    @staticmethod
    def MergeRuntimeVariables(first: 'System.Runtime.CompilerServices.IRuntimeVariables', second: 'System.Runtime.CompilerServices.IRuntimeVariables', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables(data: 'List[Any]', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables() -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...

class CallSite:
    Binder: 'System.Runtime.CompilerServices.CallSiteBinder' = ...
    @staticmethod
    def Create(delegateType: 'System.Type', binder: 'System.Runtime.CompilerServices.CallSiteBinder') -> 'System.Runtime.CompilerServices.CallSite': ...

class CallSiteBinder:
    UpdateLabel: 'System.Linq.Expressions.LabelTarget' = ...
    def Bind(self, args: 'List[Any]', parameters: 'System.Collections.ObjectModel.ReadOnlyCollection[System.Linq.Expressions.ParameterExpression]', returnLabel: 'System.Linq.Expressions.LabelTarget') -> 'System.Linq.Expressions.Expression': ...
    def BindDelegate(self, site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteOps:
    @staticmethod
    def CreateMatchmaker(site: 'CallSite[T]') -> 'CallSite[T]': ...
    @staticmethod
    def SetNotMatched(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def GetMatch(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def ClearMatch(site: 'System.Runtime.CompilerServices.CallSite') -> None: ...
    @staticmethod
    def AddRule(site: 'CallSite[T]', rule: 'T') -> None: ...
    @staticmethod
    def UpdateRules(this: 'CallSite[T]', matched: 'int') -> None: ...
    @staticmethod
    def GetRules(site: 'CallSite[T]') -> 'List[T]': ...
    @staticmethod
    def GetRuleCache(site: 'CallSite[T]') -> 'RuleCache[T]': ...
    @staticmethod
    def MoveRule(cache: 'RuleCache[T]', rule: 'T', i: 'int') -> None: ...
    @staticmethod
    def GetCachedRules(cache: 'RuleCache[T]') -> 'List[T]': ...
    @staticmethod
    def Bind(binder: 'System.Runtime.CompilerServices.CallSiteBinder', site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteHelpers:
    @staticmethod
    def IsInternalFrame(mb: 'System.Reflection.MethodBase') -> 'bool': ...

class DynamicAttribute(System.Attribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, transformFlags: 'List[bool]') -> None: ...
    TransformFlags: 'System.Collections.Generic.IList[bool]' = ...

class DebugInfoGenerator:
    @staticmethod
    def CreatePdbGenerator() -> 'System.Runtime.CompilerServices.DebugInfoGenerator': ...
    def MarkSequencePoint(self, method: 'System.Linq.Expressions.LambdaExpression', ilOffset: 'int', sequencePoint: 'System.Linq.Expressions.DebugInfoExpression') -> None: ...

class Closure:
    def __init__(self, constants: 'List[Any]', locals: 'List[Any]') -> None: ...
    Constants: 'List[Any]' = ...
    Locals: 'List[Any]' = ...

class IRuntimeVariables:
    Count: 'int' = ...
    __getitem__: 'Any' = ...

class RuntimeOps:
    @staticmethod
    def ExpandoTryGetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> Tuple['bool', 'System.Object']: ...
    @staticmethod
    def ExpandoTrySetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', value: 'Any', name: 'str', ignoreCase: 'bool') -> 'Any': ...
    @staticmethod
    def ExpandoTryDeleteValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> 'bool': ...
    @staticmethod
    def ExpandoCheckVersion(expando: 'System.Dynamic.ExpandoObject', version: 'Any') -> 'bool': ...
    @staticmethod
    def ExpandoPromoteClass(expando: 'System.Dynamic.ExpandoObject', oldClass: 'Any', newClass: 'Any') -> None: ...
    @staticmethod
    def Quote(expression: 'System.Linq.Expressions.Expression', hoistedLocals: 'Any', locals: 'List[Any]') -> 'System.Linq.Expressions.Expression': ...
    @staticmethod
    def MergeRuntimeVariables(first: 'System.Runtime.CompilerServices.IRuntimeVariables', second: 'System.Runtime.CompilerServices.IRuntimeVariables', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables(data: 'List[Any]', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables() -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...

class CallSite:
    Binder: 'System.Runtime.CompilerServices.CallSiteBinder' = ...
    @staticmethod
    def Create(delegateType: 'System.Type', binder: 'System.Runtime.CompilerServices.CallSiteBinder') -> 'System.Runtime.CompilerServices.CallSite': ...

class CallSiteBinder:
    UpdateLabel: 'System.Linq.Expressions.LabelTarget' = ...
    def Bind(self, args: 'List[Any]', parameters: 'System.Collections.ObjectModel.ReadOnlyCollection[System.Linq.Expressions.ParameterExpression]', returnLabel: 'System.Linq.Expressions.LabelTarget') -> 'System.Linq.Expressions.Expression': ...
    def BindDelegate(self, site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteOps:
    @staticmethod
    def CreateMatchmaker(site: 'CallSite[T]') -> 'CallSite[T]': ...
    @staticmethod
    def SetNotMatched(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def GetMatch(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def ClearMatch(site: 'System.Runtime.CompilerServices.CallSite') -> None: ...
    @staticmethod
    def AddRule(site: 'CallSite[T]', rule: 'T') -> None: ...
    @staticmethod
    def UpdateRules(this: 'CallSite[T]', matched: 'int') -> None: ...
    @staticmethod
    def GetRules(site: 'CallSite[T]') -> 'List[T]': ...
    @staticmethod
    def GetRuleCache(site: 'CallSite[T]') -> 'RuleCache[T]': ...
    @staticmethod
    def MoveRule(cache: 'RuleCache[T]', rule: 'T', i: 'int') -> None: ...
    @staticmethod
    def GetCachedRules(cache: 'RuleCache[T]') -> 'List[T]': ...
    @staticmethod
    def Bind(binder: 'System.Runtime.CompilerServices.CallSiteBinder', site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteHelpers:
    @staticmethod
    def IsInternalFrame(mb: 'System.Reflection.MethodBase') -> 'bool': ...

class DynamicAttribute(System.Attribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, transformFlags: 'List[bool]') -> None: ...
    TransformFlags: 'System.Collections.Generic.IList[bool]' = ...

class DebugInfoGenerator:
    @staticmethod
    def CreatePdbGenerator() -> 'System.Runtime.CompilerServices.DebugInfoGenerator': ...
    def MarkSequencePoint(self, method: 'System.Linq.Expressions.LambdaExpression', ilOffset: 'int', sequencePoint: 'System.Linq.Expressions.DebugInfoExpression') -> None: ...

class Closure:
    def __init__(self, constants: 'List[Any]', locals: 'List[Any]') -> None: ...
    Constants: 'List[Any]' = ...
    Locals: 'List[Any]' = ...

class IsPinned:
    pass

class IsBoxed:
    pass

class IsByValue:
    pass

class IsCopyConstructed:
    pass

class IsExplicitlyDereferenced:
    pass

class IsImplicitlyDereferenced:
    pass

class IsJitIntrinsic:
    pass

class IsLong:
    pass

class IsSignUnspecifiedByte:
    pass

class IsUdtReturn:
    pass

class HasCopySemanticsAttribute(System.Attribute):
    def __init__(self) -> None: ...

class ScopelessEnumAttribute(System.Attribute):
    def __init__(self) -> None: ...

class NativeCppClassAttribute(System.Attribute):
    def __init__(self) -> None: ...

class CppInlineNamespaceAttribute(System.Attribute):
    def __init__(self, dottedName: 'str') -> None: ...

class RequiredAttributeAttribute(System.Attribute):
    def __init__(self, requiredContract: 'System.Type') -> None: ...
    RequiredContract: 'System.Type' = ...

class CompilerMarshalOverride:
    pass

class IDispatchConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IUnknownConstantAttribute(System.Runtime.CompilerServices.CustomConstantAttribute):
    def __init__(self) -> None: ...
    Value: 'Any' = ...

class IRuntimeVariables:
    Count: 'int' = ...
    __getitem__: 'Any' = ...

class RuntimeOps:
    @staticmethod
    def ExpandoTryGetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> Tuple['bool', 'System.Object']: ...
    @staticmethod
    def ExpandoTrySetValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', value: 'Any', name: 'str', ignoreCase: 'bool') -> 'Any': ...
    @staticmethod
    def ExpandoTryDeleteValue(expando: 'System.Dynamic.ExpandoObject', indexClass: 'Any', index: 'int', name: 'str', ignoreCase: 'bool') -> 'bool': ...
    @staticmethod
    def ExpandoCheckVersion(expando: 'System.Dynamic.ExpandoObject', version: 'Any') -> 'bool': ...
    @staticmethod
    def ExpandoPromoteClass(expando: 'System.Dynamic.ExpandoObject', oldClass: 'Any', newClass: 'Any') -> None: ...
    @staticmethod
    def Quote(expression: 'System.Linq.Expressions.Expression', hoistedLocals: 'Any', locals: 'List[Any]') -> 'System.Linq.Expressions.Expression': ...
    @staticmethod
    def MergeRuntimeVariables(first: 'System.Runtime.CompilerServices.IRuntimeVariables', second: 'System.Runtime.CompilerServices.IRuntimeVariables', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables(data: 'List[Any]', indexes: 'List[int]') -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...
    @staticmethod
    @overload
    def CreateRuntimeVariables() -> 'System.Runtime.CompilerServices.IRuntimeVariables': ...

class CallSite:
    Binder: 'System.Runtime.CompilerServices.CallSiteBinder' = ...
    @staticmethod
    def Create(delegateType: 'System.Type', binder: 'System.Runtime.CompilerServices.CallSiteBinder') -> 'System.Runtime.CompilerServices.CallSite': ...

class CallSiteBinder:
    UpdateLabel: 'System.Linq.Expressions.LabelTarget' = ...
    def Bind(self, args: 'List[Any]', parameters: 'System.Collections.ObjectModel.ReadOnlyCollection[System.Linq.Expressions.ParameterExpression]', returnLabel: 'System.Linq.Expressions.LabelTarget') -> 'System.Linq.Expressions.Expression': ...
    def BindDelegate(self, site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteOps:
    @staticmethod
    def CreateMatchmaker(site: 'CallSite[T]') -> 'CallSite[T]': ...
    @staticmethod
    def SetNotMatched(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def GetMatch(site: 'System.Runtime.CompilerServices.CallSite') -> 'bool': ...
    @staticmethod
    def ClearMatch(site: 'System.Runtime.CompilerServices.CallSite') -> None: ...
    @staticmethod
    def AddRule(site: 'CallSite[T]', rule: 'T') -> None: ...
    @staticmethod
    def UpdateRules(this: 'CallSite[T]', matched: 'int') -> None: ...
    @staticmethod
    def GetRules(site: 'CallSite[T]') -> 'List[T]': ...
    @staticmethod
    def GetRuleCache(site: 'CallSite[T]') -> 'RuleCache[T]': ...
    @staticmethod
    def MoveRule(cache: 'RuleCache[T]', rule: 'T', i: 'int') -> None: ...
    @staticmethod
    def GetCachedRules(cache: 'RuleCache[T]') -> 'List[T]': ...
    @staticmethod
    def Bind(binder: 'System.Runtime.CompilerServices.CallSiteBinder', site: 'CallSite[T]', args: 'List[Any]') -> 'T': ...

class CallSiteHelpers:
    @staticmethod
    def IsInternalFrame(mb: 'System.Reflection.MethodBase') -> 'bool': ...

class DynamicAttribute(System.Attribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, transformFlags: 'List[bool]') -> None: ...
    TransformFlags: 'System.Collections.Generic.IList[bool]' = ...

class DebugInfoGenerator:
    @staticmethod
    def CreatePdbGenerator() -> 'System.Runtime.CompilerServices.DebugInfoGenerator': ...
    def MarkSequencePoint(self, method: 'System.Linq.Expressions.LambdaExpression', ilOffset: 'int', sequencePoint: 'System.Linq.Expressions.DebugInfoExpression') -> None: ...

class Closure:
    def __init__(self, constants: 'List[Any]', locals: 'List[Any]') -> None: ...
    Constants: 'List[Any]' = ...
    Locals: 'List[Any]' = ...

