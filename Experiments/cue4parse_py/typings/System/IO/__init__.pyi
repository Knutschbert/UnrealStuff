from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FileLoadException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str', fileName: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', fileName: 'str', inner: 'System.Exception') -> None: ...
    Message: 'str' = ...
    FileName: 'str' = ...
    FusionLog: 'str' = ...
    def ToString(self) -> 'str': ...
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...

class FileNotFoundException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str', fileName: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', fileName: 'str', innerException: 'System.Exception') -> None: ...
    Message: 'str' = ...
    FileName: 'str' = ...
    FusionLog: 'str' = ...
    def ToString(self) -> 'str': ...
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...

class BinaryReader(System.IDisposable):
    @overload
    def __init__(self, input: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, input: 'System.IO.Stream', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, input: 'System.IO.Stream', encoding: 'System.Text.Encoding', leaveOpen: 'bool') -> None: ...
    BaseStream: 'System.IO.Stream' = ...
    def Dispose(self) -> None: ...
    def Close(self) -> None: ...
    def PeekChar(self) -> 'int': ...
    @overload
    def Read(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    def ReadSByte(self) -> 'System.SByte': ...
    def ReadBoolean(self) -> 'bool': ...
    def ReadChar(self) -> 'System.Char': ...
    def ReadInt16(self) -> 'System.Int16': ...
    def ReadUInt16(self) -> 'System.UInt16': ...
    def ReadInt32(self) -> 'int': ...
    def ReadUInt32(self) -> 'System.UInt32': ...
    def ReadInt64(self) -> 'int': ...
    def ReadUInt64(self) -> 'System.UInt64': ...
    def ReadHalf(self) -> 'System.Half': ...
    def ReadSingle(self) -> 'float': ...
    def ReadDouble(self) -> 'float': ...
    def ReadDecimal(self) -> 'System.Decimal': ...
    def ReadString(self) -> 'str': ...
    def ReadChars(self, count: 'int') -> 'List[System.Char]': ...
    def ReadBytes(self, count: 'int') -> 'List[int]': ...
    def Read7BitEncodedInt(self) -> 'int': ...
    def Read7BitEncodedInt64(self) -> 'int': ...

class BinaryWriter(System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, output: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, output: 'System.IO.Stream', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, output: 'System.IO.Stream', encoding: 'System.Text.Encoding', leaveOpen: 'bool') -> None: ...
    Null: 'System.IO.BinaryWriter' = ...
    BaseStream: 'System.IO.Stream' = ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    @overload
    def Write(self, value: 'bool') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.SByte') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', index: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, ch: 'System.Char') -> None: ...
    @overload
    def Write(self, chars: 'List[System.Char]') -> None: ...
    @overload
    def Write(self, chars: 'List[System.Char]', index: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, value: 'System.Decimal') -> None: ...
    @overload
    def Write(self, value: 'System.Int16') -> None: ...
    @overload
    def Write(self, value: 'System.UInt16') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.UInt32') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.UInt64') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, value: 'System.Half') -> None: ...
    @overload
    def Write(self, value: 'str') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Write(self, chars: 'System.ReadOnlySpan[System.Char]') -> None: ...
    def Write7BitEncodedInt(self, value: 'int') -> None: ...
    def Write7BitEncodedInt64(self, value: 'int') -> None: ...

class BufferedStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    UnderlyingStream: 'System.IO.Stream' = ...
    BufferSize: 'int' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, destination: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class Directory:
    @staticmethod
    def GetParent(path: 'str') -> 'System.IO.DirectoryInfo': ...
    @staticmethod
    @overload
    def CreateDirectory(path: 'str') -> 'System.IO.DirectoryInfo': ...
    @staticmethod
    @overload
    def CreateDirectory(path: 'str', unixCreateMode: 'System.IO.UnixFileMode') -> 'System.IO.DirectoryInfo': ...
    @staticmethod
    def CreateTempSubdirectory(prefix: 'str') -> 'System.IO.DirectoryInfo': ...
    @staticmethod
    def Exists(path: 'str') -> 'bool': ...
    @staticmethod
    def SetCreationTime(path: 'str', creationTime: 'System.DateTime') -> None: ...
    @staticmethod
    def SetCreationTimeUtc(path: 'str', creationTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    def GetCreationTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    def GetCreationTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    def SetLastWriteTime(path: 'str', lastWriteTime: 'System.DateTime') -> None: ...
    @staticmethod
    def SetLastWriteTimeUtc(path: 'str', lastWriteTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    def GetLastWriteTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    def GetLastWriteTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    def SetLastAccessTime(path: 'str', lastAccessTime: 'System.DateTime') -> None: ...
    @staticmethod
    def SetLastAccessTimeUtc(path: 'str', lastAccessTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    def GetLastAccessTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    def GetLastAccessTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetFiles(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFiles(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFiles(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFiles(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetDirectories(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetDirectories(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetDirectories(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetDirectories(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFileSystemEntries(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFileSystemEntries(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFileSystemEntries(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def GetFileSystemEntries(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateDirectories(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateDirectories(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateDirectories(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateDirectories(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFiles(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFiles(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFiles(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFiles(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFileSystemEntries(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFileSystemEntries(path: 'str', searchPattern: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFileSystemEntries(path: 'str', searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[str]': ...
    @staticmethod
    @overload
    def EnumerateFileSystemEntries(path: 'str', searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[str]': ...
    @staticmethod
    def GetDirectoryRoot(path: 'str') -> 'str': ...
    @staticmethod
    def GetCurrentDirectory() -> 'str': ...
    @staticmethod
    def SetCurrentDirectory(path: 'str') -> None: ...
    @staticmethod
    def Move(sourceDirName: 'str', destDirName: 'str') -> None: ...
    @staticmethod
    @overload
    def Delete(path: 'str') -> None: ...
    @staticmethod
    @overload
    def Delete(path: 'str', recursive: 'bool') -> None: ...
    @staticmethod
    def GetLogicalDrives() -> 'List[str]': ...
    @staticmethod
    def CreateSymbolicLink(path: 'str', pathToTarget: 'str') -> 'System.IO.FileSystemInfo': ...
    @staticmethod
    def ResolveLinkTarget(linkPath: 'str', returnFinalTarget: 'bool') -> 'System.IO.FileSystemInfo': ...

class DirectoryInfo(System.IO.FileSystemInfo, System.Runtime.Serialization.ISerializable):
    def __init__(self, path: 'str') -> None: ...
    Name: 'str' = ...
    Parent: 'System.IO.DirectoryInfo' = ...
    Root: 'System.IO.DirectoryInfo' = ...
    Exists: 'bool' = ...
    def CreateSubdirectory(self, path: 'str') -> 'System.IO.DirectoryInfo': ...
    def Create(self) -> None: ...
    @overload
    def GetFiles(self) -> 'List[System.IO.FileInfo]': ...
    @overload
    def GetFiles(self, searchPattern: 'str') -> 'List[System.IO.FileInfo]': ...
    @overload
    def GetFiles(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.FileInfo]': ...
    @overload
    def GetFiles(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.FileInfo]': ...
    @overload
    def GetFileSystemInfos(self) -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def GetFileSystemInfos(self, searchPattern: 'str') -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def GetFileSystemInfos(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def GetFileSystemInfos(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def GetDirectories(self) -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def GetDirectories(self, searchPattern: 'str') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def GetDirectories(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def GetDirectories(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def EnumerateDirectories(self) -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def EnumerateDirectories(self, searchPattern: 'str') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def EnumerateDirectories(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def EnumerateDirectories(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.DirectoryInfo]': ...
    @overload
    def EnumerateFiles(self) -> 'List[System.IO.FileInfo]': ...
    @overload
    def EnumerateFiles(self, searchPattern: 'str') -> 'List[System.IO.FileInfo]': ...
    @overload
    def EnumerateFiles(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.FileInfo]': ...
    @overload
    def EnumerateFiles(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.FileInfo]': ...
    @overload
    def EnumerateFileSystemInfos(self) -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def EnumerateFileSystemInfos(self, searchPattern: 'str') -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def EnumerateFileSystemInfos(self, searchPattern: 'str', searchOption: 'System.IO.SearchOption') -> 'List[System.IO.FileSystemInfo]': ...
    @overload
    def EnumerateFileSystemInfos(self, searchPattern: 'str', enumerationOptions: 'System.IO.EnumerationOptions') -> 'List[System.IO.FileSystemInfo]': ...
    def MoveTo(self, destDirName: 'str') -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, recursive: 'bool') -> None: ...

class DirectoryNotFoundException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class EnumerationOptions:
    def __init__(self) -> None: ...
    RecurseSubdirectories: 'bool' = ...
    IgnoreInaccessible: 'bool' = ...
    BufferSize: 'int' = ...
    AttributesToSkip: 'System.IO.FileAttributes' = ...
    MatchType: 'System.IO.MatchType' = ...
    MatchCasing: 'System.IO.MatchCasing' = ...
    MaxRecursionDepth: 'int' = ...
    ReturnSpecialDirectories: 'bool' = ...

class EndOfStreamException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class File:
    @staticmethod
    def OpenText(path: 'str') -> 'System.IO.StreamReader': ...
    @staticmethod
    def CreateText(path: 'str') -> 'System.IO.StreamWriter': ...
    @staticmethod
    def AppendText(path: 'str') -> 'System.IO.StreamWriter': ...
    @staticmethod
    @overload
    def Copy(sourceFileName: 'str', destFileName: 'str') -> None: ...
    @staticmethod
    @overload
    def Copy(sourceFileName: 'str', destFileName: 'str', overwrite: 'bool') -> None: ...
    @staticmethod
    @overload
    def Create(path: 'str') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def Create(path: 'str', bufferSize: 'int') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def Create(path: 'str', bufferSize: 'int', options: 'System.IO.FileOptions') -> 'System.IO.FileStream': ...
    @staticmethod
    def Delete(path: 'str') -> None: ...
    @staticmethod
    def Exists(path: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def Open(path: 'str', options: 'System.IO.FileStreamOptions') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def Open(path: 'str', mode: 'System.IO.FileMode') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def Open(path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def Open(path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare') -> 'System.IO.FileStream': ...
    @staticmethod
    def OpenHandle(path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare', options: 'System.IO.FileOptions', preallocationSize: 'int') -> 'Microsoft.Win32.SafeHandles.SafeFileHandle': ...
    @staticmethod
    @overload
    def SetCreationTime(path: 'str', creationTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetCreationTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', creationTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetCreationTimeUtc(path: 'str', creationTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetCreationTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', creationTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def GetCreationTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetCreationTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetCreationTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetCreationTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def SetLastAccessTime(path: 'str', lastAccessTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastAccessTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', lastAccessTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastAccessTimeUtc(path: 'str', lastAccessTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastAccessTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', lastAccessTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def GetLastAccessTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastAccessTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastAccessTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastAccessTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def SetLastWriteTime(path: 'str', lastWriteTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastWriteTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', lastWriteTime: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastWriteTimeUtc(path: 'str', lastWriteTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def SetLastWriteTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', lastWriteTimeUtc: 'System.DateTime') -> None: ...
    @staticmethod
    @overload
    def GetLastWriteTime(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastWriteTime(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastWriteTimeUtc(path: 'str') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetLastWriteTimeUtc(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.DateTime': ...
    @staticmethod
    @overload
    def GetAttributes(path: 'str') -> 'System.IO.FileAttributes': ...
    @staticmethod
    @overload
    def GetAttributes(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.IO.FileAttributes': ...
    @staticmethod
    @overload
    def SetAttributes(path: 'str', fileAttributes: 'System.IO.FileAttributes') -> None: ...
    @staticmethod
    @overload
    def SetAttributes(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', fileAttributes: 'System.IO.FileAttributes') -> None: ...
    @staticmethod
    @overload
    def GetUnixFileMode(path: 'str') -> 'System.IO.UnixFileMode': ...
    @staticmethod
    @overload
    def GetUnixFileMode(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'System.IO.UnixFileMode': ...
    @staticmethod
    @overload
    def SetUnixFileMode(path: 'str', mode: 'System.IO.UnixFileMode') -> None: ...
    @staticmethod
    @overload
    def SetUnixFileMode(fileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', mode: 'System.IO.UnixFileMode') -> None: ...
    @staticmethod
    def OpenRead(path: 'str') -> 'System.IO.FileStream': ...
    @staticmethod
    def OpenWrite(path: 'str') -> 'System.IO.FileStream': ...
    @staticmethod
    @overload
    def ReadAllText(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def ReadAllText(path: 'str', encoding: 'System.Text.Encoding') -> 'str': ...
    @staticmethod
    @overload
    def WriteAllText(path: 'str', contents: 'str') -> None: ...
    @staticmethod
    @overload
    def WriteAllText(path: 'str', contents: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @staticmethod
    @overload
    def WriteAllText(path: 'str', contents: 'str', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def WriteAllText(path: 'str', contents: 'System.ReadOnlySpan[System.Char]', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    def ReadAllBytes(path: 'str') -> 'List[int]': ...
    @staticmethod
    @overload
    def WriteAllBytes(path: 'str', bytes: 'List[int]') -> None: ...
    @staticmethod
    @overload
    def WriteAllBytes(path: 'str', bytes: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def AppendAllBytes(path: 'str', bytes: 'List[int]') -> None: ...
    @staticmethod
    @overload
    def AppendAllBytes(path: 'str', bytes: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def AppendAllBytesAsync(path: 'str', bytes: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllBytesAsync(path: 'str', bytes: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ReadAllLines(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def ReadAllLines(path: 'str', encoding: 'System.Text.Encoding') -> 'List[str]': ...
    @staticmethod
    @overload
    def ReadLines(path: 'str') -> 'List[str]': ...
    @staticmethod
    @overload
    def ReadLines(path: 'str', encoding: 'System.Text.Encoding') -> 'List[str]': ...
    @staticmethod
    @overload
    def ReadLinesAsync(path: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Collections.Generic.IAsyncEnumerable[str]': ...
    @staticmethod
    @overload
    def ReadLinesAsync(path: 'str', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Collections.Generic.IAsyncEnumerable[str]': ...
    @staticmethod
    @overload
    def WriteAllLines(path: 'str', contents: 'List[str]') -> None: ...
    @staticmethod
    @overload
    def WriteAllLines(path: 'str', contents: 'List[str]') -> None: ...
    @staticmethod
    @overload
    def WriteAllLines(path: 'str', contents: 'List[str]', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def WriteAllLines(path: 'str', contents: 'List[str]', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def AppendAllText(path: 'str', contents: 'str') -> None: ...
    @staticmethod
    @overload
    def AppendAllText(path: 'str', contents: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @staticmethod
    @overload
    def AppendAllText(path: 'str', contents: 'str', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def AppendAllText(path: 'str', contents: 'System.ReadOnlySpan[System.Char]', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def AppendAllLines(path: 'str', contents: 'List[str]') -> None: ...
    @staticmethod
    @overload
    def AppendAllLines(path: 'str', contents: 'List[str]', encoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def Replace(sourceFileName: 'str', destinationFileName: 'str', destinationBackupFileName: 'str') -> None: ...
    @staticmethod
    @overload
    def Replace(sourceFileName: 'str', destinationFileName: 'str', destinationBackupFileName: 'str', ignoreMetadataErrors: 'bool') -> None: ...
    @staticmethod
    @overload
    def Move(sourceFileName: 'str', destFileName: 'str') -> None: ...
    @staticmethod
    @overload
    def Move(sourceFileName: 'str', destFileName: 'str', overwrite: 'bool') -> None: ...
    @staticmethod
    def Encrypt(path: 'str') -> None: ...
    @staticmethod
    def Decrypt(path: 'str') -> None: ...
    @staticmethod
    @overload
    def ReadAllTextAsync(path: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[str]': ...
    @staticmethod
    @overload
    def ReadAllTextAsync(path: 'str', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[str]': ...
    @staticmethod
    @overload
    def WriteAllTextAsync(path: 'str', contents: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WriteAllTextAsync(path: 'str', contents: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WriteAllTextAsync(path: 'str', contents: 'str', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WriteAllTextAsync(path: 'str', contents: 'System.ReadOnlyMemory[System.Char]', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    def ReadAllBytesAsync(path: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[List[int]]': ...
    @staticmethod
    @overload
    def WriteAllBytesAsync(path: 'str', bytes: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WriteAllBytesAsync(path: 'str', bytes: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ReadAllLinesAsync(path: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[List[str]]': ...
    @staticmethod
    @overload
    def ReadAllLinesAsync(path: 'str', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[List[str]]': ...
    @staticmethod
    @overload
    def WriteAllLinesAsync(path: 'str', contents: 'List[str]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WriteAllLinesAsync(path: 'str', contents: 'List[str]', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllTextAsync(path: 'str', contents: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllTextAsync(path: 'str', contents: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllTextAsync(path: 'str', contents: 'str', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllTextAsync(path: 'str', contents: 'System.ReadOnlyMemory[System.Char]', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllLinesAsync(path: 'str', contents: 'List[str]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def AppendAllLinesAsync(path: 'str', contents: 'List[str]', encoding: 'System.Text.Encoding', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    def CreateSymbolicLink(path: 'str', pathToTarget: 'str') -> 'System.IO.FileSystemInfo': ...
    @staticmethod
    def ResolveLinkTarget(linkPath: 'str', returnFinalTarget: 'bool') -> 'System.IO.FileSystemInfo': ...

class FileAccess(enum.Enum):
    Read = ...
    Write = ...
    ReadWrite = ...

class FileAttributes(enum.Enum):
    None = ...
    ReadOnly = ...
    Hidden = ...
    System = ...
    Directory = ...
    Archive = ...
    Device = ...
    Normal = ...
    Temporary = ...
    SparseFile = ...
    ReparsePoint = ...
    Compressed = ...
    Offline = ...
    NotContentIndexed = ...
    Encrypted = ...
    IntegrityStream = ...
    NoScrubData = ...

class FileInfo(System.IO.FileSystemInfo, System.Runtime.Serialization.ISerializable):
    def __init__(self, fileName: 'str') -> None: ...
    Name: 'str' = ...
    Length: 'int' = ...
    DirectoryName: 'str' = ...
    Directory: 'System.IO.DirectoryInfo' = ...
    IsReadOnly: 'bool' = ...
    Exists: 'bool' = ...
    @overload
    def Open(self, options: 'System.IO.FileStreamOptions') -> 'System.IO.FileStream': ...
    @overload
    def Open(self, mode: 'System.IO.FileMode') -> 'System.IO.FileStream': ...
    @overload
    def Open(self, mode: 'System.IO.FileMode', access: 'System.IO.FileAccess') -> 'System.IO.FileStream': ...
    @overload
    def Open(self, mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare') -> 'System.IO.FileStream': ...
    def OpenText(self) -> 'System.IO.StreamReader': ...
    def CreateText(self) -> 'System.IO.StreamWriter': ...
    def AppendText(self) -> 'System.IO.StreamWriter': ...
    @overload
    def CopyTo(self, destFileName: 'str') -> 'System.IO.FileInfo': ...
    @overload
    def CopyTo(self, destFileName: 'str', overwrite: 'bool') -> 'System.IO.FileInfo': ...
    def Create(self) -> 'System.IO.FileStream': ...
    def Delete(self) -> None: ...
    def OpenRead(self) -> 'System.IO.FileStream': ...
    def OpenWrite(self) -> 'System.IO.FileStream': ...
    @overload
    def MoveTo(self, destFileName: 'str') -> None: ...
    @overload
    def MoveTo(self, destFileName: 'str', overwrite: 'bool') -> None: ...
    @overload
    def Replace(self, destinationFileName: 'str', destinationBackupFileName: 'str') -> 'System.IO.FileInfo': ...
    @overload
    def Replace(self, destinationFileName: 'str', destinationBackupFileName: 'str', ignoreMetadataErrors: 'bool') -> 'System.IO.FileInfo': ...
    def Decrypt(self) -> None: ...
    def Encrypt(self) -> None: ...

class FileMode(enum.Enum):
    CreateNew = ...
    Create = ...
    Open = ...
    OpenOrCreate = ...
    Truncate = ...
    Append = ...

class FileOptions(enum.Enum):
    None = ...
    Encrypted = ...
    DeleteOnClose = ...
    SequentialScan = ...
    RandomAccess = ...
    Asynchronous = ...
    WriteThrough = ...

class FileShare(enum.Enum):
    None = ...
    Read = ...
    Write = ...
    ReadWrite = ...
    Delete = ...
    Inheritable = ...

class FileStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, handle: 'System.IntPtr', access: 'System.IO.FileAccess') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr', access: 'System.IO.FileAccess', ownsHandle: 'bool') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr', access: 'System.IO.FileAccess', ownsHandle: 'bool', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr', access: 'System.IO.FileAccess', ownsHandle: 'bool', bufferSize: 'int', isAsync: 'bool') -> None: ...
    @overload
    def __init__(self, handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', access: 'System.IO.FileAccess') -> None: ...
    @overload
    def __init__(self, handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', access: 'System.IO.FileAccess', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', access: 'System.IO.FileAccess', bufferSize: 'int', isAsync: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare', bufferSize: 'int', useAsync: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str', mode: 'System.IO.FileMode', access: 'System.IO.FileAccess', share: 'System.IO.FileShare', bufferSize: 'int', options: 'System.IO.FileOptions') -> None: ...
    @overload
    def __init__(self, path: 'str', options: 'System.IO.FileStreamOptions') -> None: ...
    Handle: 'System.IntPtr' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    SafeFileHandle: 'Microsoft.Win32.SafeHandles.SafeFileHandle' = ...
    Name: 'str' = ...
    IsAsync: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    CanSeek: 'bool' = ...
    def Lock(self, position: 'int', length: 'int') -> None: ...
    def Unlock(self, position: 'int', length: 'int') -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def Flush(self) -> None: ...
    @overload
    def Flush(self, flushToDisk: 'bool') -> None: ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    def WriteByte(self, value: 'int') -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...

class FileStreamOptions:
    def __init__(self) -> None: ...
    Mode: 'System.IO.FileMode' = ...
    Access: 'System.IO.FileAccess' = ...
    Share: 'System.IO.FileShare' = ...
    Options: 'System.IO.FileOptions' = ...
    PreallocationSize: 'int' = ...
    BufferSize: 'int' = ...
    UnixCreateMode: 'Optional[System.IO.UnixFileMode]' = ...

class FileSystemInfo(System.MarshalByRefObject, System.Runtime.Serialization.ISerializable):
    FullName: 'str' = ...
    Extension: 'str' = ...
    Name: 'str' = ...
    Exists: 'bool' = ...
    CreationTime: 'System.DateTime' = ...
    CreationTimeUtc: 'System.DateTime' = ...
    LastAccessTime: 'System.DateTime' = ...
    LastAccessTimeUtc: 'System.DateTime' = ...
    LastWriteTime: 'System.DateTime' = ...
    LastWriteTimeUtc: 'System.DateTime' = ...
    LinkTarget: 'str' = ...
    UnixFileMode: 'System.IO.UnixFileMode' = ...
    Attributes: 'System.IO.FileAttributes' = ...
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...
    def Delete(self) -> None: ...
    def CreateAsSymbolicLink(self, pathToTarget: 'str') -> None: ...
    def ResolveLinkTarget(self, returnFinalTarget: 'bool') -> 'System.IO.FileSystemInfo': ...
    def ToString(self) -> 'str': ...
    def Refresh(self) -> None: ...

class HandleInheritability(enum.Enum):
    None = ...
    Inheritable = ...

class InvalidDataException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class IOException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', hresult: 'int') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class MatchCasing(enum.Enum):
    PlatformDefault = ...
    CaseSensitive = ...
    CaseInsensitive = ...

class MatchType(enum.Enum):
    Simple = ...
    Win32 = ...

class MemoryStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, capacity: 'int') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', writable: 'bool') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', index: 'int', count: 'int') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', index: 'int', count: 'int', writable: 'bool') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', index: 'int', count: 'int', writable: 'bool', publiclyVisible: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    Capacity: 'int' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def GetBuffer(self) -> 'List[int]': ...
    def TryGetBuffer(self) -> Tuple['bool', 'System.ArraySegment_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def ReadByte(self) -> 'int': ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', loc: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ToArray(self) -> 'List[int]': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def WriteByte(self, value: 'int') -> None: ...
    def WriteTo(self, stream: 'System.IO.Stream') -> None: ...

class Path:
    DirectorySeparatorChar: 'System.Char' = ...
    AltDirectorySeparatorChar: 'System.Char' = ...
    VolumeSeparatorChar: 'System.Char' = ...
    PathSeparator: 'System.Char' = ...
    InvalidPathChars: 'List[System.Char]' = ...
    @staticmethod
    def ChangeExtension(path: 'str', extension: 'str') -> 'str': ...
    @staticmethod
    def Exists(path: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def GetDirectoryName(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetDirectoryName(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...
    @staticmethod
    @overload
    def GetExtension(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetExtension(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...
    @staticmethod
    @overload
    def GetFileName(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetFileName(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...
    @staticmethod
    @overload
    def GetFileNameWithoutExtension(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetFileNameWithoutExtension(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...
    @staticmethod
    def GetRandomFileName() -> 'str': ...
    @staticmethod
    @overload
    def IsPathFullyQualified(path: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def IsPathFullyQualified(path: 'System.ReadOnlySpan[System.Char]') -> 'bool': ...
    @staticmethod
    @overload
    def HasExtension(path: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def HasExtension(path: 'System.ReadOnlySpan[System.Char]') -> 'bool': ...
    @staticmethod
    @overload
    def Combine(path1: 'str', path2: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Combine(path1: 'str', path2: 'str', path3: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Combine(path1: 'str', path2: 'str', path3: 'str', path4: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Combine(paths: 'List[str]') -> 'str': ...
    @staticmethod
    @overload
    def Combine(paths: 'System.ReadOnlySpan[str]') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'System.ReadOnlySpan[System.Char]', path2: 'System.ReadOnlySpan[System.Char]') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'System.ReadOnlySpan[System.Char]', path2: 'System.ReadOnlySpan[System.Char]', path3: 'System.ReadOnlySpan[System.Char]') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'System.ReadOnlySpan[System.Char]', path2: 'System.ReadOnlySpan[System.Char]', path3: 'System.ReadOnlySpan[System.Char]', path4: 'System.ReadOnlySpan[System.Char]') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'str', path2: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'str', path2: 'str', path3: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Join(path1: 'str', path2: 'str', path3: 'str', path4: 'str') -> 'str': ...
    @staticmethod
    @overload
    def Join(paths: 'List[str]') -> 'str': ...
    @staticmethod
    @overload
    def Join(paths: 'System.ReadOnlySpan[str]') -> 'str': ...
    @staticmethod
    @overload
    def TryJoin(path1: 'System.ReadOnlySpan[System.Char]', path2: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryJoin(path1: 'System.ReadOnlySpan[System.Char]', path2: 'System.ReadOnlySpan[System.Char]', path3: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def GetRelativePath(relativeTo: 'str', path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def TrimEndingDirectorySeparator(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def TrimEndingDirectorySeparator(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...
    @staticmethod
    @overload
    def EndsInDirectorySeparator(path: 'System.ReadOnlySpan[System.Char]') -> 'bool': ...
    @staticmethod
    @overload
    def EndsInDirectorySeparator(path: 'str') -> 'bool': ...
    @staticmethod
    def GetInvalidFileNameChars() -> 'List[System.Char]': ...
    @staticmethod
    def GetInvalidPathChars() -> 'List[System.Char]': ...
    @staticmethod
    @overload
    def GetFullPath(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetFullPath(path: 'str', basePath: 'str') -> 'str': ...
    @staticmethod
    def GetTempPath() -> 'str': ...
    @staticmethod
    def GetTempFileName() -> 'str': ...
    @staticmethod
    @overload
    def IsPathRooted(path: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def IsPathRooted(path: 'System.ReadOnlySpan[System.Char]') -> 'bool': ...
    @staticmethod
    @overload
    def GetPathRoot(path: 'str') -> 'str': ...
    @staticmethod
    @overload
    def GetPathRoot(path: 'System.ReadOnlySpan[System.Char]') -> 'System.ReadOnlySpan[System.Char]': ...

class PathTooLongException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class RandomAccess:
    @staticmethod
    def GetLength(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> 'int': ...
    @staticmethod
    def SetLength(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', length: 'int') -> None: ...
    @staticmethod
    @overload
    def Read(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffer: 'System.Span[int]', fileOffset: 'int') -> 'int': ...
    @staticmethod
    @overload
    def Read(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffers: 'List[System.Memory[int]]', fileOffset: 'int') -> 'int': ...
    @staticmethod
    @overload
    def ReadAsync(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffer: 'System.Memory[int]', fileOffset: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def ReadAsync(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffers: 'List[System.Memory[int]]', fileOffset: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def Write(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffer: 'System.ReadOnlySpan[int]', fileOffset: 'int') -> None: ...
    @staticmethod
    @overload
    def Write(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffers: 'List[System.ReadOnlyMemory[int]]', fileOffset: 'int') -> None: ...
    @staticmethod
    @overload
    def WriteAsync(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffer: 'System.ReadOnlyMemory[int]', fileOffset: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def WriteAsync(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle', buffers: 'List[System.ReadOnlyMemory[int]]', fileOffset: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    def FlushToDisk(handle: 'Microsoft.Win32.SafeHandles.SafeFileHandle') -> None: ...

class SearchOption(enum.Enum):
    TopDirectoryOnly = ...
    AllDirectories = ...

class SeekOrigin(enum.Enum):
    Begin = ...
    Current = ...
    End = ...

class Stream(System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable):
    Null: 'System.IO.Stream' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    CanTimeout: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    ReadTimeout: 'int' = ...
    WriteTimeout: 'int' = ...
    @overload
    def CopyTo(self, destination: 'System.IO.Stream') -> None: ...
    @overload
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Stream') -> 'System.Threading.Tasks.Task': ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Dispose(self) -> None: ...
    def Close(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    @overload
    def FlushAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReadExactlyAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ReadExactlyAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def ReadAtLeastAsync(self, buffer: 'System.Memory[int]', minimumBytes: 'int', throwOnEndOfStream: 'bool', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    @overload
    def ReadExactly(self, buffer: 'System.Span[int]') -> None: ...
    @overload
    def ReadExactly(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    def ReadAtLeast(self, buffer: 'System.Span[int]', minimumBytes: 'int', throwOnEndOfStream: 'bool') -> 'int': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    @staticmethod
    def Synchronized(stream: 'System.IO.Stream') -> 'System.IO.Stream': ...

class StreamReader(System.IO.TextReader, System.IDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', detectEncodingFromByteOrderMarks: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool', bufferSize: 'int', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str') -> None: ...
    @overload
    def __init__(self, path: 'str', detectEncodingFromByteOrderMarks: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, path: 'str', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, path: 'str', options: 'System.IO.FileStreamOptions') -> None: ...
    @overload
    def __init__(self, path: 'str', encoding: 'System.Text.Encoding', detectEncodingFromByteOrderMarks: 'bool', options: 'System.IO.FileStreamOptions') -> None: ...
    Null: 'System.IO.StreamReader' = ...
    CurrentEncoding: 'System.Text.Encoding' = ...
    BaseStream: 'System.IO.Stream' = ...
    EndOfStream: 'bool' = ...
    def Close(self) -> None: ...
    def DiscardBufferedData(self) -> None: ...
    def Peek(self) -> 'int': ...
    @overload
    def Read(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadToEnd(self) -> 'str': ...
    @overload
    def ReadBlock(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadBlock(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadLine(self) -> 'str': ...
    @overload
    def ReadLineAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadLineAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[str]': ...
    @overload
    def ReadToEndAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadToEndAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class StreamWriter(System.IO.TextWriter, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', encoding: 'System.Text.Encoding', bufferSize: 'int', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str') -> None: ...
    @overload
    def __init__(self, path: 'str', append: 'bool') -> None: ...
    @overload
    def __init__(self, path: 'str', append: 'bool', encoding: 'System.Text.Encoding') -> None: ...
    @overload
    def __init__(self, path: 'str', append: 'bool', encoding: 'System.Text.Encoding', bufferSize: 'int') -> None: ...
    @overload
    def __init__(self, path: 'str', options: 'System.IO.FileStreamOptions') -> None: ...
    @overload
    def __init__(self, path: 'str', encoding: 'System.Text.Encoding', options: 'System.IO.FileStreamOptions') -> None: ...
    Null: 'System.IO.StreamWriter' = ...
    AutoFlush: 'bool' = ...
    BaseStream: 'System.IO.Stream' = ...
    Encoding: 'System.Text.Encoding' = ...
    def Close(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    @overload
    def Write(self, value: 'System.Char') -> None: ...
    @overload
    def Write(self, buffer: 'List[System.Char]') -> None: ...
    @overload
    def Write(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def Write(self, value: 'str') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any', arg1: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any', arg1: 'Any', arg2: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg: 'List[Any]') -> None: ...
    @overload
    def Write(self, format: 'str', arg: 'System.ReadOnlySpan[Any]') -> None: ...
    @overload
    def WriteLine(self, value: 'str') -> None: ...
    @overload
    def WriteLine(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any', arg1: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any', arg1: 'Any', arg2: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg: 'List[Any]') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg: 'System.ReadOnlySpan[Any]') -> None: ...
    @overload
    def WriteAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FlushAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class StringReader(System.IO.TextReader, System.IDisposable):
    def __init__(self, s: 'str') -> None: ...
    def Close(self) -> None: ...
    def Peek(self) -> 'int': ...
    @overload
    def Read(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadBlock(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadToEnd(self) -> 'str': ...
    def ReadLine(self) -> 'str': ...
    @overload
    def ReadLineAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadLineAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[str]': ...
    @overload
    def ReadToEndAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadToEndAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReadAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class StringWriter(System.IO.TextWriter, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, formatProvider: 'System.IFormatProvider') -> None: ...
    @overload
    def __init__(self, sb: 'System.Text.StringBuilder') -> None: ...
    @overload
    def __init__(self, sb: 'System.Text.StringBuilder', formatProvider: 'System.IFormatProvider') -> None: ...
    Encoding: 'System.Text.Encoding' = ...
    def Close(self) -> None: ...
    def GetStringBuilder(self) -> 'System.Text.StringBuilder': ...
    @overload
    def Write(self, value: 'System.Char') -> None: ...
    @overload
    def Write(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def Write(self, value: 'str') -> None: ...
    @overload
    def Write(self, value: 'System.Text.StringBuilder') -> None: ...
    @overload
    def WriteLine(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def WriteLine(self, value: 'System.Text.StringBuilder') -> None: ...
    @overload
    def WriteAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, value: 'System.Text.StringBuilder', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'System.Text.StringBuilder', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def FlushAsync(self) -> 'System.Threading.Tasks.Task': ...
    def ToString(self) -> 'str': ...

class TextReader(System.MarshalByRefObject, System.IDisposable):
    Null: 'System.IO.TextReader' = ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def Peek(self) -> 'int': ...
    @overload
    def Read(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadToEnd(self) -> 'str': ...
    @overload
    def ReadBlock(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'int': ...
    @overload
    def ReadBlock(self, buffer: 'System.Span[System.Char]') -> 'int': ...
    def ReadLine(self) -> 'str': ...
    @overload
    def ReadLineAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadLineAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[str]': ...
    @overload
    def ReadToEndAsync(self) -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadToEndAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[str]': ...
    @overload
    def ReadAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadBlockAsync(self, buffer: 'System.Memory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    def Synchronized(reader: 'System.IO.TextReader') -> 'System.IO.TextReader': ...

class TextWriter(System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable):
    Null: 'System.IO.TextWriter' = ...
    FormatProvider: 'System.IFormatProvider' = ...
    Encoding: 'System.Text.Encoding' = ...
    NewLine: 'str' = ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    @overload
    def Write(self, value: 'System.Char') -> None: ...
    @overload
    def Write(self, buffer: 'List[System.Char]') -> None: ...
    @overload
    def Write(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def Write(self, value: 'bool') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.UInt32') -> None: ...
    @overload
    def Write(self, value: 'int') -> None: ...
    @overload
    def Write(self, value: 'System.UInt64') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, value: 'float') -> None: ...
    @overload
    def Write(self, value: 'System.Decimal') -> None: ...
    @overload
    def Write(self, value: 'str') -> None: ...
    @overload
    def Write(self, value: 'Any') -> None: ...
    @overload
    def Write(self, value: 'System.Text.StringBuilder') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any', arg1: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg0: 'Any', arg1: 'Any', arg2: 'Any') -> None: ...
    @overload
    def Write(self, format: 'str', arg: 'List[Any]') -> None: ...
    @overload
    def Write(self, format: 'str', arg: 'System.ReadOnlySpan[Any]') -> None: ...
    @overload
    def WriteLine(self) -> None: ...
    @overload
    def WriteLine(self, value: 'System.Char') -> None: ...
    @overload
    def WriteLine(self, buffer: 'List[System.Char]') -> None: ...
    @overload
    def WriteLine(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> None: ...
    @overload
    def WriteLine(self, buffer: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def WriteLine(self, value: 'bool') -> None: ...
    @overload
    def WriteLine(self, value: 'int') -> None: ...
    @overload
    def WriteLine(self, value: 'System.UInt32') -> None: ...
    @overload
    def WriteLine(self, value: 'int') -> None: ...
    @overload
    def WriteLine(self, value: 'System.UInt64') -> None: ...
    @overload
    def WriteLine(self, value: 'float') -> None: ...
    @overload
    def WriteLine(self, value: 'float') -> None: ...
    @overload
    def WriteLine(self, value: 'System.Decimal') -> None: ...
    @overload
    def WriteLine(self, value: 'str') -> None: ...
    @overload
    def WriteLine(self, value: 'System.Text.StringBuilder') -> None: ...
    @overload
    def WriteLine(self, value: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any', arg1: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg0: 'Any', arg1: 'Any', arg2: 'Any') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg: 'List[Any]') -> None: ...
    @overload
    def WriteLine(self, format: 'str', arg: 'System.ReadOnlySpan[Any]') -> None: ...
    @overload
    def WriteAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, value: 'System.Text.StringBuilder', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'List[System.Char]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'System.Char') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'str') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, value: 'System.Text.StringBuilder', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'List[System.Char]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'List[System.Char]', index: 'int', count: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self, buffer: 'System.ReadOnlyMemory[System.Char]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteLineAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def FlushAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    def Synchronized(writer: 'System.IO.TextWriter') -> 'System.IO.TextWriter': ...
    @staticmethod
    def CreateBroadcasting(writers: 'List[System.IO.TextWriter]') -> 'System.IO.TextWriter': ...

class UnixFileMode(enum.Enum):
    None = ...
    OtherExecute = ...
    OtherWrite = ...
    OtherRead = ...
    GroupExecute = ...
    GroupWrite = ...
    GroupRead = ...
    UserExecute = ...
    UserWrite = ...
    UserRead = ...
    StickyBit = ...
    SetGroup = ...
    SetUser = ...

class UnmanagedMemoryAccessor(System.IDisposable):
    @overload
    def __init__(self, buffer: 'System.Runtime.InteropServices.SafeBuffer', offset: 'int', capacity: 'int') -> None: ...
    @overload
    def __init__(self, buffer: 'System.Runtime.InteropServices.SafeBuffer', offset: 'int', capacity: 'int', access: 'System.IO.FileAccess') -> None: ...
    Capacity: 'int' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    def Dispose(self) -> None: ...
    def ReadBoolean(self, position: 'int') -> 'bool': ...
    def ReadByte(self, position: 'int') -> 'int': ...
    def ReadChar(self, position: 'int') -> 'System.Char': ...
    def ReadInt16(self, position: 'int') -> 'System.Int16': ...
    def ReadInt32(self, position: 'int') -> 'int': ...
    def ReadInt64(self, position: 'int') -> 'int': ...
    def ReadDecimal(self, position: 'int') -> 'System.Decimal': ...
    def ReadSingle(self, position: 'int') -> 'float': ...
    def ReadDouble(self, position: 'int') -> 'float': ...
    def ReadSByte(self, position: 'int') -> 'System.SByte': ...
    def ReadUInt16(self, position: 'int') -> 'System.UInt16': ...
    def ReadUInt32(self, position: 'int') -> 'System.UInt32': ...
    def ReadUInt64(self, position: 'int') -> 'System.UInt64': ...
    def Read(self, position: 'int') -> 'T': ...
    def ReadArray(self, position: 'int', array: 'List[T]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Write(self, position: 'int', value: 'bool') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'int') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.Char') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.Int16') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'int') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'int') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.Decimal') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'float') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'float') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.SByte') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.UInt16') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.UInt32') -> None: ...
    @overload
    def Write(self, position: 'int', value: 'System.UInt64') -> None: ...
    @overload
    def Write(self, position: 'int') -> 'T': ...
    def WriteArray(self, position: 'int', array: 'List[T]', offset: 'int', count: 'int') -> None: ...

class UnmanagedMemoryStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, buffer: 'System.Runtime.InteropServices.SafeBuffer', offset: 'int', length: 'int') -> None: ...
    @overload
    def __init__(self, buffer: 'System.Runtime.InteropServices.SafeBuffer', offset: 'int', length: 'int', access: 'System.IO.FileAccess') -> None: ...
    @overload
    def __init__(self, pointer: 'System.Byte*', length: 'int') -> None: ...
    @overload
    def __init__(self, pointer: 'System.Byte*', length: 'int', capacity: 'int', access: 'System.IO.FileAccess') -> None: ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    Length: 'int' = ...
    Capacity: 'int' = ...
    Position: 'int' = ...
    PositionPointer: 'System.Byte*' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def ReadByte(self) -> 'int': ...
    def Seek(self, offset: 'int', loc: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def WriteByte(self, value: 'int') -> None: ...

class DriveInfo(System.Runtime.Serialization.ISerializable):
    def __init__(self, driveName: 'str') -> None: ...
    Name: 'str' = ...
    IsReady: 'bool' = ...
    RootDirectory: 'System.IO.DirectoryInfo' = ...
    DriveType: 'System.IO.DriveType' = ...
    DriveFormat: 'str' = ...
    AvailableFreeSpace: 'int' = ...
    TotalFreeSpace: 'int' = ...
    TotalSize: 'int' = ...
    VolumeLabel: 'str' = ...
    def ToString(self) -> 'str': ...
    @staticmethod
    def GetDrives() -> 'List[System.IO.DriveInfo]': ...

class DriveNotFoundException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class DriveType(enum.Enum):
    Unknown = ...
    NoRootDirectory = ...
    Removable = ...
    Fixed = ...
    Network = ...
    CDRom = ...
    Ram = ...

class ErrorEventArgs(System.EventArgs):
    def __init__(self, exception: 'System.Exception') -> None: ...
    def GetException(self) -> 'System.Exception': ...

class ErrorEventHandler(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, sender: 'Any', e: 'System.IO.ErrorEventArgs') -> None: ...
    def BeginInvoke(self, sender: 'Any', e: 'System.IO.ErrorEventArgs', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class FileSystemEventArgs(System.EventArgs):
    def __init__(self, changeType: 'System.IO.WatcherChangeTypes', directory: 'str', name: 'str') -> None: ...
    ChangeType: 'System.IO.WatcherChangeTypes' = ...
    FullPath: 'str' = ...
    Name: 'str' = ...

class FileSystemEventHandler(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, sender: 'Any', e: 'System.IO.FileSystemEventArgs') -> None: ...
    def BeginInvoke(self, sender: 'Any', e: 'System.IO.FileSystemEventArgs', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class FileSystemWatcher(System.ComponentModel.Component, System.ComponentModel.IComponent, System.IDisposable, System.ComponentModel.ISupportInitialize):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: 'str') -> None: ...
    @overload
    def __init__(self, path: 'str', filter: 'str') -> None: ...
    NotifyFilter: 'System.IO.NotifyFilters' = ...
    Filters: 'System.Collections.ObjectModel.Collection[str]' = ...
    EnableRaisingEvents: 'bool' = ...
    Filter: 'str' = ...
    IncludeSubdirectories: 'bool' = ...
    InternalBufferSize: 'int' = ...
    Path: 'str' = ...
    Site: 'System.ComponentModel.ISite' = ...
    SynchronizingObject: 'System.ComponentModel.ISynchronizeInvoke' = ...
    @overload
    def WaitForChanged(self, changeType: 'System.IO.WatcherChangeTypes') -> 'System.IO.WaitForChangedResult': ...
    @overload
    def WaitForChanged(self, changeType: 'System.IO.WatcherChangeTypes', timeout: 'int') -> 'System.IO.WaitForChangedResult': ...
    @overload
    def WaitForChanged(self, changeType: 'System.IO.WatcherChangeTypes', timeout: 'System.TimeSpan') -> 'System.IO.WaitForChangedResult': ...
    def BeginInit(self) -> None: ...
    def EndInit(self) -> None: ...

class InternalBufferOverflowException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...

class NotifyFilters(enum.Enum):
    FileName = ...
    DirectoryName = ...
    Attributes = ...
    Size = ...
    LastWrite = ...
    LastAccess = ...
    CreationTime = ...
    Security = ...

class RenamedEventArgs(System.IO.FileSystemEventArgs):
    def __init__(self, changeType: 'System.IO.WatcherChangeTypes', directory: 'str', name: 'str', oldName: 'str') -> None: ...
    OldFullPath: 'str' = ...
    OldName: 'str' = ...

class RenamedEventHandler(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, sender: 'Any', e: 'System.IO.RenamedEventArgs') -> None: ...
    def BeginInvoke(self, sender: 'Any', e: 'System.IO.RenamedEventArgs', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class WatcherChangeTypes(enum.Enum):
    Created = ...
    Deleted = ...
    Changed = ...
    Renamed = ...
    All = ...

class WaitForChangedResult(System.ValueType):
    ChangeType: 'System.IO.WatcherChangeTypes' = ...
    Name: 'str' = ...
    OldName: 'str' = ...
    TimedOut: 'bool' = ...

class FileSystemAclExtensions:
    @staticmethod
    @overload
    def GetAccessControl(directoryInfo: 'System.IO.DirectoryInfo') -> 'System.Security.AccessControl.DirectorySecurity': ...
    @staticmethod
    @overload
    def GetAccessControl(directoryInfo: 'System.IO.DirectoryInfo', includeSections: 'System.Security.AccessControl.AccessControlSections') -> 'System.Security.AccessControl.DirectorySecurity': ...
    @staticmethod
    @overload
    def GetAccessControl(fileInfo: 'System.IO.FileInfo') -> 'System.Security.AccessControl.FileSecurity': ...
    @staticmethod
    @overload
    def GetAccessControl(fileInfo: 'System.IO.FileInfo', includeSections: 'System.Security.AccessControl.AccessControlSections') -> 'System.Security.AccessControl.FileSecurity': ...
    @staticmethod
    @overload
    def GetAccessControl(fileStream: 'System.IO.FileStream') -> 'System.Security.AccessControl.FileSecurity': ...
    @staticmethod
    @overload
    def SetAccessControl(directoryInfo: 'System.IO.DirectoryInfo', directorySecurity: 'System.Security.AccessControl.DirectorySecurity') -> None: ...
    @staticmethod
    @overload
    def SetAccessControl(fileInfo: 'System.IO.FileInfo', fileSecurity: 'System.Security.AccessControl.FileSecurity') -> None: ...
    @staticmethod
    @overload
    def SetAccessControl(fileStream: 'System.IO.FileStream', fileSecurity: 'System.Security.AccessControl.FileSecurity') -> None: ...
    @staticmethod
    @overload
    def Create(directoryInfo: 'System.IO.DirectoryInfo', directorySecurity: 'System.Security.AccessControl.DirectorySecurity') -> None: ...
    @staticmethod
    @overload
    def Create(fileInfo: 'System.IO.FileInfo', mode: 'System.IO.FileMode', rights: 'System.Security.AccessControl.FileSystemRights', share: 'System.IO.FileShare', bufferSize: 'int', options: 'System.IO.FileOptions', fileSecurity: 'System.Security.AccessControl.FileSecurity') -> 'System.IO.FileStream': ...
    @staticmethod
    def CreateDirectory(directorySecurity: 'System.Security.AccessControl.DirectorySecurity', path: 'str') -> 'System.IO.DirectoryInfo': ...

from . import Strategies as Strategies
from . import Enumeration as Enumeration
from . import MemoryMappedFiles as MemoryMappedFiles
from . import Compression as Compression
from . import Pipelines as Pipelines
from . import Pipes as Pipes
from . import IsolatedStorage as IsolatedStorage
