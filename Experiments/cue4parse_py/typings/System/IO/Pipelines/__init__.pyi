from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class FlushResult(System.ValueType):
    def __init__(self, isCanceled: 'bool', isCompleted: 'bool') -> None: ...
    IsCanceled: 'bool' = ...
    IsCompleted: 'bool' = ...

class IDuplexPipe:
    Input: 'System.IO.Pipelines.PipeReader' = ...
    Output: 'System.IO.Pipelines.PipeWriter' = ...

class Pipe:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, options: 'System.IO.Pipelines.PipeOptions') -> None: ...
    Reader: 'System.IO.Pipelines.PipeReader' = ...
    Writer: 'System.IO.Pipelines.PipeWriter' = ...
    def Reset(self) -> None: ...

class PipeOptions:
    def __init__(self, pool: 'System.Buffers.MemoryPool[int]', readerScheduler: 'System.IO.Pipelines.PipeScheduler', writerScheduler: 'System.IO.Pipelines.PipeScheduler', pauseWriterThreshold: 'int', resumeWriterThreshold: 'int', minimumSegmentSize: 'int', useSynchronizationContext: 'bool') -> None: ...
    Default: 'System.IO.Pipelines.PipeOptions' = ...
    UseSynchronizationContext: 'bool' = ...
    PauseWriterThreshold: 'int' = ...
    ResumeWriterThreshold: 'int' = ...
    MinimumSegmentSize: 'int' = ...
    WriterScheduler: 'System.IO.Pipelines.PipeScheduler' = ...
    ReaderScheduler: 'System.IO.Pipelines.PipeScheduler' = ...
    Pool: 'System.Buffers.MemoryPool[int]' = ...

class PipeReader:
    def TryRead(self) -> Tuple['bool', 'System.IO.Pipelines.ReadResult']: ...
    def ReadAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.IO.Pipelines.ReadResult]': ...
    def ReadAtLeastAsync(self, minimumSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.IO.Pipelines.ReadResult]': ...
    @overload
    def AdvanceTo(self, consumed: 'System.SequencePosition') -> None: ...
    @overload
    def AdvanceTo(self, consumed: 'System.SequencePosition', examined: 'System.SequencePosition') -> None: ...
    def AsStream(self, leaveOpen: 'bool') -> 'System.IO.Stream': ...
    def CancelPendingRead(self) -> None: ...
    def Complete(self, exception: 'System.Exception') -> None: ...
    def CompleteAsync(self, exception: 'System.Exception') -> 'System.Threading.Tasks.ValueTask': ...
    def OnWriterCompleted(self, callback: 'System.Action[System.Exception, Any]', state: 'Any') -> None: ...
    @staticmethod
    @overload
    def Create(stream: 'System.IO.Stream', readerOptions: 'System.IO.Pipelines.StreamPipeReaderOptions') -> 'System.IO.Pipelines.PipeReader': ...
    @staticmethod
    @overload
    def Create(sequence: 'System.Buffers.ReadOnlySequence[int]') -> 'System.IO.Pipelines.PipeReader': ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Pipelines.PipeWriter', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def CopyToAsync(self, destination: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class PipeScheduler:
    ThreadPool: 'System.IO.Pipelines.PipeScheduler' = ...
    Inline: 'System.IO.Pipelines.PipeScheduler' = ...
    def Schedule(self, action: 'System.Action[Any]', state: 'Any') -> None: ...

class PipeWriter(System.Buffers.IBufferWriter[int]):
    CanGetUnflushedBytes: 'bool' = ...
    UnflushedBytes: 'int' = ...
    def Complete(self, exception: 'System.Exception') -> None: ...
    def CompleteAsync(self, exception: 'System.Exception') -> 'System.Threading.Tasks.ValueTask': ...
    def CancelPendingFlush(self) -> None: ...
    def OnReaderCompleted(self, callback: 'System.Action[System.Exception, Any]', state: 'Any') -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.IO.Pipelines.FlushResult]': ...
    def Advance(self, bytes: 'int') -> None: ...
    def GetMemory(self, sizeHint: 'int') -> 'System.Memory[int]': ...
    def GetSpan(self, sizeHint: 'int') -> 'System.Span[int]': ...
    def AsStream(self, leaveOpen: 'bool') -> 'System.IO.Stream': ...
    @staticmethod
    def Create(stream: 'System.IO.Stream', writerOptions: 'System.IO.Pipelines.StreamPipeWriterOptions') -> 'System.IO.Pipelines.PipeWriter': ...
    def WriteAsync(self, source: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.IO.Pipelines.FlushResult]': ...

class ReadResult(System.ValueType):
    def __init__(self, buffer: 'System.Buffers.ReadOnlySequence[int]', isCanceled: 'bool', isCompleted: 'bool') -> None: ...
    Buffer: 'System.Buffers.ReadOnlySequence[int]' = ...
    IsCanceled: 'bool' = ...
    IsCompleted: 'bool' = ...

class StreamPipeExtensions:
    @staticmethod
    def CopyToAsync(source: 'System.IO.Stream', destination: 'System.IO.Pipelines.PipeWriter', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class StreamPipeReaderOptions:
    @overload
    def __init__(self, pool: 'System.Buffers.MemoryPool[int]', bufferSize: 'int', minimumReadSize: 'int', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, pool: 'System.Buffers.MemoryPool[int]', bufferSize: 'int', minimumReadSize: 'int', leaveOpen: 'bool', useZeroByteReads: 'bool') -> None: ...
    BufferSize: 'int' = ...
    MinimumReadSize: 'int' = ...
    Pool: 'System.Buffers.MemoryPool[int]' = ...
    LeaveOpen: 'bool' = ...
    UseZeroByteReads: 'bool' = ...

class StreamPipeWriterOptions:
    def __init__(self, pool: 'System.Buffers.MemoryPool[int]', minimumBufferSize: 'int', leaveOpen: 'bool') -> None: ...
    MinimumBufferSize: 'int' = ...
    Pool: 'System.Buffers.MemoryPool[int]' = ...
    LeaveOpen: 'bool' = ...

