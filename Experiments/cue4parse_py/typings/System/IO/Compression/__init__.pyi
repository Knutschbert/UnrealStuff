from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class ZipArchive(System.IDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode', leaveOpen: 'bool', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    Comment: 'str' = ...
    Entries: 'System.Collections.ObjectModel.ReadOnlyCollection[System.IO.Compression.ZipArchiveEntry]' = ...
    Mode: 'System.IO.Compression.ZipArchiveMode' = ...
    @overload
    def CreateEntry(self, entryName: 'str') -> 'System.IO.Compression.ZipArchiveEntry': ...
    @overload
    def CreateEntry(self, entryName: 'str', compressionLevel: 'System.IO.Compression.CompressionLevel') -> 'System.IO.Compression.ZipArchiveEntry': ...
    def Dispose(self) -> None: ...
    def GetEntry(self, entryName: 'str') -> 'System.IO.Compression.ZipArchiveEntry': ...

class ZipArchiveEntry:
    Archive: 'System.IO.Compression.ZipArchive' = ...
    Crc32: 'System.UInt32' = ...
    IsEncrypted: 'bool' = ...
    CompressedLength: 'int' = ...
    ExternalAttributes: 'int' = ...
    Comment: 'str' = ...
    FullName: 'str' = ...
    LastWriteTime: 'System.DateTimeOffset' = ...
    Length: 'int' = ...
    Name: 'str' = ...
    def Delete(self) -> None: ...
    def Open(self) -> 'System.IO.Stream': ...
    def ToString(self) -> 'str': ...

class ZipArchiveMode(enum.Enum):
    Read = ...
    Create = ...
    Update = ...

class DeflateStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    BaseStream: 'System.IO.Stream' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class ZLibException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self, message: 'str', zlibErrorContext: 'str', zlibErrorCode: 'int', zlibErrorMessage: 'str') -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class CompressionLevel(enum.Enum):
    Optimal = ...
    Fastest = ...
    NoCompression = ...
    SmallestSize = ...

class CompressionMode(enum.Enum):
    Decompress = ...
    Compress = ...

class GZipStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    BaseStream: 'System.IO.Stream' = ...
    def Flush(self) -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class ZLibCompressionOptions:
    def __init__(self) -> None: ...
    CompressionLevel: 'int' = ...
    CompressionStrategy: 'System.IO.Compression.ZLibCompressionStrategy' = ...

class ZLibCompressionStrategy(enum.Enum):
    Default = ...
    Filtered = ...
    HuffmanOnly = ...
    RunLengthEncoding = ...
    Fixed = ...

class ZLibStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    BaseStream: 'System.IO.Stream' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def WriteByte(self, value: 'int') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...

class BrotliCompressionOptions:
    def __init__(self) -> None: ...
    Quality: 'int' = ...

class BrotliStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.BrotliCompressionOptions', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    BaseStream: 'System.IO.Stream' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...

class BrotliDecoder(System.ValueType, System.IDisposable):
    def Dispose(self) -> None: ...
    def Decompress(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['System.Buffers.OperationStatus', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    def TryDecompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class BrotliEncoder(System.ValueType, System.IDisposable):
    def __init__(self, quality: 'int', window: 'int') -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetMaxCompressedLength(inputSize: 'int') -> 'int': ...
    def Flush(self, destination: 'System.Span[int]') -> Tuple['System.Buffers.OperationStatus', 'System.Int32']: ...
    def Compress(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', isFinalBlock: 'bool') -> Tuple['System.Buffers.OperationStatus', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryCompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryCompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', quality: 'int', window: 'int') -> Tuple['bool', 'System.Int32']: ...

class ZipFile:
    @staticmethod
    def OpenRead(archiveFileName: 'str') -> 'System.IO.Compression.ZipArchive': ...
    @staticmethod
    @overload
    def Open(archiveFileName: 'str', mode: 'System.IO.Compression.ZipArchiveMode') -> 'System.IO.Compression.ZipArchive': ...
    @staticmethod
    @overload
    def Open(archiveFileName: 'str', mode: 'System.IO.Compression.ZipArchiveMode', entryNameEncoding: 'System.Text.Encoding') -> 'System.IO.Compression.ZipArchive': ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destinationArchiveFileName: 'str') -> None: ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destinationArchiveFileName: 'str', compressionLevel: 'System.IO.Compression.CompressionLevel', includeBaseDirectory: 'bool') -> None: ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destinationArchiveFileName: 'str', compressionLevel: 'System.IO.Compression.CompressionLevel', includeBaseDirectory: 'bool', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destination: 'System.IO.Stream') -> None: ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destination: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', includeBaseDirectory: 'bool') -> None: ...
    @staticmethod
    @overload
    def CreateFromDirectory(sourceDirectoryName: 'str', destination: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', includeBaseDirectory: 'bool', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(sourceArchiveFileName: 'str', destinationDirectoryName: 'str') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(sourceArchiveFileName: 'str', destinationDirectoryName: 'str', overwriteFiles: 'bool') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(sourceArchiveFileName: 'str', destinationDirectoryName: 'str', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(sourceArchiveFileName: 'str', destinationDirectoryName: 'str', entryNameEncoding: 'System.Text.Encoding', overwriteFiles: 'bool') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Stream', destinationDirectoryName: 'str') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Stream', destinationDirectoryName: 'str', overwriteFiles: 'bool') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Stream', destinationDirectoryName: 'str', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Stream', destinationDirectoryName: 'str', entryNameEncoding: 'System.Text.Encoding', overwriteFiles: 'bool') -> None: ...

class ZipFileExtensions:
    @staticmethod
    @overload
    def CreateEntryFromFile(destination: 'System.IO.Compression.ZipArchive', sourceFileName: 'str', entryName: 'str') -> 'System.IO.Compression.ZipArchiveEntry': ...
    @staticmethod
    @overload
    def CreateEntryFromFile(destination: 'System.IO.Compression.ZipArchive', sourceFileName: 'str', entryName: 'str', compressionLevel: 'System.IO.Compression.CompressionLevel') -> 'System.IO.Compression.ZipArchiveEntry': ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Compression.ZipArchive', destinationDirectoryName: 'str') -> None: ...
    @staticmethod
    @overload
    def ExtractToDirectory(source: 'System.IO.Compression.ZipArchive', destinationDirectoryName: 'str', overwriteFiles: 'bool') -> None: ...
    @staticmethod
    @overload
    def ExtractToFile(source: 'System.IO.Compression.ZipArchiveEntry', destinationFileName: 'str') -> None: ...
    @staticmethod
    @overload
    def ExtractToFile(source: 'System.IO.Compression.ZipArchiveEntry', destinationFileName: 'str', overwrite: 'bool') -> None: ...

class BrotliCompressionOptions:
    def __init__(self) -> None: ...
    Quality: 'int' = ...

class BrotliStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.BrotliCompressionOptions', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    BaseStream: 'System.IO.Stream' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...

class BrotliDecoder(System.ValueType, System.IDisposable):
    def Dispose(self) -> None: ...
    def Decompress(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['System.Buffers.OperationStatus', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    def TryDecompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class BrotliEncoder(System.ValueType, System.IDisposable):
    def __init__(self, quality: 'int', window: 'int') -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetMaxCompressedLength(inputSize: 'int') -> 'int': ...
    def Flush(self, destination: 'System.Span[int]') -> Tuple['System.Buffers.OperationStatus', 'System.Int32']: ...
    def Compress(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', isFinalBlock: 'bool') -> Tuple['System.Buffers.OperationStatus', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryCompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryCompress(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', quality: 'int', window: 'int') -> Tuple['bool', 'System.Int32']: ...

class ZipArchive(System.IDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.ZipArchiveMode', leaveOpen: 'bool', entryNameEncoding: 'System.Text.Encoding') -> None: ...
    Comment: 'str' = ...
    Entries: 'System.Collections.ObjectModel.ReadOnlyCollection[System.IO.Compression.ZipArchiveEntry]' = ...
    Mode: 'System.IO.Compression.ZipArchiveMode' = ...
    @overload
    def CreateEntry(self, entryName: 'str') -> 'System.IO.Compression.ZipArchiveEntry': ...
    @overload
    def CreateEntry(self, entryName: 'str', compressionLevel: 'System.IO.Compression.CompressionLevel') -> 'System.IO.Compression.ZipArchiveEntry': ...
    def Dispose(self) -> None: ...
    def GetEntry(self, entryName: 'str') -> 'System.IO.Compression.ZipArchiveEntry': ...

class ZipArchiveEntry:
    Archive: 'System.IO.Compression.ZipArchive' = ...
    Crc32: 'System.UInt32' = ...
    IsEncrypted: 'bool' = ...
    CompressedLength: 'int' = ...
    ExternalAttributes: 'int' = ...
    Comment: 'str' = ...
    FullName: 'str' = ...
    LastWriteTime: 'System.DateTimeOffset' = ...
    Length: 'int' = ...
    Name: 'str' = ...
    def Delete(self) -> None: ...
    def Open(self) -> 'System.IO.Stream': ...
    def ToString(self) -> 'str': ...

class ZipArchiveMode(enum.Enum):
    Read = ...
    Create = ...
    Update = ...

class DeflateStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    BaseStream: 'System.IO.Stream' = ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class ZLibException(System.IO.IOException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self, message: 'str', zlibErrorContext: 'str', zlibErrorCode: 'int', zlibErrorMessage: 'str') -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class CompressionLevel(enum.Enum):
    Optimal = ...
    Fastest = ...
    NoCompression = ...
    SmallestSize = ...

class CompressionMode(enum.Enum):
    Decompress = ...
    Compress = ...

class GZipStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    BaseStream: 'System.IO.Stream' = ...
    def Flush(self) -> None: ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...

class ZLibCompressionOptions:
    def __init__(self) -> None: ...
    CompressionLevel: 'int' = ...
    CompressionStrategy: 'System.IO.Compression.ZLibCompressionStrategy' = ...

class ZLibCompressionStrategy(enum.Enum):
    Default = ...
    Filtered = ...
    HuffmanOnly = ...
    RunLengthEncoding = ...
    Fixed = ...

class ZLibStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', mode: 'System.IO.Compression.CompressionMode', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionLevel: 'System.IO.Compression.CompressionLevel', leaveOpen: 'bool') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', compressionOptions: 'System.IO.Compression.ZLibCompressionOptions', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanWrite: 'bool' = ...
    CanSeek: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    BaseStream: 'System.IO.Stream' = ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    def ReadByte(self) -> 'int': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', asyncCallback: 'System.AsyncCallback', asyncState: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def WriteByte(self, value: 'int') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...

