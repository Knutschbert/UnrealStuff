from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class IPinnable:
    def Pin(self, elementIndex: 'int') -> 'System.Buffers.MemoryHandle': ...
    def Unpin(self) -> None: ...

class MemoryHandle(System.ValueType, System.IDisposable):
    def __init__(self, pointer: 'System.Void*', handle: 'System.Runtime.InteropServices.GCHandle', pinnable: 'System.Buffers.IPinnable') -> None: ...
    Pointer: 'System.Void*' = ...
    def Dispose(self) -> None: ...

class OperationStatus(enum.Enum):
    Done = ...
    DestinationTooSmall = ...
    NeedMoreData = ...
    InvalidData = ...

class StandardFormat(System.ValueType, System.IEquatable[System.Buffers.StandardFormat]):
    def __init__(self, symbol: 'System.Char', precision: 'int') -> None: ...
    NoPrecision: 'int' = ...
    MaxPrecision: 'int' = ...
    Symbol: 'System.Char' = ...
    Precision: 'int' = ...
    HasPrecision: 'bool' = ...
    IsDefault: 'bool' = ...
    @staticmethod
    @overload
    def Parse(format: 'System.ReadOnlySpan[System.Char]') -> 'System.Buffers.StandardFormat': ...
    @staticmethod
    @overload
    def Parse(format: 'str') -> 'System.Buffers.StandardFormat': ...
    @staticmethod
    def TryParse(format: 'System.ReadOnlySpan[System.Char]') -> Tuple['bool', 'System.Buffers.StandardFormat']: ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Buffers.StandardFormat') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class SearchValues:
    @staticmethod
    @overload
    def Create(values: 'System.ReadOnlySpan[int]') -> 'SearchValues[int]': ...
    @staticmethod
    @overload
    def Create(values: 'System.ReadOnlySpan[System.Char]') -> 'SearchValues[System.Char]': ...
    @staticmethod
    @overload
    def Create(values: 'System.ReadOnlySpan[str]', comparisonType: 'System.StringComparison') -> 'SearchValues[str]': ...

class BuffersExtensions:
    @staticmethod
    def PositionOf(value: 'T') -> Tuple['Optional[System.SequencePosition]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def CopyTo(destination: 'System.Span[T]') -> 'ReadOnlySequence_1': ...
    @staticmethod
    def ToArray() -> Tuple['List[T]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def Write(writer: 'IBufferWriter[T]', value: 'System.ReadOnlySpan[T]') -> None: ...

class SequenceReaderExtensions:
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...

class BuffersExtensions:
    @staticmethod
    def PositionOf(value: 'T') -> Tuple['Optional[System.SequencePosition]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def CopyTo(destination: 'System.Span[T]') -> 'ReadOnlySequence_1': ...
    @staticmethod
    def ToArray() -> Tuple['List[T]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def Write(writer: 'IBufferWriter[T]', value: 'System.ReadOnlySpan[T]') -> None: ...

class SequenceReaderExtensions:
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...

class BuffersExtensions:
    @staticmethod
    def PositionOf(value: 'T') -> Tuple['Optional[System.SequencePosition]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def CopyTo(destination: 'System.Span[T]') -> 'ReadOnlySequence_1': ...
    @staticmethod
    def ToArray() -> Tuple['List[T]', 'ReadOnlySequence_1']: ...
    @staticmethod
    def Write(writer: 'IBufferWriter[T]', value: 'System.ReadOnlySpan[T]') -> None: ...

class SequenceReaderExtensions:
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadLittleEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int16']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int32']: ...
    @staticmethod
    @overload
    def TryReadBigEndian() -> Tuple['bool', 'System.Buffers.SequenceReader_1[[System.Byte, System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]', 'System.Int64']: ...

from . import Text as Text
from . import Binary as Binary
