from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class ConcurrentExclusiveSchedulerPair:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, taskScheduler: 'System.Threading.Tasks.TaskScheduler') -> None: ...
    @overload
    def __init__(self, taskScheduler: 'System.Threading.Tasks.TaskScheduler', maxConcurrencyLevel: 'int') -> None: ...
    @overload
    def __init__(self, taskScheduler: 'System.Threading.Tasks.TaskScheduler', maxConcurrencyLevel: 'int', maxItemsPerTask: 'int') -> None: ...
    Completion: 'System.Threading.Tasks.Task' = ...
    ConcurrentScheduler: 'System.Threading.Tasks.TaskScheduler' = ...
    ExclusiveScheduler: 'System.Threading.Tasks.TaskScheduler' = ...
    def Complete(self) -> None: ...

class ConfigureAwaitOptions(enum.Enum):
    None = ...
    ContinueOnCapturedContext = ...
    SuppressThrowing = ...
    ForceYielding = ...

class TaskStatus(enum.Enum):
    Created = ...
    WaitingForActivation = ...
    WaitingToRun = ...
    Running = ...
    WaitingForChildrenToComplete = ...
    RanToCompletion = ...
    Canceled = ...
    Faulted = ...

class Task(System.IAsyncResult, System.IDisposable):
    @overload
    def __init__(self, action: 'System.Action') -> None: ...
    @overload
    def __init__(self, action: 'System.Action', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def __init__(self, action: 'System.Action', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    @overload
    def __init__(self, action: 'System.Action', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    @overload
    def __init__(self, action: 'System.Action[Any]', state: 'Any') -> None: ...
    @overload
    def __init__(self, action: 'System.Action[Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def __init__(self, action: 'System.Action[Any]', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    @overload
    def __init__(self, action: 'System.Action[Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    Id: 'int' = ...
    CurrentId: 'Optional[int]' = ...
    Exception: 'System.AggregateException' = ...
    Status: 'System.Threading.Tasks.TaskStatus' = ...
    IsCanceled: 'bool' = ...
    IsCompleted: 'bool' = ...
    IsCompletedSuccessfully: 'bool' = ...
    CreationOptions: 'System.Threading.Tasks.TaskCreationOptions' = ...
    AsyncState: 'Any' = ...
    Factory: 'System.Threading.Tasks.TaskFactory' = ...
    CompletedTask: 'System.Threading.Tasks.Task' = ...
    IsFaulted: 'bool' = ...
    @overload
    def Start(self) -> None: ...
    @overload
    def Start(self, scheduler: 'System.Threading.Tasks.TaskScheduler') -> None: ...
    @overload
    def RunSynchronously(self) -> None: ...
    @overload
    def RunSynchronously(self, scheduler: 'System.Threading.Tasks.TaskScheduler') -> None: ...
    def Dispose(self) -> None: ...
    def GetAwaiter(self) -> 'System.Runtime.CompilerServices.TaskAwaiter': ...
    @overload
    def ConfigureAwait(self, continueOnCapturedContext: 'bool') -> 'System.Runtime.CompilerServices.ConfiguredTaskAwaitable': ...
    @overload
    def ConfigureAwait(self, options: 'System.Threading.Tasks.ConfigureAwaitOptions') -> 'System.Runtime.CompilerServices.ConfiguredTaskAwaitable': ...
    @staticmethod
    def Yield() -> 'System.Runtime.CompilerServices.YieldAwaitable': ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def WaitAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan', timeProvider: 'System.TimeProvider') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan', timeProvider: 'System.TimeProvider', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task]', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task, Any]', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task, Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task, Any]', state: 'Any', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task, Any]', state: 'Any', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationAction: 'System.Action[System.Threading.Tasks.Task, Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, Any, TResult]', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, Any, TResult]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, Any, TResult]', state: 'Any', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, Any, TResult]', state: 'Any', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWith(self, continuationFunction: 'System.Func[System.Threading.Tasks.Task, Any, TResult]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]') -> None: ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'System.ReadOnlySpan[System.Threading.Tasks.Task]') -> None: ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]', timeout: 'System.TimeSpan') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]', millisecondsTimeout: 'int') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]', millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(tasks: 'List[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @staticmethod
    @overload
    def WaitAny(tasks: 'List[System.Threading.Tasks.Task]') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(tasks: 'List[System.Threading.Tasks.Task]', timeout: 'System.TimeSpan') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(tasks: 'List[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(tasks: 'List[System.Threading.Tasks.Task]', millisecondsTimeout: 'int') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(tasks: 'List[System.Threading.Tasks.Task]', millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'int': ...
    @staticmethod
    def FromResult(result: 'TResult') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def FromException(exception: 'System.Exception') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def FromException(exception: 'System.Exception') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def FromCanceled(cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def FromCanceled(cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def Run(action: 'System.Action') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Run(action: 'System.Action', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[TResult]') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[Task[TResult]]') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def Run(function: 'System.Func[Task[TResult]]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @staticmethod
    @overload
    def Delay(delay: 'System.TimeSpan') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Delay(delay: 'System.TimeSpan', timeProvider: 'System.TimeProvider') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Delay(delay: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Delay(delay: 'System.TimeSpan', timeProvider: 'System.TimeProvider', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Delay(millisecondsDelay: 'int') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Delay(millisecondsDelay: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'List[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'List[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'System.ReadOnlySpan[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'List[Task[TResult]]') -> 'Task[List[TResult]]': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'List[Task[TResult]]') -> 'Task[List[TResult]]': ...
    @staticmethod
    @overload
    def WhenAll(tasks: 'System.ReadOnlySpan[Task[TResult]]') -> 'Task[List[TResult]]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'List[System.Threading.Tasks.Task]') -> 'Task[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'System.ReadOnlySpan[System.Threading.Tasks.Task]') -> 'Task[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenAny(task1: 'System.Threading.Tasks.Task', task2: 'System.Threading.Tasks.Task') -> 'Task[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'List[System.Threading.Tasks.Task]') -> 'Task[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'List[Task[TResult]]') -> 'Task[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'System.ReadOnlySpan[Task[TResult]]') -> 'Task[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenAny(task1: 'Task[TResult]', task2: 'Task[TResult]') -> 'Task[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenAny(tasks: 'List[Task[TResult]]') -> 'Task[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'List[System.Threading.Tasks.Task]') -> 'System.Collections.Generic.IAsyncEnumerable[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'System.ReadOnlySpan[System.Threading.Tasks.Task]') -> 'System.Collections.Generic.IAsyncEnumerable[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'List[System.Threading.Tasks.Task]') -> 'System.Collections.Generic.IAsyncEnumerable[System.Threading.Tasks.Task]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'List[Task[TResult]]') -> 'System.Collections.Generic.IAsyncEnumerable[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'System.ReadOnlySpan[Task[TResult]]') -> 'System.Collections.Generic.IAsyncEnumerable[Task[TResult]]': ...
    @staticmethod
    @overload
    def WhenEach(tasks: 'List[Task[TResult]]') -> 'System.Collections.Generic.IAsyncEnumerable[Task[TResult]]': ...

class TaskCreationOptions(enum.Enum):
    None = ...
    PreferFairness = ...
    LongRunning = ...
    AttachedToParent = ...
    DenyChildAttach = ...
    HideScheduler = ...
    RunContinuationsAsynchronously = ...

class TaskContinuationOptions(enum.Enum):
    None = ...
    PreferFairness = ...
    LongRunning = ...
    AttachedToParent = ...
    DenyChildAttach = ...
    HideScheduler = ...
    LazyCancellation = ...
    RunContinuationsAsynchronously = ...
    NotOnRanToCompletion = ...
    NotOnFaulted = ...
    OnlyOnCanceled = ...
    NotOnCanceled = ...
    OnlyOnFaulted = ...
    OnlyOnRanToCompletion = ...
    ExecuteSynchronously = ...

class TaskAsyncEnumerableExtensions:
    @staticmethod
    @overload
    def ConfigureAwait(source: 'System.IAsyncDisposable', continueOnCapturedContext: 'bool') -> 'System.Runtime.CompilerServices.ConfiguredAsyncDisposable': ...
    @staticmethod
    @overload
    def ConfigureAwait(source: 'System.Collections.Generic.IAsyncEnumerable[T]', continueOnCapturedContext: 'bool') -> 'System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable[T]': ...
    @staticmethod
    def WithCancellation(source: 'System.Collections.Generic.IAsyncEnumerable[T]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable[T]': ...
    @staticmethod
    def ToBlockingEnumerable(source: 'System.Collections.Generic.IAsyncEnumerable[T]', cancellationToken: 'System.Threading.CancellationToken') -> 'List[T]': ...

class TaskCanceledException(System.OperationCanceledException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception', token: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def __init__(self, task: 'System.Threading.Tasks.Task') -> None: ...
    Task: 'System.Threading.Tasks.Task' = ...

class TaskCompletionSource:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    @overload
    def __init__(self, state: 'Any') -> None: ...
    @overload
    def __init__(self, state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> None: ...
    Task: 'System.Threading.Tasks.Task' = ...
    @overload
    def SetException(self, exception: 'System.Exception') -> None: ...
    @overload
    def SetException(self, exceptions: 'List[System.Exception]') -> None: ...
    @overload
    def TrySetException(self, exception: 'System.Exception') -> 'bool': ...
    @overload
    def TrySetException(self, exceptions: 'List[System.Exception]') -> 'bool': ...
    def SetResult(self) -> None: ...
    def TrySetResult(self) -> 'bool': ...
    @overload
    def SetCanceled(self) -> None: ...
    @overload
    def SetCanceled(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def TrySetCanceled(self) -> 'bool': ...
    @overload
    def TrySetCanceled(self, cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    def SetFromTask(self, completedTask: 'System.Threading.Tasks.Task') -> None: ...
    def TrySetFromTask(self, completedTask: 'System.Threading.Tasks.Task') -> 'bool': ...

class TaskExtensions:
    @staticmethod
    @overload
    def Unwrap(task: 'Task[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Unwrap(task: 'Task[Task[TResult]]') -> 'Task[TResult]': ...

class TaskFactory:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def __init__(self, scheduler: 'System.Threading.Tasks.TaskScheduler') -> None: ...
    @overload
    def __init__(self, creationOptions: 'System.Threading.Tasks.TaskCreationOptions', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> None: ...
    @overload
    def __init__(self, cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> None: ...
    CancellationToken: 'System.Threading.CancellationToken' = ...
    Scheduler: 'System.Threading.Tasks.TaskScheduler' = ...
    CreationOptions: 'System.Threading.Tasks.TaskCreationOptions' = ...
    ContinuationOptions: 'System.Threading.Tasks.TaskContinuationOptions' = ...
    @overload
    def StartNew(self, action: 'System.Action') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action[Any]', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action[Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action[Any]', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, action: 'System.Action[Any]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def StartNew(self, function: 'System.Func[TResult]') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[TResult]', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[TResult]', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[Any, TResult]', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[Any, TResult]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[Any, TResult]', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def StartNew(self, function: 'System.Func[Any, TResult]', state: 'Any', cancellationToken: 'System.Threading.CancellationToken', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Action[System.IAsyncResult]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Action[System.IAsyncResult]', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Action[System.IAsyncResult]', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', arg2: 'TArg2', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', arg2: 'TArg2', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, TArg3, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', arg2: 'TArg2', arg3: 'TArg3', state: 'Any') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, TArg3, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Action[System.IAsyncResult]', arg1: 'TArg1', arg2: 'TArg2', arg3: 'TArg3', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Func[System.IAsyncResult, TResult]') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Func[System.IAsyncResult, TResult]', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, asyncResult: 'System.IAsyncResult', endMethod: 'System.Func[System.IAsyncResult, TResult]', creationOptions: 'System.Threading.Tasks.TaskCreationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', arg2: 'TArg2', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', arg2: 'TArg2', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, TArg3, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', arg2: 'TArg2', arg3: 'TArg3', state: 'Any') -> 'Task[TResult]': ...
    @overload
    def FromAsync(self, beginMethod: 'System.Func[TArg1, TArg2, TArg3, System.AsyncCallback, Any, System.IAsyncResult]', endMethod: 'System.Func[System.IAsyncResult, TResult]', arg1: 'TArg1', arg2: 'TArg2', arg3: 'TArg3', state: 'Any', creationOptions: 'System.Threading.Tasks.TaskCreationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[List[System.Threading.Tasks.Task]]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[List[System.Threading.Tasks.Task]]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[List[System.Threading.Tasks.Task]]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[List[System.Threading.Tasks.Task]]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[List[Task[TAntecedentResult]]]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[List[Task[TAntecedentResult]]]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[List[Task[TAntecedentResult]]]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[List[Task[TAntecedentResult]]]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[List[System.Threading.Tasks.Task], TResult]') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[List[System.Threading.Tasks.Task], TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[List[System.Threading.Tasks.Task], TResult]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[List[System.Threading.Tasks.Task], TResult]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[List[Task[TAntecedentResult]], TResult]') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[List[Task[TAntecedentResult]], TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[List[Task[TAntecedentResult]], TResult]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAll(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[List[Task[TAntecedentResult]], TResult]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[System.Threading.Tasks.Task]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[System.Threading.Tasks.Task]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationAction: 'System.Action[System.Threading.Tasks.Task]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[System.Threading.Tasks.Task]', continuationFunction: 'System.Func[System.Threading.Tasks.Task, TResult]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[Task[TAntecedentResult], TResult]') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[Task[TAntecedentResult], TResult]', cancellationToken: 'System.Threading.CancellationToken') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[Task[TAntecedentResult], TResult]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationFunction: 'System.Func[Task[TAntecedentResult], TResult]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'Task[TResult]': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[Task[TAntecedentResult]]') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[Task[TAntecedentResult]]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[Task[TAntecedentResult]]', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ContinueWhenAny(self, tasks: 'List[Task[TAntecedentResult]]', continuationAction: 'System.Action[Task[TAntecedentResult]]', cancellationToken: 'System.Threading.CancellationToken', continuationOptions: 'System.Threading.Tasks.TaskContinuationOptions', scheduler: 'System.Threading.Tasks.TaskScheduler') -> 'System.Threading.Tasks.Task': ...

class TaskScheduler:
    MaximumConcurrencyLevel: 'int' = ...
    Default: 'System.Threading.Tasks.TaskScheduler' = ...
    Current: 'System.Threading.Tasks.TaskScheduler' = ...
    Id: 'int' = ...
    @staticmethod
    def FromCurrentSynchronizationContext() -> 'System.Threading.Tasks.TaskScheduler': ...

class UnobservedTaskExceptionEventArgs(System.EventArgs):
    def __init__(self, exception: 'System.AggregateException') -> None: ...
    Observed: 'bool' = ...
    Exception: 'System.AggregateException' = ...
    def SetObserved(self) -> None: ...

class TaskSchedulerException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class ValueTask(System.ValueType, System.IEquatable[System.Threading.Tasks.ValueTask]):
    @overload
    def __init__(self, task: 'System.Threading.Tasks.Task') -> None: ...
    @overload
    def __init__(self, source: 'System.Threading.Tasks.Sources.IValueTaskSource', token: 'System.Int16') -> None: ...
    CompletedTask: 'System.Threading.Tasks.ValueTask' = ...
    IsCompleted: 'bool' = ...
    IsCompletedSuccessfully: 'bool' = ...
    IsFaulted: 'bool' = ...
    IsCanceled: 'bool' = ...
    @staticmethod
    def FromResult(result: 'TResult') -> 'ValueTask[TResult]': ...
    @staticmethod
    @overload
    def FromCanceled(cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def FromCanceled(cancellationToken: 'System.Threading.CancellationToken') -> 'ValueTask[TResult]': ...
    @staticmethod
    @overload
    def FromException(exception: 'System.Exception') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def FromException(exception: 'System.Exception') -> 'ValueTask[TResult]': ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Threading.Tasks.ValueTask') -> 'bool': ...
    def AsTask(self) -> 'System.Threading.Tasks.Task': ...
    def Preserve(self) -> 'System.Threading.Tasks.ValueTask': ...
    def GetAwaiter(self) -> 'System.Runtime.CompilerServices.ValueTaskAwaiter': ...
    def ConfigureAwait(self, continueOnCapturedContext: 'bool') -> 'System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable': ...

class TaskToAsyncResult:
    @staticmethod
    def Begin(task: 'System.Threading.Tasks.Task', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @staticmethod
    @overload
    def End(asyncResult: 'System.IAsyncResult') -> None: ...
    @staticmethod
    @overload
    def End(asyncResult: 'System.IAsyncResult') -> 'TResult': ...
    @staticmethod
    @overload
    def Unwrap(asyncResult: 'System.IAsyncResult') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def Unwrap(asyncResult: 'System.IAsyncResult') -> 'Task[TResult]': ...

class ParallelOptions:
    def __init__(self) -> None: ...
    TaskScheduler: 'System.Threading.Tasks.TaskScheduler' = ...
    MaxDegreeOfParallelism: 'int' = ...
    CancellationToken: 'System.Threading.CancellationToken' = ...

class Parallel:
    @staticmethod
    @overload
    def Invoke(actions: 'List[System.Action]') -> None: ...
    @staticmethod
    @overload
    def Invoke(parallelOptions: 'System.Threading.Tasks.ParallelOptions', actions: 'List[System.Action]') -> None: ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...

class ParallelLoopState:
    ShouldExitCurrentIteration: 'bool' = ...
    IsStopped: 'bool' = ...
    IsExceptional: 'bool' = ...
    LowestBreakIteration: 'Optional[int]' = ...
    def Stop(self) -> None: ...
    def Break(self) -> None: ...

class ParallelLoopResult(System.ValueType):
    IsCompleted: 'bool' = ...
    LowestBreakIteration: 'Optional[int]' = ...

class ParallelOptions:
    def __init__(self) -> None: ...
    TaskScheduler: 'System.Threading.Tasks.TaskScheduler' = ...
    MaxDegreeOfParallelism: 'int' = ...
    CancellationToken: 'System.Threading.CancellationToken' = ...

class Parallel:
    @staticmethod
    @overload
    def Invoke(actions: 'List[System.Action]') -> None: ...
    @staticmethod
    @overload
    def Invoke(parallelOptions: 'System.Threading.Tasks.ParallelOptions', actions: 'List[System.Action]') -> None: ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[int, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def For(fromInclusive: 'int', toExclusive: 'int', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Action[TSource, System.Threading.Tasks.ParallelLoopState, int]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.Partitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForEach(source: 'System.Collections.Concurrent.OrderablePartitioner[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', localInit: 'System.Func[TLocal]', body: 'System.Func[TSource, System.Threading.Tasks.ParallelLoopState, int, TLocal, TLocal]', localFinally: 'System.Action[TLocal]') -> 'System.Threading.Tasks.ParallelLoopResult': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForAsync(fromInclusive: 'T', toExclusive: 'T', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'List[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', cancellationToken: 'System.Threading.CancellationToken', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ForEachAsync(source: 'System.Collections.Generic.IAsyncEnumerable[TSource]', parallelOptions: 'System.Threading.Tasks.ParallelOptions', body: 'System.Func[TSource, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask]') -> 'System.Threading.Tasks.Task': ...

class ParallelLoopState:
    ShouldExitCurrentIteration: 'bool' = ...
    IsStopped: 'bool' = ...
    IsExceptional: 'bool' = ...
    LowestBreakIteration: 'Optional[int]' = ...
    def Stop(self) -> None: ...
    def Break(self) -> None: ...

class ParallelLoopResult(System.ValueType):
    IsCompleted: 'bool' = ...
    LowestBreakIteration: 'Optional[int]' = ...

from . import Sources as Sources
