from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class Interlocked:
    @staticmethod
    @overload
    def Increment() -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Increment() -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Increment() -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Increment() -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Decrement() -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Decrement() -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Decrement() -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Decrement() -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Exchange(value: 'int') -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Exchange(value: 'int') -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Exchange(value: 'Any') -> Tuple['Any', 'System.Object']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.SByte') -> Tuple['System.SByte', 'System.SByte']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.Int16') -> Tuple['System.Int16', 'System.Int16']: ...
    @staticmethod
    @overload
    def Exchange(value: 'int') -> Tuple['int', 'System.Byte']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.UInt16') -> Tuple['System.UInt16', 'System.UInt16']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.UInt64') -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Exchange(value: 'float') -> Tuple['float', 'System.Single']: ...
    @staticmethod
    @overload
    def Exchange(value: 'float') -> Tuple['float', 'System.Double']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.IntPtr') -> Tuple['System.IntPtr', 'System.IntPtr']: ...
    @staticmethod
    @overload
    def Exchange(value: 'System.UIntPtr') -> Tuple['System.UIntPtr', 'System.UIntPtr']: ...
    @staticmethod
    @overload
    def Exchange(value: 'T') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'int', comparand: 'int') -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'int', comparand: 'int') -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'Any', comparand: 'Any') -> Tuple['Any', 'System.Object']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.SByte', comparand: 'System.SByte') -> Tuple['System.SByte', 'System.SByte']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.Int16', comparand: 'System.Int16') -> Tuple['System.Int16', 'System.Int16']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'int', comparand: 'int') -> Tuple['int', 'System.Byte']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.UInt16', comparand: 'System.UInt16') -> Tuple['System.UInt16', 'System.UInt16']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.UInt32', comparand: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.UInt64', comparand: 'System.UInt64') -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'float', comparand: 'float') -> Tuple['float', 'System.Single']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'float', comparand: 'float') -> Tuple['float', 'System.Double']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.IntPtr', comparand: 'System.IntPtr') -> Tuple['System.IntPtr', 'System.IntPtr']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'System.UIntPtr', comparand: 'System.UIntPtr') -> Tuple['System.UIntPtr', 'System.UIntPtr']: ...
    @staticmethod
    @overload
    def CompareExchange(value: 'T', comparand: 'T') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Add(value: 'int') -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Add(value: 'int') -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Add(value: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Add(value: 'System.UInt64') -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    def MemoryBarrierProcessWide() -> None: ...
    @staticmethod
    @overload
    def And(value: 'int') -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def And(value: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def And(value: 'int') -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def And(value: 'System.UInt64') -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Or(value: 'int') -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Or(value: 'System.UInt32') -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Or(value: 'int') -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Or(value: 'System.UInt64') -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    def MemoryBarrier() -> None: ...

class Monitor:
    LockContentionCount: 'int' = ...
    @staticmethod
    @overload
    def Enter(obj: 'Any') -> None: ...
    @staticmethod
    @overload
    def Enter(obj: 'Any') -> 'System.Boolean': ...
    @staticmethod
    def Exit(obj: 'Any') -> None: ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any') -> 'bool': ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any') -> 'System.Boolean': ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any', millisecondsTimeout: 'int') -> 'bool': ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any', millisecondsTimeout: 'int') -> 'System.Boolean': ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any', timeout: 'System.TimeSpan') -> 'bool': ...
    @staticmethod
    @overload
    def TryEnter(obj: 'Any', timeout: 'System.TimeSpan') -> 'System.Boolean': ...
    @staticmethod
    def IsEntered(obj: 'Any') -> 'bool': ...
    @staticmethod
    @overload
    def Wait(obj: 'Any', millisecondsTimeout: 'int') -> 'bool': ...
    @staticmethod
    @overload
    def Wait(obj: 'Any', timeout: 'System.TimeSpan') -> 'bool': ...
    @staticmethod
    @overload
    def Wait(obj: 'Any') -> 'bool': ...
    @staticmethod
    @overload
    def Wait(obj: 'Any', millisecondsTimeout: 'int', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def Wait(obj: 'Any', timeout: 'System.TimeSpan', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    def Pulse(obj: 'Any') -> None: ...
    @staticmethod
    def PulseAll(obj: 'Any') -> None: ...

class SynchronizationContext:
    def __init__(self) -> None: ...
    Current: 'System.Threading.SynchronizationContext' = ...
    def IsWaitNotificationRequired(self) -> 'bool': ...
    def Send(self, d: 'System.Threading.SendOrPostCallback', state: 'Any') -> None: ...
    def Post(self, d: 'System.Threading.SendOrPostCallback', state: 'Any') -> None: ...
    def OperationStarted(self) -> None: ...
    def OperationCompleted(self) -> None: ...
    def Wait(self, waitHandles: 'List[System.IntPtr]', waitAll: 'bool', millisecondsTimeout: 'int') -> 'int': ...
    @staticmethod
    def SetSynchronizationContext(syncContext: 'System.Threading.SynchronizationContext') -> None: ...
    def CreateCopy(self) -> 'System.Threading.SynchronizationContext': ...

class Thread(System.Runtime.ConstrainedExecution.CriticalFinalizerObject):
    @overload
    def __init__(self, start: 'System.Threading.ThreadStart') -> None: ...
    @overload
    def __init__(self, start: 'System.Threading.ThreadStart', maxStackSize: 'int') -> None: ...
    @overload
    def __init__(self, start: 'System.Threading.ParameterizedThreadStart') -> None: ...
    @overload
    def __init__(self, start: 'System.Threading.ParameterizedThreadStart', maxStackSize: 'int') -> None: ...
    ManagedThreadId: 'int' = ...
    IsAlive: 'bool' = ...
    IsBackground: 'bool' = ...
    IsThreadPoolThread: 'bool' = ...
    Priority: 'System.Threading.ThreadPriority' = ...
    ThreadState: 'System.Threading.ThreadState' = ...
    CurrentCulture: 'System.Globalization.CultureInfo' = ...
    CurrentUICulture: 'System.Globalization.CultureInfo' = ...
    CurrentPrincipal: 'System.Security.Principal.IPrincipal' = ...
    CurrentThread: 'System.Threading.Thread' = ...
    ExecutionContext: 'System.Threading.ExecutionContext' = ...
    Name: 'str' = ...
    ApartmentState: 'System.Threading.ApartmentState' = ...
    @staticmethod
    def SpinWait(iterations: 'int') -> None: ...
    @staticmethod
    def Yield() -> 'bool': ...
    def GetApartmentState(self) -> 'System.Threading.ApartmentState': ...
    def DisableComObjectEagerCleanup(self) -> None: ...
    def Interrupt(self) -> None: ...
    @overload
    def Join(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Join(self) -> None: ...
    @overload
    def Join(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Start(self, parameter: 'Any') -> None: ...
    @overload
    def Start(self) -> None: ...
    @overload
    def UnsafeStart(self, parameter: 'Any') -> None: ...
    @overload
    def UnsafeStart(self) -> None: ...
    @staticmethod
    @overload
    def Sleep(millisecondsTimeout: 'int') -> None: ...
    @staticmethod
    @overload
    def Sleep(timeout: 'System.TimeSpan') -> None: ...
    @overload
    def Abort(self) -> None: ...
    @overload
    def Abort(self, stateInfo: 'Any') -> None: ...
    @staticmethod
    def ResetAbort() -> None: ...
    def Suspend(self) -> None: ...
    def Resume(self) -> None: ...
    @staticmethod
    def BeginCriticalRegion() -> None: ...
    @staticmethod
    def EndCriticalRegion() -> None: ...
    @staticmethod
    def BeginThreadAffinity() -> None: ...
    @staticmethod
    def EndThreadAffinity() -> None: ...
    @staticmethod
    def AllocateDataSlot() -> 'System.LocalDataStoreSlot': ...
    @staticmethod
    def AllocateNamedDataSlot(name: 'str') -> 'System.LocalDataStoreSlot': ...
    @staticmethod
    def GetNamedDataSlot(name: 'str') -> 'System.LocalDataStoreSlot': ...
    @staticmethod
    def FreeNamedDataSlot(name: 'str') -> None: ...
    @staticmethod
    def GetData(slot: 'System.LocalDataStoreSlot') -> 'Any': ...
    @staticmethod
    def SetData(slot: 'System.LocalDataStoreSlot', data: 'Any') -> None: ...
    def SetApartmentState(self, state: 'System.Threading.ApartmentState') -> None: ...
    def TrySetApartmentState(self, state: 'System.Threading.ApartmentState') -> 'bool': ...
    def GetCompressedStack(self) -> 'System.Threading.CompressedStack': ...
    def SetCompressedStack(self, stack: 'System.Threading.CompressedStack') -> None: ...
    @staticmethod
    def GetDomain() -> 'System.AppDomain': ...
    @staticmethod
    def GetDomainID() -> 'int': ...
    def GetHashCode(self) -> 'int': ...
    @staticmethod
    def MemoryBarrier() -> None: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['int', 'System.Byte']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['float', 'System.Double']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.Int16', 'System.Int16']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.IntPtr', 'System.IntPtr']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['Any', 'System.Object']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.SByte', 'System.SByte']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['float', 'System.Single']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.UInt16', 'System.UInt16']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def VolatileRead() -> Tuple['System.UIntPtr', 'System.UIntPtr']: ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'int') -> 'System.Byte': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'float') -> 'System.Double': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.Int16') -> 'System.Int16': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'int') -> 'System.Int32': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'int') -> 'System.Int64': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.IntPtr') -> 'System.IntPtr': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'Any') -> 'System.Object': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.SByte') -> 'System.SByte': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'float') -> 'System.Single': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.UInt16') -> 'System.UInt16': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.UInt32') -> 'System.UInt32': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.UInt64') -> 'System.UInt64': ...
    @staticmethod
    @overload
    def VolatileWrite(value: 'System.UIntPtr') -> 'System.UIntPtr': ...
    @staticmethod
    def GetCurrentProcessorId() -> 'int': ...

class ThreadPool:
    PendingWorkItemCount: 'int' = ...
    ThreadCount: 'int' = ...
    CompletedWorkItemCount: 'int' = ...
    @staticmethod
    @overload
    def RegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'System.UInt32', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def RegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'int', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def RegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'int', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def RegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', timeout: 'System.TimeSpan', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def UnsafeRegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'System.UInt32', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def UnsafeRegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'int', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def UnsafeRegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', millisecondsTimeOutInterval: 'int', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def UnsafeRegisterWaitForSingleObject(waitObject: 'System.Threading.WaitHandle', callBack: 'System.Threading.WaitOrTimerCallback', state: 'Any', timeout: 'System.TimeSpan', executeOnlyOnce: 'bool') -> 'System.Threading.RegisteredWaitHandle': ...
    @staticmethod
    @overload
    def QueueUserWorkItem(callBack: 'System.Threading.WaitCallback') -> 'bool': ...
    @staticmethod
    @overload
    def QueueUserWorkItem(callBack: 'System.Threading.WaitCallback', state: 'Any') -> 'bool': ...
    @staticmethod
    @overload
    def QueueUserWorkItem(callBack: 'System.Action[TState]', state: 'TState', preferLocal: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def UnsafeQueueUserWorkItem(callBack: 'System.Action[TState]', state: 'TState', preferLocal: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def UnsafeQueueUserWorkItem(callBack: 'System.Threading.WaitCallback', state: 'Any') -> 'bool': ...
    @staticmethod
    @overload
    def UnsafeQueueUserWorkItem(callBack: 'System.Threading.IThreadPoolWorkItem', preferLocal: 'bool') -> 'bool': ...
    @staticmethod
    def UnsafeQueueNativeOverlapped(overlapped: 'System.Threading.NativeOverlapped*') -> 'bool': ...
    @staticmethod
    @overload
    def BindHandle(osHandle: 'System.IntPtr') -> 'bool': ...
    @staticmethod
    @overload
    def BindHandle(osHandle: 'System.Runtime.InteropServices.SafeHandle') -> 'bool': ...
    @staticmethod
    def SetMaxThreads(workerThreads: 'int', completionPortThreads: 'int') -> 'bool': ...
    @staticmethod
    def GetMaxThreads() -> Tuple['System.Int32', 'System.Int32']: ...
    @staticmethod
    def SetMinThreads(workerThreads: 'int', completionPortThreads: 'int') -> 'bool': ...
    @staticmethod
    def GetMinThreads() -> Tuple['System.Int32', 'System.Int32']: ...
    @staticmethod
    def GetAvailableThreads() -> Tuple['System.Int32', 'System.Int32']: ...

class WaitHandle(System.MarshalByRefObject, System.IDisposable):
    WaitTimeout: 'int' = ...
    Handle: 'System.IntPtr' = ...
    SafeWaitHandle: 'Microsoft.Win32.SafeHandles.SafeWaitHandle' = ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def WaitOne(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def WaitOne(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def WaitOne(self) -> 'bool': ...
    @overload
    def WaitOne(self, millisecondsTimeout: 'int', exitContext: 'bool') -> 'bool': ...
    @overload
    def WaitOne(self, timeout: 'System.TimeSpan', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(waitHandles: 'List[System.Threading.WaitHandle]', millisecondsTimeout: 'int') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(waitHandles: 'List[System.Threading.WaitHandle]', timeout: 'System.TimeSpan') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(waitHandles: 'List[System.Threading.WaitHandle]') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(waitHandles: 'List[System.Threading.WaitHandle]', millisecondsTimeout: 'int', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAll(waitHandles: 'List[System.Threading.WaitHandle]', timeout: 'System.TimeSpan', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def WaitAny(waitHandles: 'List[System.Threading.WaitHandle]', millisecondsTimeout: 'int') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(waitHandles: 'List[System.Threading.WaitHandle]', timeout: 'System.TimeSpan') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(waitHandles: 'List[System.Threading.WaitHandle]') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(waitHandles: 'List[System.Threading.WaitHandle]', millisecondsTimeout: 'int', exitContext: 'bool') -> 'int': ...
    @staticmethod
    @overload
    def WaitAny(waitHandles: 'List[System.Threading.WaitHandle]', timeout: 'System.TimeSpan', exitContext: 'bool') -> 'int': ...
    @staticmethod
    @overload
    def SignalAndWait(toSignal: 'System.Threading.WaitHandle', toWaitOn: 'System.Threading.WaitHandle') -> 'bool': ...
    @staticmethod
    @overload
    def SignalAndWait(toSignal: 'System.Threading.WaitHandle', toWaitOn: 'System.Threading.WaitHandle', timeout: 'System.TimeSpan', exitContext: 'bool') -> 'bool': ...
    @staticmethod
    @overload
    def SignalAndWait(toSignal: 'System.Threading.WaitHandle', toWaitOn: 'System.Threading.WaitHandle', millisecondsTimeout: 'int', exitContext: 'bool') -> 'bool': ...

class AbandonedMutexException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...
    @overload
    def __init__(self, location: 'int', handle: 'System.Threading.WaitHandle') -> None: ...
    @overload
    def __init__(self, message: 'str', location: 'int', handle: 'System.Threading.WaitHandle') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception', location: 'int', handle: 'System.Threading.WaitHandle') -> None: ...
    Mutex: 'System.Threading.Mutex' = ...
    MutexIndex: 'int' = ...

class ApartmentState(enum.Enum):
    STA = ...
    MTA = ...
    Unknown = ...

class AutoResetEvent(System.Threading.EventWaitHandle, System.IDisposable):
    def __init__(self, initialState: 'bool') -> None: ...

class CancellationToken(System.ValueType, System.IEquatable[System.Threading.CancellationToken]):
    def __init__(self, canceled: 'bool') -> None: ...
    None: 'System.Threading.CancellationToken' = ...
    IsCancellationRequested: 'bool' = ...
    CanBeCanceled: 'bool' = ...
    WaitHandle: 'System.Threading.WaitHandle' = ...
    @overload
    def Register(self, callback: 'System.Action') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def Register(self, callback: 'System.Action', useSynchronizationContext: 'bool') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def Register(self, callback: 'System.Action[Any]', state: 'Any') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def Register(self, callback: 'System.Action[Any, System.Threading.CancellationToken]', state: 'Any') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def Register(self, callback: 'System.Action[Any]', state: 'Any', useSynchronizationContext: 'bool') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def UnsafeRegister(self, callback: 'System.Action[Any]', state: 'Any') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def UnsafeRegister(self, callback: 'System.Action[Any, System.Threading.CancellationToken]', state: 'Any') -> 'System.Threading.CancellationTokenRegistration': ...
    @overload
    def Equals(self, other: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Equals(self, other: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ThrowIfCancellationRequested(self) -> None: ...

class CancellationTokenRegistration(System.ValueType, System.IEquatable[System.Threading.CancellationTokenRegistration], System.IDisposable, System.IAsyncDisposable):
    Token: 'System.Threading.CancellationToken' = ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...
    def Unregister(self) -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Threading.CancellationTokenRegistration') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class CancellationTokenSource(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, delay: 'System.TimeSpan') -> None: ...
    @overload
    def __init__(self, delay: 'System.TimeSpan', timeProvider: 'System.TimeProvider') -> None: ...
    @overload
    def __init__(self, millisecondsDelay: 'int') -> None: ...
    IsCancellationRequested: 'bool' = ...
    Token: 'System.Threading.CancellationToken' = ...
    @overload
    def Cancel(self) -> None: ...
    @overload
    def Cancel(self, throwOnFirstException: 'bool') -> None: ...
    def CancelAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def CancelAfter(self, delay: 'System.TimeSpan') -> None: ...
    @overload
    def CancelAfter(self, millisecondsDelay: 'int') -> None: ...
    def TryReset(self) -> 'bool': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def CreateLinkedTokenSource(token1: 'System.Threading.CancellationToken', token2: 'System.Threading.CancellationToken') -> 'System.Threading.CancellationTokenSource': ...
    @staticmethod
    @overload
    def CreateLinkedTokenSource(token: 'System.Threading.CancellationToken') -> 'System.Threading.CancellationTokenSource': ...
    @staticmethod
    @overload
    def CreateLinkedTokenSource(tokens: 'List[System.Threading.CancellationToken]') -> 'System.Threading.CancellationTokenSource': ...
    @staticmethod
    @overload
    def CreateLinkedTokenSource(tokens: 'System.ReadOnlySpan[System.Threading.CancellationToken]') -> 'System.Threading.CancellationTokenSource': ...

class CompressedStack(System.Runtime.Serialization.ISerializable):
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...
    @staticmethod
    def Capture() -> 'System.Threading.CompressedStack': ...
    def CreateCopy(self) -> 'System.Threading.CompressedStack': ...
    @staticmethod
    def GetCompressedStack() -> 'System.Threading.CompressedStack': ...
    @staticmethod
    def Run(compressedStack: 'System.Threading.CompressedStack', callback: 'System.Threading.ContextCallback', state: 'Any') -> None: ...

class EventResetMode(enum.Enum):
    AutoReset = ...
    ManualReset = ...

class EventWaitHandle(System.Threading.WaitHandle, System.IDisposable):
    @overload
    def __init__(self, initialState: 'bool', mode: 'System.Threading.EventResetMode') -> None: ...
    @overload
    def __init__(self, initialState: 'bool', mode: 'System.Threading.EventResetMode', name: 'str') -> None: ...
    @overload
    def __init__(self, initialState: 'bool', mode: 'System.Threading.EventResetMode', name: 'str', createdNew: 'System.Boolean') -> None: ...
    @staticmethod
    def OpenExisting(name: 'str') -> 'System.Threading.EventWaitHandle': ...
    @staticmethod
    def TryOpenExisting(name: 'str') -> Tuple['bool', 'System.Threading.EventWaitHandle']: ...
    def Reset(self) -> 'bool': ...
    def Set(self) -> 'bool': ...

class ContextCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, state: 'Any') -> None: ...
    def BeginInvoke(self, state: 'Any', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class ExecutionContext(System.IDisposable, System.Runtime.Serialization.ISerializable):
    def GetObjectData(self, info: 'System.Runtime.Serialization.SerializationInfo', context: 'System.Runtime.Serialization.StreamingContext') -> None: ...
    @staticmethod
    def Capture() -> 'System.Threading.ExecutionContext': ...
    @staticmethod
    def SuppressFlow() -> 'System.Threading.AsyncFlowControl': ...
    @staticmethod
    def RestoreFlow() -> None: ...
    @staticmethod
    def IsFlowSuppressed() -> 'bool': ...
    @staticmethod
    def Run(executionContext: 'System.Threading.ExecutionContext', callback: 'System.Threading.ContextCallback', state: 'Any') -> None: ...
    @staticmethod
    def Restore(executionContext: 'System.Threading.ExecutionContext') -> None: ...
    def CreateCopy(self) -> 'System.Threading.ExecutionContext': ...
    def Dispose(self) -> None: ...

class AsyncFlowControl(System.ValueType, System.IEquatable[System.Threading.AsyncFlowControl], System.IDisposable):
    def Undo(self) -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, obj: 'System.Threading.AsyncFlowControl') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class IOCompletionCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, errorCode: 'System.UInt32', numBytes: 'System.UInt32', pOVERLAP: 'System.Threading.NativeOverlapped*') -> None: ...
    def BeginInvoke(self, errorCode: 'System.UInt32', numBytes: 'System.UInt32', pOVERLAP: 'System.Threading.NativeOverlapped*', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class IThreadPoolWorkItem:
    def Execute(self) -> None: ...

class LazyInitializer:
    @staticmethod
    @overload
    def EnsureInitialized() -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def EnsureInitialized(valueFactory: 'System.Func[T]') -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def EnsureInitialized() -> Tuple['T', 'T', 'System.Boolean', 'System.Object']: ...
    @staticmethod
    @overload
    def EnsureInitialized(valueFactory: 'System.Func[T]') -> Tuple['T', 'T', 'System.Boolean', 'System.Object']: ...
    @staticmethod
    @overload
    def EnsureInitialized(valueFactory: 'System.Func[T]') -> Tuple['T', 'T', 'System.Object']: ...

class LazyThreadSafetyMode(enum.Enum):
    None = ...
    PublicationOnly = ...
    ExecutionAndPublication = ...

class Lock:
    def __init__(self) -> None: ...
    IsHeldByCurrentThread: 'bool' = ...
    def Enter(self) -> None: ...
    def EnterScope(self) -> 'System.Threading.Lock.Scope': ...
    @overload
    def TryEnter(self) -> 'bool': ...
    @overload
    def TryEnter(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def TryEnter(self, timeout: 'System.TimeSpan') -> 'bool': ...
    def Exit(self) -> None: ...

class LockRecursionException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class ManualResetEvent(System.Threading.EventWaitHandle, System.IDisposable):
    def __init__(self, initialState: 'bool') -> None: ...

class ManualResetEventSlim(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, initialState: 'bool') -> None: ...
    @overload
    def __init__(self, initialState: 'bool', spinCount: 'int') -> None: ...
    WaitHandle: 'System.Threading.WaitHandle' = ...
    IsSet: 'bool' = ...
    SpinCount: 'int' = ...
    def Set(self) -> None: ...
    def Reset(self) -> None: ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    def Dispose(self) -> None: ...

class Mutex(System.Threading.WaitHandle, System.IDisposable):
    @overload
    def __init__(self, initiallyOwned: 'bool', name: 'str', createdNew: 'System.Boolean') -> None: ...
    @overload
    def __init__(self, initiallyOwned: 'bool', name: 'str') -> None: ...
    @overload
    def __init__(self, initiallyOwned: 'bool') -> None: ...
    @overload
    def __init__(self) -> None: ...
    @staticmethod
    def OpenExisting(name: 'str') -> 'System.Threading.Mutex': ...
    @staticmethod
    def TryOpenExisting(name: 'str') -> Tuple['bool', 'System.Threading.Mutex']: ...
    def ReleaseMutex(self) -> None: ...

class NativeOverlapped(System.ValueType):
    InternalLow: 'System.IntPtr' = ...
    InternalHigh: 'System.IntPtr' = ...
    OffsetLow: 'int' = ...
    OffsetHigh: 'int' = ...
    EventHandle: 'System.IntPtr' = ...

class Overlapped:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, offsetLo: 'int', offsetHi: 'int', hEvent: 'System.IntPtr', ar: 'System.IAsyncResult') -> None: ...
    @overload
    def __init__(self, offsetLo: 'int', offsetHi: 'int', hEvent: 'int', ar: 'System.IAsyncResult') -> None: ...
    AsyncResult: 'System.IAsyncResult' = ...
    OffsetLow: 'int' = ...
    OffsetHigh: 'int' = ...
    EventHandle: 'int' = ...
    EventHandleIntPtr: 'System.IntPtr' = ...
    @overload
    def Pack(self, iocb: 'System.Threading.IOCompletionCallback') -> 'System.Threading.NativeOverlapped*': ...
    @overload
    def Pack(self, iocb: 'System.Threading.IOCompletionCallback', userData: 'Any') -> 'System.Threading.NativeOverlapped*': ...
    @overload
    def UnsafePack(self, iocb: 'System.Threading.IOCompletionCallback') -> 'System.Threading.NativeOverlapped*': ...
    @overload
    def UnsafePack(self, iocb: 'System.Threading.IOCompletionCallback', userData: 'Any') -> 'System.Threading.NativeOverlapped*': ...
    @staticmethod
    def Unpack(nativeOverlappedPtr: 'System.Threading.NativeOverlapped*') -> 'System.Threading.Overlapped': ...
    @staticmethod
    def Free(nativeOverlappedPtr: 'System.Threading.NativeOverlapped*') -> None: ...

class ParameterizedThreadStart(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, obj: 'Any') -> None: ...
    def BeginInvoke(self, obj: 'Any', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class LockRecursionPolicy(enum.Enum):
    NoRecursion = ...
    SupportsRecursion = ...

class ReaderWriterLockSlim(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, recursionPolicy: 'System.Threading.LockRecursionPolicy') -> None: ...
    IsReadLockHeld: 'bool' = ...
    IsUpgradeableReadLockHeld: 'bool' = ...
    IsWriteLockHeld: 'bool' = ...
    RecursionPolicy: 'System.Threading.LockRecursionPolicy' = ...
    CurrentReadCount: 'int' = ...
    RecursiveReadCount: 'int' = ...
    RecursiveUpgradeCount: 'int' = ...
    RecursiveWriteCount: 'int' = ...
    WaitingReadCount: 'int' = ...
    WaitingUpgradeCount: 'int' = ...
    WaitingWriteCount: 'int' = ...
    def EnterReadLock(self) -> None: ...
    @overload
    def TryEnterReadLock(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def TryEnterReadLock(self, millisecondsTimeout: 'int') -> 'bool': ...
    def EnterWriteLock(self) -> None: ...
    @overload
    def TryEnterWriteLock(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def TryEnterWriteLock(self, millisecondsTimeout: 'int') -> 'bool': ...
    def EnterUpgradeableReadLock(self) -> None: ...
    @overload
    def TryEnterUpgradeableReadLock(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def TryEnterUpgradeableReadLock(self, millisecondsTimeout: 'int') -> 'bool': ...
    def ExitReadLock(self) -> None: ...
    def ExitWriteLock(self) -> None: ...
    def ExitUpgradeableReadLock(self) -> None: ...
    def Dispose(self) -> None: ...

class Semaphore(System.Threading.WaitHandle, System.IDisposable):
    @overload
    def __init__(self, initialCount: 'int', maximumCount: 'int') -> None: ...
    @overload
    def __init__(self, initialCount: 'int', maximumCount: 'int', name: 'str') -> None: ...
    @overload
    def __init__(self, initialCount: 'int', maximumCount: 'int', name: 'str', createdNew: 'System.Boolean') -> None: ...
    @staticmethod
    def OpenExisting(name: 'str') -> 'System.Threading.Semaphore': ...
    @staticmethod
    def TryOpenExisting(name: 'str') -> Tuple['bool', 'System.Threading.Semaphore']: ...
    @overload
    def Release(self) -> 'int': ...
    @overload
    def Release(self, releaseCount: 'int') -> 'int': ...

class SemaphoreFullException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class SemaphoreSlim(System.IDisposable):
    @overload
    def __init__(self, initialCount: 'int') -> None: ...
    @overload
    def __init__(self, initialCount: 'int', maxCount: 'int') -> None: ...
    CurrentCount: 'int' = ...
    AvailableWaitHandle: 'System.Threading.WaitHandle' = ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def WaitAsync(self) -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WaitAsync(self, millisecondsTimeout: 'int') -> 'System.Threading.Tasks.Task[bool]': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan') -> 'System.Threading.Tasks.Task[bool]': ...
    @overload
    def WaitAsync(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[bool]': ...
    @overload
    def WaitAsync(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[bool]': ...
    @overload
    def Release(self) -> 'int': ...
    @overload
    def Release(self, releaseCount: 'int') -> 'int': ...
    def Dispose(self) -> None: ...

class SendOrPostCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, state: 'Any') -> None: ...
    def BeginInvoke(self, state: 'Any', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class SpinLock(System.ValueType):
    def __init__(self, enableThreadOwnerTracking: 'bool') -> None: ...
    IsHeld: 'bool' = ...
    IsHeldByCurrentThread: 'bool' = ...
    IsThreadOwnerTrackingEnabled: 'bool' = ...
    def Enter(self) -> 'System.Boolean': ...
    @overload
    def TryEnter(self) -> 'System.Boolean': ...
    @overload
    def TryEnter(self, timeout: 'System.TimeSpan') -> 'System.Boolean': ...
    @overload
    def TryEnter(self, millisecondsTimeout: 'int') -> 'System.Boolean': ...
    @overload
    def Exit(self) -> None: ...
    @overload
    def Exit(self, useMemoryBarrier: 'bool') -> None: ...

class SpinWait(System.ValueType):
    Count: 'int' = ...
    NextSpinWillYield: 'bool' = ...
    @overload
    def SpinOnce(self) -> None: ...
    @overload
    def SpinOnce(self, sleep1Threshold: 'int') -> None: ...
    def Reset(self) -> None: ...
    @staticmethod
    @overload
    def SpinUntil(condition: 'System.Func[bool]') -> None: ...
    @staticmethod
    @overload
    def SpinUntil(condition: 'System.Func[bool]', timeout: 'System.TimeSpan') -> 'bool': ...
    @staticmethod
    @overload
    def SpinUntil(condition: 'System.Func[bool]', millisecondsTimeout: 'int') -> 'bool': ...

class SynchronizationLockException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class ThreadAbortException(System.SystemException, System.Runtime.Serialization.ISerializable):
    ExceptionState: 'Any' = ...

class ThreadExceptionEventArgs(System.EventArgs):
    def __init__(self, t: 'System.Exception') -> None: ...
    Exception: 'System.Exception' = ...

class ThreadExceptionEventHandler(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, sender: 'Any', e: 'System.Threading.ThreadExceptionEventArgs') -> None: ...
    def BeginInvoke(self, sender: 'Any', e: 'System.Threading.ThreadExceptionEventArgs', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class ThreadInterruptedException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class WaitCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, state: 'Any') -> None: ...
    def BeginInvoke(self, state: 'Any', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class WaitOrTimerCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, state: 'Any', timedOut: 'bool') -> None: ...
    def BeginInvoke(self, state: 'Any', timedOut: 'bool', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class ThreadPriority(enum.Enum):
    Lowest = ...
    BelowNormal = ...
    Normal = ...
    AboveNormal = ...
    Highest = ...

class ThreadStart(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self) -> None: ...
    def BeginInvoke(self, callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class ThreadStartException(System.SystemException, System.Runtime.Serialization.ISerializable):
    pass

class ThreadState(enum.Enum):
    Running = ...
    StopRequested = ...
    SuspendRequested = ...
    Background = ...
    Unstarted = ...
    Stopped = ...
    WaitSleepJoin = ...
    Suspended = ...
    AbortRequested = ...
    Aborted = ...

class ThreadStateException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class Timeout:
    InfiniteTimeSpan: 'System.TimeSpan' = ...
    Infinite: 'int' = ...

class PeriodicTimer(System.IDisposable):
    @overload
    def __init__(self, period: 'System.TimeSpan') -> None: ...
    @overload
    def __init__(self, period: 'System.TimeSpan', timeProvider: 'System.TimeProvider') -> None: ...
    Period: 'System.TimeSpan' = ...
    def WaitForNextTickAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[bool]': ...
    def Dispose(self) -> None: ...

class TimerCallback(System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable):
    def __init__(self, object: 'Any', method: 'System.IntPtr') -> None: ...
    def Invoke(self, state: 'Any') -> None: ...
    def BeginInvoke(self, state: 'Any', callback: 'System.AsyncCallback', object: 'Any') -> 'System.IAsyncResult': ...
    def EndInvoke(self, result: 'System.IAsyncResult') -> None: ...

class Timer(System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable, System.Threading.ITimer):
    @overload
    def __init__(self, callback: 'System.Threading.TimerCallback', state: 'Any', dueTime: 'int', period: 'int') -> None: ...
    @overload
    def __init__(self, callback: 'System.Threading.TimerCallback', state: 'Any', dueTime: 'System.TimeSpan', period: 'System.TimeSpan') -> None: ...
    @overload
    def __init__(self, callback: 'System.Threading.TimerCallback', state: 'Any', dueTime: 'System.UInt32', period: 'System.UInt32') -> None: ...
    @overload
    def __init__(self, callback: 'System.Threading.TimerCallback', state: 'Any', dueTime: 'int', period: 'int') -> None: ...
    @overload
    def __init__(self, callback: 'System.Threading.TimerCallback') -> None: ...
    ActiveCount: 'int' = ...
    @overload
    def Change(self, dueTime: 'int', period: 'int') -> 'bool': ...
    @overload
    def Change(self, dueTime: 'System.TimeSpan', period: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Change(self, dueTime: 'System.UInt32', period: 'System.UInt32') -> 'bool': ...
    @overload
    def Change(self, dueTime: 'int', period: 'int') -> 'bool': ...
    @overload
    def Dispose(self, notifyObject: 'System.Threading.WaitHandle') -> 'bool': ...
    @overload
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...

class Volatile:
    @staticmethod
    @overload
    def Read() -> Tuple['bool', 'System.Boolean']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['int', 'System.Byte']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['float', 'System.Double']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.Int16', 'System.Int16']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['int', 'System.Int32']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['int', 'System.Int64']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.IntPtr', 'System.IntPtr']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.SByte', 'System.SByte']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['float', 'System.Single']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.UInt16', 'System.UInt16']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.UInt32', 'System.UInt32']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.UInt64', 'System.UInt64']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['System.UIntPtr', 'System.UIntPtr']: ...
    @staticmethod
    @overload
    def Read() -> Tuple['T', 'T']: ...
    @staticmethod
    @overload
    def Write(value: 'bool') -> 'System.Boolean': ...
    @staticmethod
    @overload
    def Write(value: 'int') -> 'System.Byte': ...
    @staticmethod
    @overload
    def Write(value: 'float') -> 'System.Double': ...
    @staticmethod
    @overload
    def Write(value: 'System.Int16') -> 'System.Int16': ...
    @staticmethod
    @overload
    def Write(value: 'int') -> 'System.Int32': ...
    @staticmethod
    @overload
    def Write(value: 'int') -> 'System.Int64': ...
    @staticmethod
    @overload
    def Write(value: 'System.IntPtr') -> 'System.IntPtr': ...
    @staticmethod
    @overload
    def Write(value: 'System.SByte') -> 'System.SByte': ...
    @staticmethod
    @overload
    def Write(value: 'float') -> 'System.Single': ...
    @staticmethod
    @overload
    def Write(value: 'System.UInt16') -> 'System.UInt16': ...
    @staticmethod
    @overload
    def Write(value: 'System.UInt32') -> 'System.UInt32': ...
    @staticmethod
    @overload
    def Write(value: 'System.UInt64') -> 'System.UInt64': ...
    @staticmethod
    @overload
    def Write(value: 'System.UIntPtr') -> 'System.UIntPtr': ...
    @staticmethod
    @overload
    def Write(value: 'T') -> 'T': ...

class WaitHandleCannotBeOpenedException(System.ApplicationException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class WaitHandleExtensions:
    @staticmethod
    def GetSafeWaitHandle(waitHandle: 'System.Threading.WaitHandle') -> 'Microsoft.Win32.SafeHandles.SafeWaitHandle': ...
    @staticmethod
    def SetSafeWaitHandle(waitHandle: 'System.Threading.WaitHandle', value: 'Microsoft.Win32.SafeHandles.SafeWaitHandle') -> None: ...

class ITimer(System.IDisposable, System.IAsyncDisposable):
    def Change(self, dueTime: 'System.TimeSpan', period: 'System.TimeSpan') -> 'bool': ...

class RegisteredWaitHandle(System.MarshalByRefObject):
    def Unregister(self, waitObject: 'System.Threading.WaitHandle') -> 'bool': ...

class ThreadPoolBoundHandle(System.IDisposable, System.Threading.IDeferredDisposable):
    Handle: 'System.Runtime.InteropServices.SafeHandle' = ...
    @staticmethod
    def BindHandle(handle: 'System.Runtime.InteropServices.SafeHandle') -> 'System.Threading.ThreadPoolBoundHandle': ...
    @overload
    def AllocateNativeOverlapped(self, callback: 'System.Threading.IOCompletionCallback', state: 'Any', pinData: 'Any') -> 'System.Threading.NativeOverlapped*': ...
    @overload
    def AllocateNativeOverlapped(self, preAllocated: 'System.Threading.PreAllocatedOverlapped') -> 'System.Threading.NativeOverlapped*': ...
    def UnsafeAllocateNativeOverlapped(self, callback: 'System.Threading.IOCompletionCallback', state: 'Any', pinData: 'Any') -> 'System.Threading.NativeOverlapped*': ...
    def FreeNativeOverlapped(self, overlapped: 'System.Threading.NativeOverlapped*') -> None: ...
    @staticmethod
    def GetNativeOverlappedState(overlapped: 'System.Threading.NativeOverlapped*') -> 'Any': ...
    def Dispose(self) -> None: ...

class PreAllocatedOverlapped(System.IDisposable, System.Threading.IDeferredDisposable):
    def __init__(self, callback: 'System.Threading.IOCompletionCallback', state: 'Any', pinData: 'Any') -> None: ...
    @staticmethod
    def UnsafeCreate(callback: 'System.Threading.IOCompletionCallback', state: 'Any', pinData: 'Any') -> 'System.Threading.PreAllocatedOverlapped': ...
    def Dispose(self) -> None: ...

class BarrierPostPhaseException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class Barrier(System.IDisposable):
    @overload
    def __init__(self, participantCount: 'int') -> None: ...
    @overload
    def __init__(self, participantCount: 'int', postPhaseAction: 'System.Action[System.Threading.Barrier]') -> None: ...
    ParticipantsRemaining: 'int' = ...
    ParticipantCount: 'int' = ...
    CurrentPhaseNumber: 'int' = ...
    def AddParticipant(self) -> 'int': ...
    def AddParticipants(self, participantCount: 'int') -> 'int': ...
    def RemoveParticipant(self) -> None: ...
    def RemoveParticipants(self, participantCount: 'int') -> None: ...
    @overload
    def SignalAndWait(self) -> None: ...
    @overload
    def SignalAndWait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    def Dispose(self) -> None: ...

class CountdownEvent(System.IDisposable):
    def __init__(self, initialCount: 'int') -> None: ...
    CurrentCount: 'int' = ...
    InitialCount: 'int' = ...
    IsSet: 'bool' = ...
    WaitHandle: 'System.Threading.WaitHandle' = ...
    def Dispose(self) -> None: ...
    @overload
    def Signal(self) -> 'bool': ...
    @overload
    def Signal(self, signalCount: 'int') -> 'bool': ...
    @overload
    def AddCount(self) -> None: ...
    @overload
    def AddCount(self, signalCount: 'int') -> None: ...
    @overload
    def TryAddCount(self) -> 'bool': ...
    @overload
    def TryAddCount(self, signalCount: 'int') -> 'bool': ...
    @overload
    def Reset(self) -> None: ...
    @overload
    def Reset(self, count: 'int') -> None: ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...

class HostExecutionContext(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, state: 'Any') -> None: ...
    def CreateCopy(self) -> 'System.Threading.HostExecutionContext': ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Dispose(self, disposing: 'bool') -> None: ...

class HostExecutionContextManager:
    def __init__(self) -> None: ...
    def Capture(self) -> 'System.Threading.HostExecutionContext': ...
    def SetHostExecutionContext(self, hostExecutionContext: 'System.Threading.HostExecutionContext') -> 'Any': ...
    def Revert(self, previousState: 'Any') -> None: ...

class LockCookie(System.ValueType, System.IEquatable[System.Threading.LockCookie]):
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, obj: 'System.Threading.LockCookie') -> 'bool': ...

class ReaderWriterLock(System.Runtime.ConstrainedExecution.CriticalFinalizerObject):
    def __init__(self) -> None: ...
    IsReaderLockHeld: 'bool' = ...
    IsWriterLockHeld: 'bool' = ...
    WriterSeqNum: 'int' = ...
    def AnyWritersSince(self, seqNum: 'int') -> 'bool': ...
    @overload
    def AcquireReaderLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireReaderLock(self, timeout: 'System.TimeSpan') -> None: ...
    @overload
    def AcquireWriterLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireWriterLock(self, timeout: 'System.TimeSpan') -> None: ...
    def ReleaseReaderLock(self) -> None: ...
    def ReleaseWriterLock(self) -> None: ...
    @overload
    def UpgradeToWriterLock(self, millisecondsTimeout: 'int') -> 'System.Threading.LockCookie': ...
    @overload
    def UpgradeToWriterLock(self, timeout: 'System.TimeSpan') -> 'System.Threading.LockCookie': ...
    def DowngradeFromWriterLock(self) -> 'System.Threading.LockCookie': ...
    def ReleaseLock(self) -> 'System.Threading.LockCookie': ...
    def RestoreLock(self) -> 'System.Threading.LockCookie': ...

class BarrierPostPhaseException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class Barrier(System.IDisposable):
    @overload
    def __init__(self, participantCount: 'int') -> None: ...
    @overload
    def __init__(self, participantCount: 'int', postPhaseAction: 'System.Action[System.Threading.Barrier]') -> None: ...
    ParticipantsRemaining: 'int' = ...
    ParticipantCount: 'int' = ...
    CurrentPhaseNumber: 'int' = ...
    def AddParticipant(self) -> 'int': ...
    def AddParticipants(self, participantCount: 'int') -> 'int': ...
    def RemoveParticipant(self) -> None: ...
    def RemoveParticipants(self, participantCount: 'int') -> None: ...
    @overload
    def SignalAndWait(self) -> None: ...
    @overload
    def SignalAndWait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    def Dispose(self) -> None: ...

class CountdownEvent(System.IDisposable):
    def __init__(self, initialCount: 'int') -> None: ...
    CurrentCount: 'int' = ...
    InitialCount: 'int' = ...
    IsSet: 'bool' = ...
    WaitHandle: 'System.Threading.WaitHandle' = ...
    def Dispose(self) -> None: ...
    @overload
    def Signal(self) -> 'bool': ...
    @overload
    def Signal(self, signalCount: 'int') -> 'bool': ...
    @overload
    def AddCount(self) -> None: ...
    @overload
    def AddCount(self, signalCount: 'int') -> None: ...
    @overload
    def TryAddCount(self) -> 'bool': ...
    @overload
    def TryAddCount(self, signalCount: 'int') -> 'bool': ...
    @overload
    def Reset(self) -> None: ...
    @overload
    def Reset(self, count: 'int') -> None: ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...

class HostExecutionContext(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, state: 'Any') -> None: ...
    def CreateCopy(self) -> 'System.Threading.HostExecutionContext': ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Dispose(self, disposing: 'bool') -> None: ...

class HostExecutionContextManager:
    def __init__(self) -> None: ...
    def Capture(self) -> 'System.Threading.HostExecutionContext': ...
    def SetHostExecutionContext(self, hostExecutionContext: 'System.Threading.HostExecutionContext') -> 'Any': ...
    def Revert(self, previousState: 'Any') -> None: ...

class LockCookie(System.ValueType, System.IEquatable[System.Threading.LockCookie]):
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, obj: 'System.Threading.LockCookie') -> 'bool': ...

class ReaderWriterLock(System.Runtime.ConstrainedExecution.CriticalFinalizerObject):
    def __init__(self) -> None: ...
    IsReaderLockHeld: 'bool' = ...
    IsWriterLockHeld: 'bool' = ...
    WriterSeqNum: 'int' = ...
    def AnyWritersSince(self, seqNum: 'int') -> 'bool': ...
    @overload
    def AcquireReaderLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireReaderLock(self, timeout: 'System.TimeSpan') -> None: ...
    @overload
    def AcquireWriterLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireWriterLock(self, timeout: 'System.TimeSpan') -> None: ...
    def ReleaseReaderLock(self) -> None: ...
    def ReleaseWriterLock(self) -> None: ...
    @overload
    def UpgradeToWriterLock(self, millisecondsTimeout: 'int') -> 'System.Threading.LockCookie': ...
    @overload
    def UpgradeToWriterLock(self, timeout: 'System.TimeSpan') -> 'System.Threading.LockCookie': ...
    def DowngradeFromWriterLock(self) -> 'System.Threading.LockCookie': ...
    def ReleaseLock(self) -> 'System.Threading.LockCookie': ...
    def RestoreLock(self) -> 'System.Threading.LockCookie': ...

class BarrierPostPhaseException(System.Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, innerException: 'System.Exception') -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', innerException: 'System.Exception') -> None: ...

class Barrier(System.IDisposable):
    @overload
    def __init__(self, participantCount: 'int') -> None: ...
    @overload
    def __init__(self, participantCount: 'int', postPhaseAction: 'System.Action[System.Threading.Barrier]') -> None: ...
    ParticipantsRemaining: 'int' = ...
    ParticipantCount: 'int' = ...
    CurrentPhaseNumber: 'int' = ...
    def AddParticipant(self) -> 'int': ...
    def AddParticipants(self, participantCount: 'int') -> 'int': ...
    def RemoveParticipant(self) -> None: ...
    def RemoveParticipants(self, participantCount: 'int') -> None: ...
    @overload
    def SignalAndWait(self) -> None: ...
    @overload
    def SignalAndWait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def SignalAndWait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    def Dispose(self) -> None: ...

class CountdownEvent(System.IDisposable):
    def __init__(self, initialCount: 'int') -> None: ...
    CurrentCount: 'int' = ...
    InitialCount: 'int' = ...
    IsSet: 'bool' = ...
    WaitHandle: 'System.Threading.WaitHandle' = ...
    def Dispose(self) -> None: ...
    @overload
    def Signal(self) -> 'bool': ...
    @overload
    def Signal(self, signalCount: 'int') -> 'bool': ...
    @overload
    def AddCount(self) -> None: ...
    @overload
    def AddCount(self, signalCount: 'int') -> None: ...
    @overload
    def TryAddCount(self) -> 'bool': ...
    @overload
    def TryAddCount(self, signalCount: 'int') -> 'bool': ...
    @overload
    def Reset(self) -> None: ...
    @overload
    def Reset(self, count: 'int') -> None: ...
    @overload
    def Wait(self) -> None: ...
    @overload
    def Wait(self, cancellationToken: 'System.Threading.CancellationToken') -> None: ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan') -> 'bool': ...
    @overload
    def Wait(self, timeout: 'System.TimeSpan', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int') -> 'bool': ...
    @overload
    def Wait(self, millisecondsTimeout: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'bool': ...

class HostExecutionContext(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, state: 'Any') -> None: ...
    def CreateCopy(self) -> 'System.Threading.HostExecutionContext': ...
    @overload
    def Dispose(self) -> None: ...
    @overload
    def Dispose(self, disposing: 'bool') -> None: ...

class HostExecutionContextManager:
    def __init__(self) -> None: ...
    def Capture(self) -> 'System.Threading.HostExecutionContext': ...
    def SetHostExecutionContext(self, hostExecutionContext: 'System.Threading.HostExecutionContext') -> 'Any': ...
    def Revert(self, previousState: 'Any') -> None: ...

class LockCookie(System.ValueType, System.IEquatable[System.Threading.LockCookie]):
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, obj: 'System.Threading.LockCookie') -> 'bool': ...

class ReaderWriterLock(System.Runtime.ConstrainedExecution.CriticalFinalizerObject):
    def __init__(self) -> None: ...
    IsReaderLockHeld: 'bool' = ...
    IsWriterLockHeld: 'bool' = ...
    WriterSeqNum: 'int' = ...
    def AnyWritersSince(self, seqNum: 'int') -> 'bool': ...
    @overload
    def AcquireReaderLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireReaderLock(self, timeout: 'System.TimeSpan') -> None: ...
    @overload
    def AcquireWriterLock(self, millisecondsTimeout: 'int') -> None: ...
    @overload
    def AcquireWriterLock(self, timeout: 'System.TimeSpan') -> None: ...
    def ReleaseReaderLock(self) -> None: ...
    def ReleaseWriterLock(self) -> None: ...
    @overload
    def UpgradeToWriterLock(self, millisecondsTimeout: 'int') -> 'System.Threading.LockCookie': ...
    @overload
    def UpgradeToWriterLock(self, timeout: 'System.TimeSpan') -> 'System.Threading.LockCookie': ...
    def DowngradeFromWriterLock(self) -> 'System.Threading.LockCookie': ...
    def ReleaseLock(self) -> 'System.Threading.LockCookie': ...
    def RestoreLock(self) -> 'System.Threading.LockCookie': ...

from . import Tasks as Tasks
from . import Channels as Channels
