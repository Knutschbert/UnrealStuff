from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class ImmutableArrayExtensions:
    @staticmethod
    def Select(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', selector: 'System.Func[T, TResult]') -> 'List[TResult]': ...
    @staticmethod
    def SelectMany(immutableArray: 'System.Collections.Immutable.ImmutableArray[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    def Where(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'List[T]': ...
    @staticmethod
    @overload
    def Any(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(builder: 'System.Collections.Immutable.Builder[T]') -> 'bool': ...
    @staticmethod
    def All(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'System.Collections.Immutable.ImmutableArray[TDerived]', comparer: 'System.Collections.Generic.IEqualityComparer[TBase]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'List[TDerived]', comparer: 'System.Collections.Generic.IEqualityComparer[TBase]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'System.Collections.Immutable.ImmutableArray[TDerived]', predicate: 'System.Func[TBase, TBase, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', func: 'System.Func[T, T, T]') -> 'T': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, T, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, T, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    def ElementAt(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', index: 'int') -> 'T': ...
    @staticmethod
    def ElementAtOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', index: 'int') -> 'T': ...
    @staticmethod
    @overload
    def First(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def First(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def First(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def Last(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def Last(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def Last(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def Single(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def Single(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def SingleOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def SingleOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, T]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', elementSelector: 'System.Func[T, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, T]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', elementSelector: 'System.Func[T, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    def ToArray(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'List[T]': ...

class Enumerable:
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', func: 'System.Func[TSource, TSource, TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def All(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def Append(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    def Prepend(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    def Cast(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    def Chunk(source: 'List[TSource]', size: 'int') -> 'List[List[TSource]]': ...
    @staticmethod
    def Concat(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seedSelector: 'System.Func[TKey, TAccumulate]', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    def CountBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, int]]': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    def TryGetNonEnumeratedCount(source: 'List[TSource]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]', defaultValue: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    def AsEnumerable(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def Empty() -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    def Index(source: 'List[TSource]') -> 'List[System.ValueTuple[int, TSource]]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    def OfType(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    def Range(start: 'int', count: 'int') -> 'List[int]': ...
    @staticmethod
    def Repeat(element: 'TResult', count: 'int') -> 'List[TResult]': ...
    @staticmethod
    def Reverse(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, int, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, int, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, int, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    def Skip(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def SkipLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', range: 'System.Range') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def TakeLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    def ToArray(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def ToList(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', resultSelector: 'System.Func[TFirst, TSecond, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]') -> 'List[System.ValueTuple[TFirst, TSecond]]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', third: 'List[TThird]') -> 'List[System.ValueTuple[TFirst, TSecond, TThird]]': ...

class IQueryable(System.Collections.IEnumerable):
    Expression: 'System.Linq.Expressions.Expression' = ...
    ElementType: 'System.Type' = ...
    Provider: 'System.Linq.IQueryProvider' = ...

class IQueryProvider:
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'System.Linq.IQueryable': ...
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'IQueryable[TElement]': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'Any': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'TResult': ...

class IOrderedQueryable(System.Linq.IQueryable, System.Collections.IEnumerable):
    pass

class IQueryable(System.Collections.IEnumerable):
    Expression: 'System.Linq.Expressions.Expression' = ...
    ElementType: 'System.Type' = ...
    Provider: 'System.Linq.IQueryProvider' = ...

class IQueryProvider:
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'System.Linq.IQueryable': ...
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'IQueryable[TElement]': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'Any': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'TResult': ...

class IOrderedQueryable(System.Linq.IQueryable, System.Collections.IEnumerable):
    pass

class Enumerable:
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', func: 'System.Func[TSource, TSource, TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def All(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def Append(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    def Prepend(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    def Cast(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    def Chunk(source: 'List[TSource]', size: 'int') -> 'List[List[TSource]]': ...
    @staticmethod
    def Concat(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seedSelector: 'System.Func[TKey, TAccumulate]', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    def CountBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, int]]': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    def TryGetNonEnumeratedCount(source: 'List[TSource]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]', defaultValue: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    def AsEnumerable(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def Empty() -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    def Index(source: 'List[TSource]') -> 'List[System.ValueTuple[int, TSource]]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    def OfType(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    def Range(start: 'int', count: 'int') -> 'List[int]': ...
    @staticmethod
    def Repeat(element: 'TResult', count: 'int') -> 'List[TResult]': ...
    @staticmethod
    def Reverse(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, int, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, int, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, int, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    def Skip(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def SkipLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', range: 'System.Range') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def TakeLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    def ToArray(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def ToList(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', resultSelector: 'System.Func[TFirst, TSecond, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]') -> 'List[System.ValueTuple[TFirst, TSecond]]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', third: 'List[TThird]') -> 'List[System.ValueTuple[TFirst, TSecond, TThird]]': ...

class EnumerableExecutor:
    pass

class EnumerableQuery:
    pass

class Queryable:
    @staticmethod
    @overload
    def AsQueryable(source: 'List[TElement]') -> 'IQueryable[TElement]': ...
    @staticmethod
    @overload
    def AsQueryable(source: 'System.Collections.IEnumerable') -> 'System.Linq.IQueryable': ...
    @staticmethod
    @overload
    def Where(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, int, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    def OfType(source: 'System.Linq.IQueryable') -> 'IQueryable[TResult]': ...
    @staticmethod
    def Cast(source: 'System.Linq.IQueryable') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, List[TResult]]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int, List[TResult]]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'IQueryable[TSource]', collectionSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, int, List[TCollection]]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TCollection, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'IQueryable[TSource]', collectionSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, List[TCollection]]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TCollection, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'IQueryable[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TKey]]', innerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TInner, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TInner, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'IQueryable[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TKey]]', innerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TInner, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TInner, TResult]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'IQueryable[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TKey]]', innerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TInner, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, List[TInner], TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'IQueryable[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, TKey]]', innerKeySelector: 'System.Linq.Expressions.Expression[System.Func[TInner, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TOuter, List[TInner], TResult]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Order(source: 'IQueryable[T]') -> 'IOrderedQueryable[T]': ...
    @staticmethod
    @overload
    def Order(source: 'IQueryable[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedQueryable[T]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'IQueryable[T]') -> 'IOrderedQueryable[T]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'IQueryable[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedQueryable[T]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedQueryable[TSource]': ...
    @staticmethod
    @overload
    def Take(source: 'IQueryable[TSource]', count: 'int') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Take(source: 'IQueryable[TSource]', range: 'System.Range') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, int, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    def Skip(source: 'IQueryable[TSource]', count: 'int') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, int, bool]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IQueryable[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', elementSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TElement]]') -> 'IQueryable[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', elementSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TElement]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', elementSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TElement]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TKey, List[TElement], TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TKey, List[TSource], TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TKey, List[TSource], TResult]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', elementSelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TElement]]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TKey, List[TElement], TResult]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Distinct(source: 'IQueryable[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'IQueryable[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TSource]': ...
    @staticmethod
    def Chunk(source: 'IQueryable[TSource]', size: 'int') -> 'IQueryable[List[TSource]]': ...
    @staticmethod
    def Concat(source1: 'IQueryable[TSource]', source2: 'List[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Zip(source1: 'IQueryable[TFirst]', source2: 'List[TSecond]') -> 'IQueryable[System.ValueTuple[TFirst, TSecond]]': ...
    @staticmethod
    @overload
    def Zip(source1: 'IQueryable[TFirst]', source2: 'List[TSecond]', resultSelector: 'System.Linq.Expressions.Expression[System.Func[TFirst, TSecond, TResult]]') -> 'IQueryable[TResult]': ...
    @staticmethod
    @overload
    def Zip(source1: 'IQueryable[TFirst]', source2: 'List[TSecond]', source3: 'List[TThird]') -> 'IQueryable[System.ValueTuple[TFirst, TSecond, TThird]]': ...
    @staticmethod
    @overload
    def Union(source1: 'IQueryable[TSource]', source2: 'List[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Union(source1: 'IQueryable[TSource]', source2: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(source1: 'IQueryable[TSource]', source2: 'List[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(source1: 'IQueryable[TSource]', source2: 'List[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TSource]': ...
    @staticmethod
    def Index(source: 'IQueryable[TSource]') -> 'IQueryable[System.ValueTuple[int, TSource]]': ...
    @staticmethod
    @overload
    def Intersect(source1: 'IQueryable[TSource]', source2: 'List[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Intersect(source1: 'IQueryable[TSource]', source2: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(source1: 'IQueryable[TSource]', source2: 'List[TKey]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(source1: 'IQueryable[TSource]', source2: 'List[TKey]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Except(source1: 'IQueryable[TSource]', source2: 'List[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Except(source1: 'IQueryable[TSource]', source2: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(source1: 'IQueryable[TSource]', source2: 'List[TKey]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(source1: 'IQueryable[TSource]', source2: 'List[TKey]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def First(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def First(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'IQueryable[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'IQueryable[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'IQueryable[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAt(source: 'IQueryable[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAt(source: 'IQueryable[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'IQueryable[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'IQueryable[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'IQueryable[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'IQueryable[TSource]', defaultValue: 'TSource') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def Contains(source: 'IQueryable[TSource]', item: 'TSource') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'IQueryable[TSource]', item: 'TSource', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    def Reverse(source: 'IQueryable[TSource]') -> 'IQueryable[TSource]': ...
    @staticmethod
    @overload
    def SequenceEqual(source1: 'IQueryable[TSource]', source2: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(source1: 'IQueryable[TSource]', source2: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'IQueryable[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'bool': ...
    @staticmethod
    def All(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'bool': ...
    @staticmethod
    @overload
    def Count(source: 'IQueryable[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def Count(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'int': ...
    @staticmethod
    def CountBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[System.Collections.Generic.KeyValuePair[TKey, int]]': ...
    @staticmethod
    @overload
    def LongCount(source: 'IQueryable[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'IQueryable[TSource]', predicate: 'System.Linq.Expressions.Expression[System.Func[TSource, bool]]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'IQueryable[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, TResult]]') -> 'TResult': ...
    @staticmethod
    @overload
    def MinBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'TSource': ...
    @staticmethod
    @overload
    def MinBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'IQueryable[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'IQueryable[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, TResult]]') -> 'TResult': ...
    @staticmethod
    @overload
    def MaxBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]') -> 'TSource': ...
    @staticmethod
    @overload
    def MaxBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int]]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[int]]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int]]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[int]]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, float]]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[float]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, float]]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[float]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, System.Decimal]]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[System.Decimal]]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int]]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[int]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, float]]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[float]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, int]]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[int]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, float]]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[float]]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, System.Decimal]]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'IQueryable[TSource]', selector: 'System.Linq.Expressions.Expression[System.Func[TSource, Optional[System.Decimal]]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Aggregate(source: 'IQueryable[TSource]', func: 'System.Linq.Expressions.Expression[System.Func[TSource, TSource, TSource]]') -> 'TSource': ...
    @staticmethod
    @overload
    def Aggregate(source: 'IQueryable[TSource]', seed: 'TAccumulate', func: 'System.Linq.Expressions.Expression[System.Func[TAccumulate, TSource, TAccumulate]]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(source: 'IQueryable[TSource]', seed: 'TAccumulate', func: 'System.Linq.Expressions.Expression[System.Func[TAccumulate, TSource, TAccumulate]]', selector: 'System.Linq.Expressions.Expression[System.Func[TAccumulate, TResult]]') -> 'TResult': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', seed: 'TAccumulate', func: 'System.Linq.Expressions.Expression[System.Func[TAccumulate, TSource, TAccumulate]]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'IQueryable[TSource]', keySelector: 'System.Linq.Expressions.Expression[System.Func[TSource, TKey]]', seedSelector: 'System.Linq.Expressions.Expression[System.Func[TKey, TAccumulate]]', func: 'System.Linq.Expressions.Expression[System.Func[TAccumulate, TSource, TAccumulate]]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'IQueryable[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    def SkipLast(source: 'IQueryable[TSource]', count: 'int') -> 'IQueryable[TSource]': ...
    @staticmethod
    def TakeLast(source: 'IQueryable[TSource]', count: 'int') -> 'IQueryable[TSource]': ...
    @staticmethod
    def Append(source: 'IQueryable[TSource]', element: 'TSource') -> 'IQueryable[TSource]': ...
    @staticmethod
    def Prepend(source: 'IQueryable[TSource]', element: 'TSource') -> 'IQueryable[TSource]': ...

class ParallelQuery(System.Collections.IEnumerable):
    pass

class ParallelEnumerable:
    @staticmethod
    @overload
    def AsParallel(source: 'List[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def AsParallel(source: 'System.Collections.Concurrent.Partitioner[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def AsParallel(source: 'System.Collections.IEnumerable') -> 'System.Linq.ParallelQuery': ...
    @staticmethod
    @overload
    def AsOrdered(source: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def AsOrdered(source: 'System.Linq.ParallelQuery') -> 'System.Linq.ParallelQuery': ...
    @staticmethod
    def AsUnordered(source: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def AsSequential(source: 'ParallelQuery[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def WithDegreeOfParallelism(source: 'ParallelQuery[TSource]', degreeOfParallelism: 'int') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def WithCancellation(source: 'ParallelQuery[TSource]', cancellationToken: 'System.Threading.CancellationToken') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def WithExecutionMode(source: 'ParallelQuery[TSource]', executionMode: 'System.Linq.ParallelExecutionMode') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def WithMergeOptions(source: 'ParallelQuery[TSource]', mergeOptions: 'System.Linq.ParallelMergeOptions') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def Range(start: 'int', count: 'int') -> 'ParallelQuery[int]': ...
    @staticmethod
    def Repeat(element: 'TResult', count: 'int') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    def Empty() -> 'ParallelQuery[TResult]': ...
    @staticmethod
    def ForAll(source: 'ParallelQuery[TSource]', action: 'System.Action[TSource]') -> None: ...
    @staticmethod
    @overload
    def Where(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Select(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Zip(first: 'ParallelQuery[TFirst]', second: 'ParallelQuery[TSecond]', resultSelector: 'System.Func[TFirst, TSecond, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Zip(first: 'ParallelQuery[TFirst]', second: 'List[TSecond]', resultSelector: 'System.Func[TFirst, TSecond, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'ParallelQuery[TOuter]', inner: 'ParallelQuery[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'ParallelQuery[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'ParallelQuery[TOuter]', inner: 'ParallelQuery[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'ParallelQuery[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'ParallelQuery[TOuter]', inner: 'ParallelQuery[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'ParallelQuery[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'ParallelQuery[TOuter]', inner: 'ParallelQuery[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'ParallelQuery[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, List[TResult]]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int, List[TResult]]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'ParallelQuery[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'ParallelQuery[TSource]', collectionSelector: 'System.Func[TSource, int, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'OrderedParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'OrderedParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'OrderedParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'OrderedParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'OrderedParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'ParallelQuery[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'ParallelQuery[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def Aggregate(source: 'ParallelQuery[TSource]', func: 'System.Func[TSource, TSource, TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Aggregate(source: 'ParallelQuery[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(source: 'ParallelQuery[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Aggregate(source: 'ParallelQuery[TSource]', seed: 'TAccumulate', updateAccumulatorFunc: 'System.Func[TAccumulate, TSource, TAccumulate]', combineAccumulatorsFunc: 'System.Func[TAccumulate, TAccumulate, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Aggregate(source: 'ParallelQuery[TSource]', seedFactory: 'System.Func[TAccumulate]', updateAccumulatorFunc: 'System.Func[TAccumulate, TSource, TAccumulate]', combineAccumulatorsFunc: 'System.Func[TAccumulate, TAccumulate, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Count(source: 'ParallelQuery[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def Count(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'ParallelQuery[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'ParallelQuery[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Any(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'ParallelQuery[TSource]') -> 'bool': ...
    @staticmethod
    def All(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'ParallelQuery[TSource]', value: 'TSource') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'ParallelQuery[TSource]', value: 'TSource', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    def Take(source: 'ParallelQuery[TSource]', count: 'int') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def Skip(source: 'ParallelQuery[TSource]', count: 'int') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Concat(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Concat(first: 'ParallelQuery[TSource]', second: 'List[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'ParallelQuery[TSource]', second: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'ParallelQuery[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Distinct(source: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'ParallelQuery[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'ParallelQuery[TSource]', second: 'List[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'ParallelQuery[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'ParallelQuery[TSource]', second: 'List[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'ParallelQuery[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'ParallelQuery[TSource]', second: 'List[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'ParallelQuery[TSource]', second: 'ParallelQuery[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'ParallelQuery[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def AsEnumerable(source: 'ParallelQuery[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def ToArray(source: 'ParallelQuery[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def ToList(source: 'ParallelQuery[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'ParallelQuery[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    def Reverse(source: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def OfType(source: 'System.Linq.ParallelQuery') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    def Cast(source: 'System.Linq.ParallelQuery') -> 'ParallelQuery[TResult]': ...
    @staticmethod
    @overload
    def First(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def First(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'ParallelQuery[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'ParallelQuery[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'ParallelQuery[TSource]') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'ParallelQuery[TSource]', defaultValue: 'TSource') -> 'ParallelQuery[TSource]': ...
    @staticmethod
    def ElementAt(source: 'ParallelQuery[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    def ElementAtOrDefault(source: 'ParallelQuery[TSource]', index: 'int') -> 'TSource': ...

class ParallelExecutionMode(enum.Enum):
    Default = ...
    ForceParallelism = ...

class ParallelMergeOptions(enum.Enum):
    Default = ...
    NotBuffered = ...
    AutoBuffered = ...
    FullyBuffered = ...

class IQueryable(System.Collections.IEnumerable):
    Expression: 'System.Linq.Expressions.Expression' = ...
    ElementType: 'System.Type' = ...
    Provider: 'System.Linq.IQueryProvider' = ...

class IQueryProvider:
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'System.Linq.IQueryable': ...
    @overload
    def CreateQuery(self, expression: 'System.Linq.Expressions.Expression') -> 'IQueryable[TElement]': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'Any': ...
    @overload
    def Execute(self, expression: 'System.Linq.Expressions.Expression') -> 'TResult': ...

class IOrderedQueryable(System.Linq.IQueryable, System.Collections.IEnumerable):
    pass

class Enumerable:
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', func: 'System.Func[TSource, TSource, TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(source: 'List[TSource]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def All(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'bool': ...
    @staticmethod
    def Append(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    def Prepend(source: 'List[TSource]', element: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Average(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    def Cast(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    def Chunk(source: 'List[TSource]', size: 'int') -> 'List[List[TSource]]': ...
    @staticmethod
    def Concat(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource') -> 'bool': ...
    @staticmethod
    @overload
    def Contains(source: 'List[TSource]', value: 'TSource', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    @overload
    def AggregateBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', seedSelector: 'System.Func[TKey, TAccumulate]', func: 'System.Func[TAccumulate, TSource, TAccumulate]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, TAccumulate]]': ...
    @staticmethod
    def CountBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', keyComparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[System.Collections.Generic.KeyValuePair[TKey, int]]': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def Count(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    def TryGetNonEnumeratedCount(source: 'List[TSource]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]') -> 'int': ...
    @staticmethod
    @overload
    def LongCount(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'int': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DefaultIfEmpty(source: 'List[TSource]', defaultValue: 'TSource') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Distinct(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def DistinctBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAt(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'int') -> 'TSource': ...
    @staticmethod
    @overload
    def ElementAtOrDefault(source: 'List[TSource]', index: 'System.Index') -> 'TSource': ...
    @staticmethod
    def AsEnumerable(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def Empty() -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Except(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ExceptBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def First(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def FirstOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TSource]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[IGrouping[TKey, TElement]]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', resultSelector: 'System.Func[TKey, List[TSource], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', resultSelector: 'System.Func[TKey, List[TElement], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def GroupJoin(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, List[TInner], TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    def Index(source: 'List[TSource]') -> 'List[System.ValueTuple[int, TSource]]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Intersect(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def IntersectBy(first: 'List[TSource]', second: 'List[TKey]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Join(outer: 'List[TOuter]', inner: 'List[TInner]', outerKeySelector: 'System.Func[TOuter, TKey]', innerKeySelector: 'System.Func[TInner, TKey]', resultSelector: 'System.Func[TOuter, TInner, TResult]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Last(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def LastOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToLookup(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'ILookup[TKey, TElement]': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Max(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MaxBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', comparer: 'System.Collections.Generic.IComparer[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Min(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'TResult': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'TSource': ...
    @staticmethod
    @overload
    def MinBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'TSource': ...
    @staticmethod
    def OfType(source: 'System.Collections.IEnumerable') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def Order(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderBy(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderDescending(source: 'List[T]', comparer: 'System.Collections.Generic.IComparer[T]') -> 'IOrderedEnumerable[T]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def OrderByDescending(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenBy(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    @overload
    def ThenByDescending(source: 'IOrderedEnumerable[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IComparer[TKey]') -> 'IOrderedEnumerable[TSource]': ...
    @staticmethod
    def Range(start: 'int', count: 'int') -> 'List[int]': ...
    @staticmethod
    def Repeat(element: 'TResult', count: 'int') -> 'List[TResult]': ...
    @staticmethod
    def Reverse(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Select(source: 'List[TSource]', selector: 'System.Func[TSource, int, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', selector: 'System.Func[TSource, int, List[TResult]]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, int, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SelectMany(source: 'List[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'bool': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def Single(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'TSource': ...
    @staticmethod
    @overload
    def SingleOrDefault(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]', defaultValue: 'TSource') -> 'TSource': ...
    @staticmethod
    def Skip(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def SkipWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def SkipLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, int]') -> 'int': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, float]') -> 'float': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, System.Decimal]') -> 'System.Decimal': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[int]]') -> 'Optional[int]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[float]]') -> 'Optional[float]': ...
    @staticmethod
    @overload
    def Sum(source: 'List[TSource]', selector: 'System.Func[TSource, Optional[System.Decimal]]') -> 'Optional[System.Decimal]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Take(source: 'List[TSource]', range: 'System.Range') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def TakeWhile(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    def TakeLast(source: 'List[TSource]', count: 'int') -> 'List[TSource]': ...
    @staticmethod
    def ToArray(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    def ToList(source: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.Collections.Generic.KeyValuePair[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[System.ValueTuple[TKey, TValue]]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TValue]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TSource]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(source: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', elementSelector: 'System.Func[TSource, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def ToHashSet(source: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'System.Collections.Generic.HashSet[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Union(first: 'List[TSource]', second: 'List[TSource]', comparer: 'System.Collections.Generic.IEqualityComparer[TSource]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def UnionBy(first: 'List[TSource]', second: 'List[TSource]', keySelector: 'System.Func[TSource, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Where(source: 'List[TSource]', predicate: 'System.Func[TSource, int, bool]') -> 'List[TSource]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', resultSelector: 'System.Func[TFirst, TSecond, TResult]') -> 'List[TResult]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]') -> 'List[System.ValueTuple[TFirst, TSecond]]': ...
    @staticmethod
    @overload
    def Zip(first: 'List[TFirst]', second: 'List[TSecond]', third: 'List[TThird]') -> 'List[System.ValueTuple[TFirst, TSecond, TThird]]': ...

class ImmutableArrayExtensions:
    @staticmethod
    def Select(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', selector: 'System.Func[T, TResult]') -> 'List[TResult]': ...
    @staticmethod
    def SelectMany(immutableArray: 'System.Collections.Immutable.ImmutableArray[TSource]', collectionSelector: 'System.Func[TSource, List[TCollection]]', resultSelector: 'System.Func[TSource, TCollection, TResult]') -> 'List[TResult]': ...
    @staticmethod
    def Where(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'List[T]': ...
    @staticmethod
    @overload
    def Any(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Any(builder: 'System.Collections.Immutable.Builder[T]') -> 'bool': ...
    @staticmethod
    def All(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'System.Collections.Immutable.ImmutableArray[TDerived]', comparer: 'System.Collections.Generic.IEqualityComparer[TBase]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'List[TDerived]', comparer: 'System.Collections.Generic.IEqualityComparer[TBase]') -> 'bool': ...
    @staticmethod
    @overload
    def SequenceEqual(immutableArray: 'System.Collections.Immutable.ImmutableArray[TBase]', items: 'System.Collections.Immutable.ImmutableArray[TDerived]', predicate: 'System.Func[TBase, TBase, bool]') -> 'bool': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', func: 'System.Func[T, T, T]') -> 'T': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, T, TAccumulate]') -> 'TAccumulate': ...
    @staticmethod
    @overload
    def Aggregate(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', seed: 'TAccumulate', func: 'System.Func[TAccumulate, T, TAccumulate]', resultSelector: 'System.Func[TAccumulate, TResult]') -> 'TResult': ...
    @staticmethod
    def ElementAt(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', index: 'int') -> 'T': ...
    @staticmethod
    def ElementAtOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', index: 'int') -> 'T': ...
    @staticmethod
    @overload
    def First(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def First(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def First(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def FirstOrDefault(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def Last(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def Last(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def Last(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def LastOrDefault(builder: 'System.Collections.Immutable.Builder[T]') -> 'T': ...
    @staticmethod
    @overload
    def Single(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def Single(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def SingleOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'T': ...
    @staticmethod
    @overload
    def SingleOrDefault(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', predicate: 'System.Func[T, bool]') -> 'T': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]') -> 'System.Collections.Generic.Dictionary[TKey, T]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', elementSelector: 'System.Func[T, TElement]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, T]': ...
    @staticmethod
    @overload
    def ToDictionary(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]', keySelector: 'System.Func[T, TKey]', elementSelector: 'System.Func[T, TElement]', comparer: 'System.Collections.Generic.IEqualityComparer[TKey]') -> 'System.Collections.Generic.Dictionary[TKey, TElement]': ...
    @staticmethod
    def ToArray(immutableArray: 'System.Collections.Immutable.ImmutableArray[T]') -> 'List[T]': ...

from . import Expressions as Expressions
from . import Parallel as Parallel
