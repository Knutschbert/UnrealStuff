from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class Evidence(System.Collections.ICollection, System.Collections.IEnumerable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, hostEvidence: 'List[Any]', assemblyEvidence: 'List[Any]') -> None: ...
    @overload
    def __init__(self, evidence: 'System.Security.Policy.Evidence') -> None: ...
    @overload
    def __init__(self, hostEvidence: 'List[System.Security.Policy.EvidenceBase]', assemblyEvidence: 'List[System.Security.Policy.EvidenceBase]') -> None: ...
    Count: 'int' = ...
    IsReadOnly: 'bool' = ...
    IsSynchronized: 'bool' = ...
    Locked: 'bool' = ...
    SyncRoot: 'Any' = ...
    def AddAssembly(self, id: 'Any') -> None: ...
    def AddAssemblyEvidence(self, evidence: 'T') -> None: ...
    def AddHostEvidence(self, evidence: 'T') -> None: ...
    def GetAssemblyEvidence(self) -> 'T': ...
    def GetHostEvidence(self) -> 'T': ...
    def AddHost(self, id: 'Any') -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> 'System.Security.Policy.Evidence': ...
    def CopyTo(self, array: 'System.Array', index: 'int') -> None: ...
    def GetAssemblyEnumerator(self) -> 'System.Collections.IEnumerator': ...
    def GetEnumerator(self) -> 'System.Collections.IEnumerator': ...
    def GetHostEnumerator(self) -> 'System.Collections.IEnumerator': ...
    def Merge(self, evidence: 'System.Security.Policy.Evidence') -> None: ...
    def RemoveType(self, t: 'System.Type') -> None: ...

class EvidenceBase:
    def Clone(self) -> 'System.Security.Policy.EvidenceBase': ...

