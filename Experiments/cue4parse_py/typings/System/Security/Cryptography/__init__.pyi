from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class CryptographicException(System.SystemException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, hr: 'int') -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...
    @overload
    def __init__(self, format: 'str', insert: 'str') -> None: ...

class SP800108HmacCounterKdf(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'List[int]', context: 'List[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'str', context: 'str', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'List[int]', context: 'List[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'str', context: 'str', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    def Dispose(self) -> None: ...

class Aes(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.Aes': ...
    @staticmethod
    @overload
    def Create(algorithmName: 'str') -> 'System.Security.Cryptography.Aes': ...

class AesCcm(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    NonceByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    TagByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    IsSupported: 'bool' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class AesCryptoServiceProvider(System.Security.Cryptography.Aes, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class AesGcm(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', tagSizeInBytes: 'int') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', tagSizeInBytes: 'int') -> None: ...
    NonceByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    TagSizeInBytes: 'Optional[int]' = ...
    IsSupported: 'bool' = ...
    TagByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class AesManaged(System.Security.Cryptography.Aes, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class AsnEncodedData:
    @overload
    def __init__(self, rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, rawData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid', rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, oid: 'str', rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid', rawData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, oid: 'str', rawData: 'System.ReadOnlySpan[int]') -> None: ...
    Oid: 'System.Security.Cryptography.Oid' = ...
    RawData: 'List[int]' = ...
    def CopyFrom(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    def Format(self, multiLine: 'bool') -> 'str': ...

class AsnEncodedDataCollection(System.Collections.ICollection, System.Collections.IEnumerable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    __getitem__: 'System.Security.Cryptography.AsnEncodedData' = ...
    Count: 'int' = ...
    IsSynchronized: 'bool' = ...
    SyncRoot: 'Any' = ...
    def Add(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> 'int': ...
    def Remove(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    def GetEnumerator(self) -> 'System.Security.Cryptography.AsnEncodedDataEnumerator': ...
    def CopyTo(self, array: 'List[System.Security.Cryptography.AsnEncodedData]', index: 'int') -> None: ...

class AsnEncodedDataEnumerator(System.Collections.IEnumerator):
    Current: 'System.Security.Cryptography.AsnEncodedData' = ...
    def MoveNext(self) -> 'bool': ...
    def Reset(self) -> None: ...

class AsymmetricAlgorithm(System.IDisposable):
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    SignatureAlgorithm: 'str' = ...
    KeyExchangeAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.AsymmetricAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.AsymmetricAlgorithm': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    def ExportPkcs8PrivateKey(self) -> 'List[int]': ...
    def ExportSubjectPublicKeyInfo(self) -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    def ExportPkcs8PrivateKeyPem(self) -> 'str': ...
    @overload
    def ExportEncryptedPkcs8PrivateKeyPem(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'str': ...
    @overload
    def ExportEncryptedPkcs8PrivateKeyPem(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'str': ...
    def ExportSubjectPublicKeyInfoPem(self) -> 'str': ...
    def TryExportSubjectPublicKeyInfoPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKeyPem(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKeyPem(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...

class AsymmetricKeyExchangeDeformatter:
    Parameters: 'str' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def DecryptKeyExchange(self, rgb: 'List[int]') -> 'List[int]': ...

class AsymmetricKeyExchangeFormatter:
    Parameters: 'str' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, data: 'List[int]') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, data: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...

class AsymmetricSignatureDeformatter:
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    @overload
    def VerifySignature(self, hash: 'System.Security.Cryptography.HashAlgorithm', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class AsymmetricSignatureFormatter:
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    @overload
    def CreateSignature(self, hash: 'System.Security.Cryptography.HashAlgorithm') -> 'List[int]': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class AuthenticationTagMismatchException(System.Security.Cryptography.CryptographicException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...

class FromBase64TransformMode(enum.Enum):
    IgnoreWhiteSpaces = ...
    DoNotIgnoreWhiteSpaces = ...

class ToBase64Transform(System.Security.Cryptography.ICryptoTransform, System.IDisposable):
    def __init__(self) -> None: ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...

class FromBase64Transform(System.Security.Cryptography.ICryptoTransform, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, whitespaces: 'System.Security.Cryptography.FromBase64TransformMode') -> None: ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...

class ChaCha20Poly1305(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class CipherMode(enum.Enum):
    CBC = ...
    ECB = ...
    OFB = ...
    CFB = ...
    CTS = ...

class CngAlgorithm(System.IEquatable[System.Security.Cryptography.CngAlgorithm]):
    def __init__(self, algorithm: 'str') -> None: ...
    Algorithm: 'str' = ...
    Rsa: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellman: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP256: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP384: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP521: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsa: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP256: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP384: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP521: 'System.Security.Cryptography.CngAlgorithm' = ...
    MD5: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha1: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha256: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha384: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha512: 'System.Security.Cryptography.CngAlgorithm' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngAlgorithm') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngAlgorithmGroup(System.IEquatable[System.Security.Cryptography.CngAlgorithmGroup]):
    def __init__(self, algorithmGroup: 'str') -> None: ...
    AlgorithmGroup: 'str' = ...
    DiffieHellman: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    Dsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ECDiffieHellman: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ECDsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    Rsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngAlgorithmGroup') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngExportPolicies(enum.Enum):
    None = ...
    AllowExport = ...
    AllowPlaintextExport = ...
    AllowArchiving = ...
    AllowPlaintextArchiving = ...

class CngKeyBlobFormat(System.IEquatable[System.Security.Cryptography.CngKeyBlobFormat]):
    def __init__(self, format: 'str') -> None: ...
    Format: 'str' = ...
    EccPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccFullPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccFullPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    GenericPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    GenericPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    OpaqueTransportBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    Pkcs8PrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngKeyCreationOptions(enum.Enum):
    None = ...
    MachineKey = ...
    OverwriteExistingKey = ...
    PreferVbs = ...
    RequireVbs = ...
    UsePerBootKey = ...

class CngKeyCreationParameters:
    def __init__(self) -> None: ...
    ExportPolicy: 'Optional[System.Security.Cryptography.CngExportPolicies]' = ...
    KeyCreationOptions: 'System.Security.Cryptography.CngKeyCreationOptions' = ...
    KeyUsage: 'Optional[System.Security.Cryptography.CngKeyUsages]' = ...
    Parameters: 'System.Security.Cryptography.CngPropertyCollection' = ...
    ParentWindowHandle: 'System.IntPtr' = ...
    Provider: 'System.Security.Cryptography.CngProvider' = ...
    UIPolicy: 'System.Security.Cryptography.CngUIPolicy' = ...

class CngKeyHandleOpenOptions(enum.Enum):
    None = ...
    EphemeralKey = ...

class CngKeyOpenOptions(enum.Enum):
    None = ...
    UserKey = ...
    MachineKey = ...
    Silent = ...

class CngKeyUsages(enum.Enum):
    None = ...
    Decryption = ...
    Signing = ...
    KeyAgreement = ...
    AllUsages = ...

class CngProperty(System.ValueType, System.IEquatable[System.Security.Cryptography.CngProperty]):
    def __init__(self, name: 'str', value: 'List[int]', options: 'System.Security.Cryptography.CngPropertyOptions') -> None: ...
    Name: 'str' = ...
    Options: 'System.Security.Cryptography.CngPropertyOptions' = ...
    def GetValue(self) -> 'List[int]': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngProperty') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class CngPropertyCollection(System.Collections.ObjectModel.Collection[System.Security.Cryptography.CngProperty], System.Collections.Generic.IList[System.Security.Cryptography.CngProperty], System.Collections.Generic.ICollection[System.Security.Cryptography.CngProperty], List[System.Security.Cryptography.CngProperty], System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, List[System.Security.Cryptography.CngProperty], System.Collections.Generic.IReadOnlyCollection[System.Security.Cryptography.CngProperty]):
    def __init__(self) -> None: ...

class CngPropertyOptions(enum.Enum):
    None = ...
    CustomProperty = ...
    Persist = ...

class CngProvider(System.IEquatable[System.Security.Cryptography.CngProvider]):
    def __init__(self, provider: 'str') -> None: ...
    Provider: 'str' = ...
    MicrosoftPlatformCryptoProvider: 'System.Security.Cryptography.CngProvider' = ...
    MicrosoftSmartCardKeyStorageProvider: 'System.Security.Cryptography.CngProvider' = ...
    MicrosoftSoftwareKeyStorageProvider: 'System.Security.Cryptography.CngProvider' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngProvider') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngUIPolicy:
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str', useContext: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str', useContext: 'str', creationTitle: 'str') -> None: ...
    ProtectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels' = ...
    FriendlyName: 'str' = ...
    Description: 'str' = ...
    UseContext: 'str' = ...
    CreationTitle: 'str' = ...

class CngUIProtectionLevels(enum.Enum):
    None = ...
    ProtectKey = ...
    ForceHighProtection = ...

class CryptographicOperations:
    @staticmethod
    def FixedTimeEquals(left: 'System.ReadOnlySpan[int]', right: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @staticmethod
    def ZeroMemory(buffer: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    def TryHashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def HashDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    def TryHmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class CryptographicUnexpectedOperationException(System.Security.Cryptography.CryptographicException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...
    @overload
    def __init__(self, format: 'str', insert: 'str') -> None: ...

class CryptoConfig:
    def __init__(self) -> None: ...
    AllowOnlyFipsAlgorithms: 'bool' = ...
    @staticmethod
    def AddAlgorithm(algorithm: 'System.Type', names: 'List[str]') -> None: ...
    @staticmethod
    @overload
    def CreateFromName(name: 'str', args: 'List[Any]') -> 'Any': ...
    @staticmethod
    @overload
    def CreateFromName(name: 'str') -> 'Any': ...
    @staticmethod
    def AddOID(oid: 'str', names: 'List[str]') -> None: ...
    @staticmethod
    def MapNameToOID(name: 'str') -> 'str': ...
    @staticmethod
    def EncodeOID(str: 'str') -> 'List[int]': ...

class CryptoStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', transform: 'System.Security.Cryptography.ICryptoTransform', mode: 'System.Security.Cryptography.CryptoStreamMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', transform: 'System.Security.Cryptography.ICryptoTransform', mode: 'System.Security.Cryptography.CryptoStreamMode', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    HasFlushedFinalBlock: 'bool' = ...
    def FlushFinalBlock(self) -> None: ...
    def FlushFinalBlockAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    def WriteByte(self, value: 'int') -> None: ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Clear(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...

class CryptoStreamMode(enum.Enum):
    Read = ...
    Write = ...

class CspParameters:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int') -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int', strProviderNameIn: 'str') -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int', strProviderNameIn: 'str', strContainerNameIn: 'str') -> None: ...
    ProviderType: 'int' = ...
    ProviderName: 'str' = ...
    KeyContainerName: 'str' = ...
    KeyNumber: 'int' = ...
    Flags: 'System.Security.Cryptography.CspProviderFlags' = ...
    KeyPassword: 'System.Security.SecureString' = ...
    ParentWindowHandle: 'System.IntPtr' = ...

class CspProviderFlags(enum.Enum):
    NoFlags = ...
    UseMachineKeyStore = ...
    UseDefaultKeyContainer = ...
    UseNonExportableKey = ...
    UseExistingKey = ...
    UseArchivableKey = ...
    UseUserProtectedKey = ...
    NoPrompt = ...
    CreateEphemeralKey = ...

class DeriveBytes(System.IDisposable):
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def Reset(self) -> None: ...
    def Dispose(self) -> None: ...

class DES(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.DES': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.DES': ...
    @staticmethod
    def IsWeakKey(rgbKey: 'List[int]') -> 'bool': ...
    @staticmethod
    def IsSemiWeakKey(rgbKey: 'List[int]') -> 'bool': ...

class DSA(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create(keySizeInBits: 'int') -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.DSAParameters') -> 'System.Security.Cryptography.DSA': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifySignature(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def TryCreateSignature(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryCreateSignature(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def GetMaxSignatureSize(self, signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class DSAParameters(System.ValueType):
    P: 'List[int]' = ...
    Q: 'List[int]' = ...
    G: 'List[int]' = ...
    Y: 'List[int]' = ...
    J: 'List[int]' = ...
    X: 'List[int]' = ...
    Seed: 'List[int]' = ...
    Counter: 'int' = ...

class DSASignatureDeformatter(System.Security.Cryptography.AsymmetricSignatureDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class DSASignatureFormat(enum.Enum):
    IeeeP1363FixedFieldConcatenation = ...
    Rfc3279DerSequence = ...

class DSASignatureFormatter(System.Security.Cryptography.AsymmetricSignatureFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class ECAlgorithm(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportECPrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ExportECPrivateKey(self) -> 'List[int]': ...
    def TryExportECPrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ExportECPrivateKeyPem(self) -> 'str': ...
    def TryExportECPrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...

class ECCurve(System.ValueType):
    A: 'List[int]' = ...
    B: 'List[int]' = ...
    G: 'System.Security.Cryptography.ECPoint' = ...
    Order: 'List[int]' = ...
    Cofactor: 'List[int]' = ...
    Seed: 'List[int]' = ...
    CurveType: 'System.Security.Cryptography.ECCurve.ECCurveType' = ...
    Hash: 'Optional[System.Security.Cryptography.HashAlgorithmName]' = ...
    Polynomial: 'List[int]' = ...
    Prime: 'List[int]' = ...
    Oid: 'System.Security.Cryptography.Oid' = ...
    IsPrime: 'bool' = ...
    IsCharacteristic2: 'bool' = ...
    IsExplicit: 'bool' = ...
    IsNamed: 'bool' = ...
    @staticmethod
    def CreateFromOid(curveOid: 'System.Security.Cryptography.Oid') -> 'System.Security.Cryptography.ECCurve': ...
    @staticmethod
    def CreateFromFriendlyName(oidFriendlyName: 'str') -> 'System.Security.Cryptography.ECCurve': ...
    @staticmethod
    def CreateFromValue(oidValue: 'str') -> 'System.Security.Cryptography.ECCurve': ...
    def Validate(self) -> None: ...

class ECDiffieHellman(System.Security.Cryptography.ECAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(curve: 'System.Security.Cryptography.ECCurve') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.ECParameters') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(algorithm: 'str') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyTls(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', prfLabel: 'List[int]', prfSeed: 'List[int]') -> 'List[int]': ...
    def DeriveRawSecretAgreement(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class ECDiffieHellmanKeyDerivationFunction(enum.Enum):
    Hash = ...
    Hmac = ...
    Tls = ...

class ECDiffieHellmanPublicKey(System.IDisposable):
    def Dispose(self) -> None: ...
    def ToByteArray(self) -> 'List[int]': ...
    def ToXmlString(self) -> 'str': ...
    def ExportParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def ExportExplicitParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportSubjectPublicKeyInfo(self) -> 'List[int]': ...

class ECDsa(System.Security.Cryptography.ECAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(curve: 'System.Security.Cryptography.ECCurve') -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.ECParameters') -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(algorithm: 'str') -> 'System.Security.Cryptography.ECDsa': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    def GetMaxSignatureSize(self, signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class ECKeyXmlFormat(enum.Enum):
    Rfc4050 = ...

class ECParameters(System.ValueType):
    Q: 'System.Security.Cryptography.ECPoint' = ...
    D: 'List[int]' = ...
    Curve: 'System.Security.Cryptography.ECCurve' = ...
    def Validate(self) -> None: ...

class ECPoint(System.ValueType):
    X: 'List[int]' = ...
    Y: 'List[int]' = ...

class HashAlgorithm(System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSize: 'int' = ...
    Hash: 'List[int]' = ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.HashAlgorithm': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.HashAlgorithm': ...
    @overload
    def ComputeHash(self, buffer: 'List[int]') -> 'List[int]': ...
    @overload
    def ComputeHash(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    @overload
    def ComputeHash(self, inputStream: 'System.IO.Stream') -> 'List[int]': ...
    def TryComputeHash(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ComputeHashAsync(self, inputStream: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[List[int]]': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Initialize(self) -> None: ...

class HashAlgorithmName(System.ValueType, System.IEquatable[System.Security.Cryptography.HashAlgorithmName]):
    def __init__(self, name: 'str') -> None: ...
    MD5: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA1: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA256: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA384: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA512: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_256: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_384: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_512: 'System.Security.Cryptography.HashAlgorithmName' = ...
    Name: 'str' = ...
    def ToString(self) -> 'str': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    @staticmethod
    def TryFromOid(oidValue: 'str') -> Tuple['bool', 'System.Security.Cryptography.HashAlgorithmName']: ...
    @staticmethod
    def FromOid(oidValue: 'str') -> 'System.Security.Cryptography.HashAlgorithmName': ...

class HKDF:
    @staticmethod
    @overload
    def Extract(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'List[int]', salt: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def Extract(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', prk: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def Expand(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', prk: 'List[int]', outputLength: 'int', info: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def Expand(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', prk: 'System.ReadOnlySpan[int]', output: 'System.Span[int]', info: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def DeriveKey(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'List[int]', outputLength: 'int', salt: 'List[int]', info: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveKey(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'System.ReadOnlySpan[int]', output: 'System.Span[int]', salt: 'System.ReadOnlySpan[int]', info: 'System.ReadOnlySpan[int]') -> None: ...

class HMAC(System.Security.Cryptography.KeyedHashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashName: 'str' = ...
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.HMAC': ...
    @staticmethod
    @overload
    def Create(algorithmName: 'str') -> 'System.Security.Cryptography.HMAC': ...
    def Initialize(self) -> None: ...

class HMACMD5(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA1(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', useManagedSha1: 'bool') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA256(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA384(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    ProduceLegacyHmacValues: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA512(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    ProduceLegacyHmacValues: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_256(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_384(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_512(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class ICryptoTransform(System.IDisposable):
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...

class ICspAsymmetricAlgorithm:
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ImportCspBlob(self, rawData: 'List[int]') -> None: ...

class IncrementalHash(System.IDisposable):
    HashLengthInBytes: 'int' = ...
    AlgorithmName: 'System.Security.Cryptography.HashAlgorithmName' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self) -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> 'int': ...
    def TryGetHashAndReset(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def GetCurrentHash(self) -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> 'int': ...
    def TryGetCurrentHash(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def Clone(self) -> 'System.Security.Cryptography.IncrementalHash': ...
    def Dispose(self) -> None: ...
    @staticmethod
    def CreateHash(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'System.Security.Cryptography.IncrementalHash': ...
    @staticmethod
    @overload
    def CreateHMAC(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]') -> 'System.Security.Cryptography.IncrementalHash': ...
    @staticmethod
    @overload
    def CreateHMAC(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]') -> 'System.Security.Cryptography.IncrementalHash': ...

class KeyedHashAlgorithm(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.KeyedHashAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.KeyedHashAlgorithm': ...

class KeyNumber(enum.Enum):
    Exchange = ...
    Signature = ...

class KeySizes:
    def __init__(self, minSize: 'int', maxSize: 'int', skipSize: 'int') -> None: ...
    MinSize: 'int' = ...
    MaxSize: 'int' = ...
    SkipSize: 'int' = ...

class Kmac128(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Kmac128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class Kmac256(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Kmac256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class KmacXof128(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.KmacXof128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class KmacXof256(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.KmacXof256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class MaskGenerationMethod:
    def GenerateMask(self, rgbSeed: 'List[int]', cbReturn: 'int') -> 'List[int]': ...

class MD5(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.MD5': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.MD5': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class MD5CryptoServiceProvider(System.Security.Cryptography.MD5, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class Oid:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, oid: 'str') -> None: ...
    @overload
    def __init__(self, value: 'str', friendlyName: 'str') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid') -> None: ...
    Value: 'str' = ...
    FriendlyName: 'str' = ...
    @staticmethod
    def FromFriendlyName(friendlyName: 'str', group: 'System.Security.Cryptography.OidGroup') -> 'System.Security.Cryptography.Oid': ...
    @staticmethod
    def FromOidValue(oidValue: 'str', group: 'System.Security.Cryptography.OidGroup') -> 'System.Security.Cryptography.Oid': ...

class OidCollection(System.Collections.ICollection, System.Collections.IEnumerable):
    def __init__(self) -> None: ...
    __getitem__: 'System.Security.Cryptography.Oid' = ...
    __getitem__: 'System.Security.Cryptography.Oid' = ...
    Count: 'int' = ...
    IsSynchronized: 'bool' = ...
    SyncRoot: 'Any' = ...
    def Add(self, oid: 'System.Security.Cryptography.Oid') -> 'int': ...
    def GetEnumerator(self) -> 'System.Security.Cryptography.OidEnumerator': ...
    def CopyTo(self, array: 'List[System.Security.Cryptography.Oid]', index: 'int') -> None: ...

class OidEnumerator(System.Collections.IEnumerator):
    Current: 'System.Security.Cryptography.Oid' = ...
    def MoveNext(self) -> 'bool': ...
    def Reset(self) -> None: ...

class OidGroup(enum.Enum):
    All = ...
    HashAlgorithm = ...
    EncryptionAlgorithm = ...
    PublicKeyAlgorithm = ...
    SignatureAlgorithm = ...
    Attribute = ...
    ExtensionOrAttribute = ...
    EnhancedKeyUsage = ...
    Policy = ...
    Template = ...
    KeyDerivationFunction = ...

class PaddingMode(enum.Enum):
    None = ...
    PKCS7 = ...
    Zeros = ...
    ANSIX923 = ...
    ISO10126 = ...

class PasswordDeriveBytes(System.Security.Cryptography.DeriveBytes, System.IDisposable):
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', strHashName: 'str', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', hashName: 'str', iterations: 'int') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', strHashName: 'str', iterations: 'int', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', hashName: 'str', iterations: 'int', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    HashName: 'str' = ...
    IterationCount: 'int' = ...
    Salt: 'List[int]' = ...
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def Reset(self) -> None: ...
    def CryptDeriveKey(self, algname: 'str', alghashname: 'str', keySize: 'int', rgbIV: 'List[int]') -> 'List[int]': ...

class PbeEncryptionAlgorithm(enum.Enum):
    Unknown = ...
    Aes128Cbc = ...
    Aes192Cbc = ...
    Aes256Cbc = ...
    TripleDes3KeyPkcs12 = ...

class PbeParameters:
    def __init__(self, encryptionAlgorithm: 'System.Security.Cryptography.PbeEncryptionAlgorithm', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', iterationCount: 'int') -> None: ...
    EncryptionAlgorithm: 'System.Security.Cryptography.PbeEncryptionAlgorithm' = ...
    HashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    IterationCount: 'int' = ...

class PemEncoding:
    @staticmethod
    def Find(pemData: 'System.ReadOnlySpan[System.Char]') -> 'System.Security.Cryptography.PemFields': ...
    @staticmethod
    def TryFind(pemData: 'System.ReadOnlySpan[System.Char]') -> Tuple['bool', 'System.Security.Cryptography.PemFields']: ...
    @staticmethod
    def GetEncodedSize(labelLength: 'int', dataLength: 'int') -> 'int': ...
    @staticmethod
    def TryWrite(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def Write(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]') -> 'List[System.Char]': ...
    @staticmethod
    def WriteString(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]') -> 'str': ...

class PemFields(System.ValueType):
    Location: 'System.Range' = ...
    Label: 'System.Range' = ...
    Base64Data: 'System.Range' = ...
    DecodedDataLength: 'int' = ...

class PKCS1MaskGenerationMethod(System.Security.Cryptography.MaskGenerationMethod):
    def __init__(self) -> None: ...
    HashName: 'str' = ...
    def GenerateMask(self, rgbSeed: 'List[int]', cbReturn: 'int') -> 'List[int]': ...

class RandomNumberGenerator(System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RandomNumberGenerator': ...
    @staticmethod
    @overload
    def Create(rngName: 'str') -> 'System.Security.Cryptography.RandomNumberGenerator': ...
    def Dispose(self) -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def GetBytes(self, data: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def GetBytes(count: 'int') -> 'List[int]': ...
    @overload
    def GetNonZeroBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'System.Span[int]') -> None: ...
    @staticmethod
    def Fill(data: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def GetInt32(fromInclusive: 'int', toExclusive: 'int') -> 'int': ...
    @staticmethod
    @overload
    def GetInt32(toExclusive: 'int') -> 'int': ...
    @staticmethod
    @overload
    def GetItems(choices: 'System.ReadOnlySpan[T]', destination: 'System.Span[T]') -> None: ...
    @staticmethod
    @overload
    def GetItems(choices: 'System.ReadOnlySpan[T]', length: 'int') -> 'List[T]': ...
    @staticmethod
    def GetString(choices: 'System.ReadOnlySpan[System.Char]', length: 'int') -> 'str': ...
    @staticmethod
    @overload
    def GetHexString(destination: 'System.Span[System.Char]', lowercase: 'bool') -> None: ...
    @staticmethod
    @overload
    def GetHexString(stringLength: 'int', lowercase: 'bool') -> 'str': ...
    @staticmethod
    def Shuffle(values: 'System.Span[T]') -> None: ...

class RC2(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    KeySize: 'int' = ...
    EffectiveKeySize: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RC2': ...
    @staticmethod
    @overload
    def Create(AlgName: 'str') -> 'System.Security.Cryptography.RC2': ...

class Rijndael(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.Rijndael': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.Rijndael': ...

class RijndaelManaged(System.Security.Cryptography.Rijndael, System.IDisposable):
    def __init__(self) -> None: ...
    BlockSize: 'int' = ...
    FeedbackSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class Rfc2898DeriveBytes(System.Security.Cryptography.DeriveBytes, System.IDisposable):
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    HashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    IterationCount: 'int' = ...
    Salt: 'List[int]' = ...
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def CryptDeriveKey(self, algname: 'str', alghashname: 'str', keySize: 'int', rgbIV: 'List[int]') -> 'List[int]': ...
    def Reset(self) -> None: ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'List[int]', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'str', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[System.Char]', salt: 'System.ReadOnlySpan[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[System.Char]', salt: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...

class RNGCryptoServiceProvider(System.Security.Cryptography.RandomNumberGenerator, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, str: 'str') -> None: ...
    @overload
    def __init__(self, rgb: 'List[int]') -> None: ...
    @overload
    def __init__(self, cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def GetBytes(self, data: 'System.Span[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'System.Span[int]') -> None: ...

class RSA(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(keySizeInBits: 'int') -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.RSAParameters') -> 'System.Security.Cryptography.RSA': ...
    def GetMaxOutputSize(self) -> 'int': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'System.ReadOnlySpan[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'int': ...
    @overload
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'System.ReadOnlySpan[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'int': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def TryDecrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TryEncrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    def DecryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    def EncryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'int': ...
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def ExportRSAPrivateKey(self) -> 'List[int]': ...
    def TryExportRSAPrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportRSAPublicKey(self) -> 'List[int]': ...
    def TryExportRSAPublicKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportRSAPublicKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportRSAPrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ExportRSAPrivateKeyPem(self) -> 'str': ...
    def ExportRSAPublicKeyPem(self) -> 'str': ...
    def TryExportRSAPrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportRSAPublicKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class RSAEncryptionPadding(System.IEquatable[System.Security.Cryptography.RSAEncryptionPadding]):
    Pkcs1: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA1: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA256: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA384: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA512: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_256: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_384: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_512: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    Mode: 'System.Security.Cryptography.RSAEncryptionPaddingMode' = ...
    OaepHashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    @staticmethod
    def CreateOaep(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'System.Security.Cryptography.RSAEncryptionPadding': ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'bool': ...
    def ToString(self) -> 'str': ...

class RSAEncryptionPaddingMode(enum.Enum):
    Pkcs1 = ...
    Oaep = ...

class RSAOAEPKeyExchangeDeformatter(System.Security.Cryptography.AsymmetricKeyExchangeDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameters: 'str' = ...
    def DecryptKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...

class RSAOAEPKeyExchangeFormatter(System.Security.Cryptography.AsymmetricKeyExchangeFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameter: 'List[int]' = ...
    Parameters: 'str' = ...
    Rng: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...

class RSAParameters(System.ValueType):
    D: 'List[int]' = ...
    DP: 'List[int]' = ...
    DQ: 'List[int]' = ...
    Exponent: 'List[int]' = ...
    InverseQ: 'List[int]' = ...
    Modulus: 'List[int]' = ...
    P: 'List[int]' = ...
    Q: 'List[int]' = ...

class RSAPKCS1KeyExchangeDeformatter(System.Security.Cryptography.AsymmetricKeyExchangeDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    RNG: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    Parameters: 'str' = ...
    def DecryptKeyExchange(self, rgbIn: 'List[int]') -> 'List[int]': ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...

class RSAPKCS1KeyExchangeFormatter(System.Security.Cryptography.AsymmetricKeyExchangeFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameters: 'str' = ...
    Rng: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...

class RSAPKCS1SignatureDeformatter(System.Security.Cryptography.AsymmetricSignatureDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class RSAPKCS1SignatureFormatter(System.Security.Cryptography.AsymmetricSignatureFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class RSASignaturePadding(System.IEquatable[System.Security.Cryptography.RSASignaturePadding]):
    Pkcs1: 'System.Security.Cryptography.RSASignaturePadding' = ...
    Pss: 'System.Security.Cryptography.RSASignaturePadding' = ...
    Mode: 'System.Security.Cryptography.RSASignaturePaddingMode' = ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def ToString(self) -> 'str': ...

class RSASignaturePaddingMode(enum.Enum):
    Pkcs1 = ...
    Pss = ...

class SHA1(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA1': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA1': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA1CryptoServiceProvider(System.Security.Cryptography.SHA1, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA1Managed(System.Security.Cryptography.SHA1, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA256(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA256': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA256': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA256CryptoServiceProvider(System.Security.Cryptography.SHA256, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA256Managed(System.Security.Cryptography.SHA256, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA384(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA384': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA384': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA384CryptoServiceProvider(System.Security.Cryptography.SHA384, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA384Managed(System.Security.Cryptography.SHA384, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA512(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA512': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA512': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA512CryptoServiceProvider(System.Security.Cryptography.SHA512, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA512Managed(System.Security.Cryptography.SHA512, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA3_256(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_256': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA3_384(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_384': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA3_512(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_512': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class Shake128(System.IDisposable):
    def __init__(self) -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def Read(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def Read(self, destination: 'System.Span[int]') -> None: ...
    def Reset(self) -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Shake128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', outputLength: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class Shake256(System.IDisposable):
    def __init__(self) -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def Read(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def Read(self, destination: 'System.Span[int]') -> None: ...
    def Reset(self) -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Shake256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', outputLength: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class SignatureDescription:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, el: 'System.Security.SecurityElement') -> None: ...
    KeyAlgorithm: 'str' = ...
    DigestAlgorithm: 'str' = ...
    FormatterAlgorithm: 'str' = ...
    DeformatterAlgorithm: 'str' = ...
    def CreateDeformatter(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> 'System.Security.Cryptography.AsymmetricSignatureDeformatter': ...
    def CreateFormatter(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> 'System.Security.Cryptography.AsymmetricSignatureFormatter': ...
    def CreateDigest(self) -> 'System.Security.Cryptography.HashAlgorithm': ...

class SymmetricAlgorithm(System.IDisposable):
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SymmetricAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.SymmetricAlgorithm': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    def ValidKeySize(self, bitLength: 'int') -> 'bool': ...
    def GetCiphertextLengthEcb(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def GetCiphertextLengthCbc(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def GetCiphertextLengthCfb(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    @overload
    def DecryptEcb(self, ciphertext: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryDecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptEcb(self, plaintext: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryEncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DecryptCbc(self, ciphertext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryDecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptCbc(self, plaintext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryEncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DecryptCfb(self, ciphertext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def DecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def DecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    def TryDecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptCfb(self, plaintext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def EncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def EncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    def TryEncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> Tuple['bool', 'System.Int32']: ...

class TripleDES(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.TripleDES': ...
    @staticmethod
    @overload
    def Create(str: 'str') -> 'System.Security.Cryptography.TripleDES': ...
    @staticmethod
    def IsWeakKey(rgbKey: 'List[int]') -> 'bool': ...

class DSACng(System.Security.Cryptography.DSA, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    SignatureAlgorithm: 'str' = ...
    KeyExchangeAlgorithm: 'str' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class ECDiffieHellmanCng(System.Security.Cryptography.ECDiffieHellman, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    HashAlgorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    KeyDerivationFunction: 'System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction' = ...
    HmacKey: 'List[int]' = ...
    Label: 'List[int]' = ...
    SecretAppend: 'List[int]' = ...
    SecretPrepend: 'List[int]' = ...
    Seed: 'List[int]' = ...
    UseSecretAgreementAsHmacKey: 'bool' = ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyTls(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', prfLabel: 'List[int]', prfSeed: 'List[int]') -> 'List[int]': ...
    def DeriveRawSecretAgreement(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    @overload
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.CngKey') -> 'List[int]': ...
    @overload
    def DeriveSecretAgreementHandle(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle': ...
    @overload
    def DeriveSecretAgreementHandle(self, otherPartyPublicKey: 'System.Security.Cryptography.CngKey') -> 'Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle': ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    def FromXmlString(self, xml: 'str', format: 'System.Security.Cryptography.ECKeyXmlFormat') -> None: ...
    def ToXmlString(self, format: 'System.Security.Cryptography.ECKeyXmlFormat') -> 'str': ...

class ECDsaCng(System.Security.Cryptography.ECDsa, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    HashAlgorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    def TrySignHash(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def FromXmlString(self, xml: 'str', format: 'System.Security.Cryptography.ECKeyXmlFormat') -> None: ...
    @overload
    def SignData(self, data: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream') -> 'List[int]': ...
    def ToXmlString(self, format: 'System.Security.Cryptography.ECKeyXmlFormat') -> 'str': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]') -> 'bool': ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...

class RSACng(System.Security.Cryptography.RSA, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def TryEncrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TryDecrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class AesCng(System.Security.Cryptography.Aes, System.IDisposable, System.Security.Cryptography.ICngSymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keyName: 'str') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> None: ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class CngKey(System.IDisposable):
    Algorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    AlgorithmGroup: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ExportPolicy: 'System.Security.Cryptography.CngExportPolicies' = ...
    Handle: 'Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle' = ...
    IsEphemeral: 'bool' = ...
    IsMachineKey: 'bool' = ...
    KeyName: 'str' = ...
    KeySize: 'int' = ...
    KeyUsage: 'System.Security.Cryptography.CngKeyUsages' = ...
    ParentWindowHandle: 'System.IntPtr' = ...
    Provider: 'System.Security.Cryptography.CngProvider' = ...
    ProviderHandle: 'Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle' = ...
    UIPolicy: 'System.Security.Cryptography.CngUIPolicy' = ...
    UniqueName: 'str' = ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm', keyName: 'str') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm', keyName: 'str', creationParameters: 'System.Security.Cryptography.CngKeyCreationParameters') -> 'System.Security.Cryptography.CngKey': ...
    def Delete(self) -> None: ...
    @staticmethod
    @overload
    def Exists(keyName: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def Exists(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> 'bool': ...
    @staticmethod
    @overload
    def Exists(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', options: 'System.Security.Cryptography.CngKeyOpenOptions') -> 'bool': ...
    def Export(self, format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'List[int]': ...
    @staticmethod
    @overload
    def Import(keyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Import(keyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat', provider: 'System.Security.Cryptography.CngProvider') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyHandle: 'Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle', keyHandleOpenOptions: 'System.Security.Cryptography.CngKeyHandleOpenOptions') -> 'System.Security.Cryptography.CngKey': ...
    def GetProperty(self, name: 'str', options: 'System.Security.Cryptography.CngPropertyOptions') -> 'System.Security.Cryptography.CngProperty': ...
    def HasProperty(self, name: 'str', options: 'System.Security.Cryptography.CngPropertyOptions') -> 'bool': ...
    def SetProperty(self, property: 'System.Security.Cryptography.CngProperty') -> None: ...

class CspKeyContainerInfo:
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    Accessible: 'bool' = ...
    Exportable: 'bool' = ...
    HardwareDevice: 'bool' = ...
    KeyContainerName: 'str' = ...
    KeyNumber: 'System.Security.Cryptography.KeyNumber' = ...
    MachineKeyStore: 'bool' = ...
    Protected: 'bool' = ...
    ProviderName: 'str' = ...
    ProviderType: 'int' = ...
    RandomlyGenerated: 'bool' = ...
    Removable: 'bool' = ...
    UniqueKeyContainerName: 'str' = ...

class DESCryptoServiceProvider(System.Security.Cryptography.DES, System.IDisposable):
    def __init__(self) -> None: ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...

class DSACryptoServiceProvider(System.Security.Cryptography.DSA, System.IDisposable, System.Security.Cryptography.ICspAsymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int', parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    PersistKeyInCsp: 'bool' = ...
    PublicOnly: 'bool' = ...
    UseMachineKeyStore: 'bool' = ...
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportCspBlob(self, keyBlob: 'List[int]') -> None: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def SignData(self, inputStream: 'System.IO.Stream') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    def VerifyData(self, rgbData: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def SignHash(self, rgbHash: 'List[int]', str: 'str') -> 'List[int]': ...
    def VerifyHash(self, rgbHash: 'List[int]', str: 'str', rgbSignature: 'List[int]') -> 'bool': ...

class ECDiffieHellmanCngPublicKey(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.IDisposable):
    BlobFormat: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    def ToXmlString(self) -> 'str': ...
    @staticmethod
    def FromXmlString(xml: 'str') -> 'System.Security.Cryptography.ECDiffieHellmanCngPublicKey': ...
    @staticmethod
    def FromByteArray(publicKeyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'System.Security.Cryptography.ECDiffieHellmanPublicKey': ...
    def Import(self) -> 'System.Security.Cryptography.CngKey': ...
    def ExportExplicitParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self) -> 'System.Security.Cryptography.ECParameters': ...

class DSAOpenSsl(System.Security.Cryptography.DSA, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class ECDiffieHellmanOpenSsl(System.Security.Cryptography.ECDiffieHellman, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...

class ECDsaOpenSsl(System.Security.Cryptography.ECDsa, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...

class RSAOpenSsl(System.Security.Cryptography.RSA, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...

class SafeEvpPKeyHandle(System.Runtime.InteropServices.SafeHandle, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr', ownsHandle: 'bool') -> None: ...
    OpenSslVersion: 'int' = ...
    IsInvalid: 'bool' = ...
    @staticmethod
    def OpenPrivateKeyFromEngine(engineName: 'str', keyId: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    @staticmethod
    def OpenPublicKeyFromEngine(engineName: 'str', keyId: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    @staticmethod
    def OpenKeyFromProvider(providerName: 'str', keyUri: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def DuplicateHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...

class RC2CryptoServiceProvider(System.Security.Cryptography.RC2, System.IDisposable):
    def __init__(self) -> None: ...
    EffectiveKeySize: 'int' = ...
    UseSalt: 'bool' = ...
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class RSACryptoServiceProvider(System.Security.Cryptography.RSA, System.IDisposable, System.Security.Cryptography.ICspAsymmetricAlgorithm, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int') -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int', parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    PersistKeyInCsp: 'bool' = ...
    PublicOnly: 'bool' = ...
    UseMachineKeyStore: 'bool' = ...
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @overload
    def Decrypt(self, rgb: 'List[int]', fOAEP: 'bool') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def DecryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    @overload
    def Encrypt(self, rgb: 'List[int]', fOAEP: 'bool') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def EncryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportCspBlob(self, keyBlob: 'List[int]') -> None: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def SignData(self, buffer: 'List[int]', offset: 'int', count: 'int', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignData(self, inputStream: 'System.IO.Stream', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignHash(self, rgbHash: 'List[int]', str: 'str') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    def VerifyData(self, buffer: 'List[int]', halg: 'Any', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, rgbHash: 'List[int]', str: 'str', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...

class TripleDESCng(System.Security.Cryptography.TripleDES, System.IDisposable, System.Security.Cryptography.ICngSymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keyName: 'str') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> None: ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class TripleDESCryptoServiceProvider(System.Security.Cryptography.TripleDES, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class SP800108HmacCounterKdf(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'List[int]', context: 'List[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'str', context: 'str', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveBytes(key: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'List[int]', context: 'List[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[int]', context: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    @overload
    def DeriveKey(self, label: 'System.ReadOnlySpan[System.Char]', context: 'System.ReadOnlySpan[System.Char]', destination: 'System.Span[int]') -> None: ...
    @overload
    def DeriveKey(self, label: 'str', context: 'str', derivedKeyLengthInBytes: 'int') -> 'List[int]': ...
    def Dispose(self) -> None: ...

class Aes(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.Aes': ...
    @staticmethod
    @overload
    def Create(algorithmName: 'str') -> 'System.Security.Cryptography.Aes': ...

class AesCcm(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    NonceByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    TagByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    IsSupported: 'bool' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class AesCryptoServiceProvider(System.Security.Cryptography.Aes, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class AesGcm(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', tagSizeInBytes: 'int') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', tagSizeInBytes: 'int') -> None: ...
    NonceByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    TagSizeInBytes: 'Optional[int]' = ...
    IsSupported: 'bool' = ...
    TagByteSizes: 'System.Security.Cryptography.KeySizes' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class AesManaged(System.Security.Cryptography.Aes, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class AsnEncodedData:
    @overload
    def __init__(self, rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, rawData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid', rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, oid: 'str', rawData: 'List[int]') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid', rawData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, oid: 'str', rawData: 'System.ReadOnlySpan[int]') -> None: ...
    Oid: 'System.Security.Cryptography.Oid' = ...
    RawData: 'List[int]' = ...
    def CopyFrom(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    def Format(self, multiLine: 'bool') -> 'str': ...

class AsnEncodedDataCollection(System.Collections.ICollection, System.Collections.IEnumerable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    __getitem__: 'System.Security.Cryptography.AsnEncodedData' = ...
    Count: 'int' = ...
    IsSynchronized: 'bool' = ...
    SyncRoot: 'Any' = ...
    def Add(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> 'int': ...
    def Remove(self, asnEncodedData: 'System.Security.Cryptography.AsnEncodedData') -> None: ...
    def GetEnumerator(self) -> 'System.Security.Cryptography.AsnEncodedDataEnumerator': ...
    def CopyTo(self, array: 'List[System.Security.Cryptography.AsnEncodedData]', index: 'int') -> None: ...

class AsnEncodedDataEnumerator(System.Collections.IEnumerator):
    Current: 'System.Security.Cryptography.AsnEncodedData' = ...
    def MoveNext(self) -> 'bool': ...
    def Reset(self) -> None: ...

class AsymmetricAlgorithm(System.IDisposable):
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    SignatureAlgorithm: 'str' = ...
    KeyExchangeAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.AsymmetricAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.AsymmetricAlgorithm': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    def ExportPkcs8PrivateKey(self) -> 'List[int]': ...
    def ExportSubjectPublicKeyInfo(self) -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    def ExportPkcs8PrivateKeyPem(self) -> 'str': ...
    @overload
    def ExportEncryptedPkcs8PrivateKeyPem(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'str': ...
    @overload
    def ExportEncryptedPkcs8PrivateKeyPem(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'str': ...
    def ExportSubjectPublicKeyInfoPem(self) -> 'str': ...
    def TryExportSubjectPublicKeyInfoPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKeyPem(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKeyPem(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...

class AsymmetricKeyExchangeDeformatter:
    Parameters: 'str' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def DecryptKeyExchange(self, rgb: 'List[int]') -> 'List[int]': ...

class AsymmetricKeyExchangeFormatter:
    Parameters: 'str' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, data: 'List[int]') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, data: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...

class AsymmetricSignatureDeformatter:
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    @overload
    def VerifySignature(self, hash: 'System.Security.Cryptography.HashAlgorithm', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class AsymmetricSignatureFormatter:
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    @overload
    def CreateSignature(self, hash: 'System.Security.Cryptography.HashAlgorithm') -> 'List[int]': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class AuthenticationTagMismatchException(System.Security.Cryptography.CryptographicException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...

class FromBase64TransformMode(enum.Enum):
    IgnoreWhiteSpaces = ...
    DoNotIgnoreWhiteSpaces = ...

class ToBase64Transform(System.Security.Cryptography.ICryptoTransform, System.IDisposable):
    def __init__(self) -> None: ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...

class FromBase64Transform(System.Security.Cryptography.ICryptoTransform, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, whitespaces: 'System.Security.Cryptography.FromBase64TransformMode') -> None: ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...

class ChaCha20Poly1305(System.IDisposable):
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def Encrypt(self, nonce: 'List[int]', plaintext: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Encrypt(self, nonce: 'System.ReadOnlySpan[int]', plaintext: 'System.ReadOnlySpan[int]', ciphertext: 'System.Span[int]', tag: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'List[int]', ciphertext: 'List[int]', tag: 'List[int]', plaintext: 'List[int]', associatedData: 'List[int]') -> None: ...
    @overload
    def Decrypt(self, nonce: 'System.ReadOnlySpan[int]', ciphertext: 'System.ReadOnlySpan[int]', tag: 'System.ReadOnlySpan[int]', plaintext: 'System.Span[int]', associatedData: 'System.ReadOnlySpan[int]') -> None: ...
    def Dispose(self) -> None: ...

class CipherMode(enum.Enum):
    CBC = ...
    ECB = ...
    OFB = ...
    CFB = ...
    CTS = ...

class CngAlgorithm(System.IEquatable[System.Security.Cryptography.CngAlgorithm]):
    def __init__(self, algorithm: 'str') -> None: ...
    Algorithm: 'str' = ...
    Rsa: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellman: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP256: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP384: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDiffieHellmanP521: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsa: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP256: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP384: 'System.Security.Cryptography.CngAlgorithm' = ...
    ECDsaP521: 'System.Security.Cryptography.CngAlgorithm' = ...
    MD5: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha1: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha256: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha384: 'System.Security.Cryptography.CngAlgorithm' = ...
    Sha512: 'System.Security.Cryptography.CngAlgorithm' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngAlgorithm') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngAlgorithmGroup(System.IEquatable[System.Security.Cryptography.CngAlgorithmGroup]):
    def __init__(self, algorithmGroup: 'str') -> None: ...
    AlgorithmGroup: 'str' = ...
    DiffieHellman: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    Dsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ECDiffieHellman: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ECDsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    Rsa: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngAlgorithmGroup') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngExportPolicies(enum.Enum):
    None = ...
    AllowExport = ...
    AllowPlaintextExport = ...
    AllowArchiving = ...
    AllowPlaintextArchiving = ...

class CngKeyBlobFormat(System.IEquatable[System.Security.Cryptography.CngKeyBlobFormat]):
    def __init__(self, format: 'str') -> None: ...
    Format: 'str' = ...
    EccPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccFullPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    EccFullPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    GenericPrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    GenericPublicBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    OpaqueTransportBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    Pkcs8PrivateBlob: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngKeyCreationOptions(enum.Enum):
    None = ...
    MachineKey = ...
    OverwriteExistingKey = ...
    PreferVbs = ...
    RequireVbs = ...
    UsePerBootKey = ...

class CngKeyCreationParameters:
    def __init__(self) -> None: ...
    ExportPolicy: 'Optional[System.Security.Cryptography.CngExportPolicies]' = ...
    KeyCreationOptions: 'System.Security.Cryptography.CngKeyCreationOptions' = ...
    KeyUsage: 'Optional[System.Security.Cryptography.CngKeyUsages]' = ...
    Parameters: 'System.Security.Cryptography.CngPropertyCollection' = ...
    ParentWindowHandle: 'System.IntPtr' = ...
    Provider: 'System.Security.Cryptography.CngProvider' = ...
    UIPolicy: 'System.Security.Cryptography.CngUIPolicy' = ...

class CngKeyHandleOpenOptions(enum.Enum):
    None = ...
    EphemeralKey = ...

class CngKeyOpenOptions(enum.Enum):
    None = ...
    UserKey = ...
    MachineKey = ...
    Silent = ...

class CngKeyUsages(enum.Enum):
    None = ...
    Decryption = ...
    Signing = ...
    KeyAgreement = ...
    AllUsages = ...

class CngProperty(System.ValueType, System.IEquatable[System.Security.Cryptography.CngProperty]):
    def __init__(self, name: 'str', value: 'List[int]', options: 'System.Security.Cryptography.CngPropertyOptions') -> None: ...
    Name: 'str' = ...
    Options: 'System.Security.Cryptography.CngPropertyOptions' = ...
    def GetValue(self) -> 'List[int]': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngProperty') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class CngPropertyCollection(System.Collections.ObjectModel.Collection[System.Security.Cryptography.CngProperty], System.Collections.Generic.IList[System.Security.Cryptography.CngProperty], System.Collections.Generic.ICollection[System.Security.Cryptography.CngProperty], List[System.Security.Cryptography.CngProperty], System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, List[System.Security.Cryptography.CngProperty], System.Collections.Generic.IReadOnlyCollection[System.Security.Cryptography.CngProperty]):
    def __init__(self) -> None: ...

class CngPropertyOptions(enum.Enum):
    None = ...
    CustomProperty = ...
    Persist = ...

class CngProvider(System.IEquatable[System.Security.Cryptography.CngProvider]):
    def __init__(self, provider: 'str') -> None: ...
    Provider: 'str' = ...
    MicrosoftPlatformCryptoProvider: 'System.Security.Cryptography.CngProvider' = ...
    MicrosoftSmartCardKeyStorageProvider: 'System.Security.Cryptography.CngProvider' = ...
    MicrosoftSoftwareKeyStorageProvider: 'System.Security.Cryptography.CngProvider' = ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.CngProvider') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class CngUIPolicy:
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str', useContext: 'str') -> None: ...
    @overload
    def __init__(self, protectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels', friendlyName: 'str', description: 'str', useContext: 'str', creationTitle: 'str') -> None: ...
    ProtectionLevel: 'System.Security.Cryptography.CngUIProtectionLevels' = ...
    FriendlyName: 'str' = ...
    Description: 'str' = ...
    UseContext: 'str' = ...
    CreationTitle: 'str' = ...

class CngUIProtectionLevels(enum.Enum):
    None = ...
    ProtectKey = ...
    ForceHighProtection = ...

class CryptographicOperations:
    @staticmethod
    def FixedTimeEquals(left: 'System.ReadOnlySpan[int]', right: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @staticmethod
    def ZeroMemory(buffer: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    def TryHashData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def HashDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    def TryHmacData(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def HmacDataAsync(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class CryptographicUnexpectedOperationException(System.Security.Cryptography.CryptographicException, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, message: 'str') -> None: ...
    @overload
    def __init__(self, message: 'str', inner: 'System.Exception') -> None: ...
    @overload
    def __init__(self, format: 'str', insert: 'str') -> None: ...

class CryptoConfig:
    def __init__(self) -> None: ...
    AllowOnlyFipsAlgorithms: 'bool' = ...
    @staticmethod
    def AddAlgorithm(algorithm: 'System.Type', names: 'List[str]') -> None: ...
    @staticmethod
    @overload
    def CreateFromName(name: 'str', args: 'List[Any]') -> 'Any': ...
    @staticmethod
    @overload
    def CreateFromName(name: 'str') -> 'Any': ...
    @staticmethod
    def AddOID(oid: 'str', names: 'List[str]') -> None: ...
    @staticmethod
    def MapNameToOID(name: 'str') -> 'str': ...
    @staticmethod
    def EncodeOID(str: 'str') -> 'List[int]': ...

class CryptoStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, stream: 'System.IO.Stream', transform: 'System.Security.Cryptography.ICryptoTransform', mode: 'System.Security.Cryptography.CryptoStreamMode') -> None: ...
    @overload
    def __init__(self, stream: 'System.IO.Stream', transform: 'System.Security.Cryptography.ICryptoTransform', mode: 'System.Security.Cryptography.CryptoStreamMode', leaveOpen: 'bool') -> None: ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    HasFlushedFinalBlock: 'bool' = ...
    def FlushFinalBlock(self) -> None: ...
    def FlushFinalBlockAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    def SetLength(self, value: 'int') -> None: ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    def WriteByte(self, value: 'int') -> None: ...
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def CopyTo(self, destination: 'System.IO.Stream', bufferSize: 'int') -> None: ...
    def CopyToAsync(self, destination: 'System.IO.Stream', bufferSize: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def Clear(self) -> None: ...
    def DisposeAsync(self) -> 'System.Threading.Tasks.ValueTask': ...

class CryptoStreamMode(enum.Enum):
    Read = ...
    Write = ...

class CspParameters:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int') -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int', strProviderNameIn: 'str') -> None: ...
    @overload
    def __init__(self, dwTypeIn: 'int', strProviderNameIn: 'str', strContainerNameIn: 'str') -> None: ...
    ProviderType: 'int' = ...
    ProviderName: 'str' = ...
    KeyContainerName: 'str' = ...
    KeyNumber: 'int' = ...
    Flags: 'System.Security.Cryptography.CspProviderFlags' = ...
    KeyPassword: 'System.Security.SecureString' = ...
    ParentWindowHandle: 'System.IntPtr' = ...

class CspProviderFlags(enum.Enum):
    NoFlags = ...
    UseMachineKeyStore = ...
    UseDefaultKeyContainer = ...
    UseNonExportableKey = ...
    UseExistingKey = ...
    UseArchivableKey = ...
    UseUserProtectedKey = ...
    NoPrompt = ...
    CreateEphemeralKey = ...

class DeriveBytes(System.IDisposable):
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def Reset(self) -> None: ...
    def Dispose(self) -> None: ...

class DES(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.DES': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.DES': ...
    @staticmethod
    def IsWeakKey(rgbKey: 'List[int]') -> 'bool': ...
    @staticmethod
    def IsSemiWeakKey(rgbKey: 'List[int]') -> 'bool': ...

class DSA(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create(keySizeInBits: 'int') -> 'System.Security.Cryptography.DSA': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.DSAParameters') -> 'System.Security.Cryptography.DSA': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    @overload
    def CreateSignature(self, rgbHash: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifySignature(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @overload
    def VerifySignature(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def TryCreateSignature(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryCreateSignature(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def GetMaxSignatureSize(self, signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class DSAParameters(System.ValueType):
    P: 'List[int]' = ...
    Q: 'List[int]' = ...
    G: 'List[int]' = ...
    Y: 'List[int]' = ...
    J: 'List[int]' = ...
    X: 'List[int]' = ...
    Seed: 'List[int]' = ...
    Counter: 'int' = ...

class DSASignatureDeformatter(System.Security.Cryptography.AsymmetricSignatureDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class DSASignatureFormat(enum.Enum):
    IeeeP1363FixedFieldConcatenation = ...
    Rfc3279DerSequence = ...

class DSASignatureFormatter(System.Security.Cryptography.AsymmetricSignatureFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class ECAlgorithm(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportECPrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ExportECPrivateKey(self) -> 'List[int]': ...
    def TryExportECPrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ExportECPrivateKeyPem(self) -> 'str': ...
    def TryExportECPrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...

class ECCurve(System.ValueType):
    A: 'List[int]' = ...
    B: 'List[int]' = ...
    G: 'System.Security.Cryptography.ECPoint' = ...
    Order: 'List[int]' = ...
    Cofactor: 'List[int]' = ...
    Seed: 'List[int]' = ...
    CurveType: 'System.Security.Cryptography.ECCurve.ECCurveType' = ...
    Hash: 'Optional[System.Security.Cryptography.HashAlgorithmName]' = ...
    Polynomial: 'List[int]' = ...
    Prime: 'List[int]' = ...
    Oid: 'System.Security.Cryptography.Oid' = ...
    IsPrime: 'bool' = ...
    IsCharacteristic2: 'bool' = ...
    IsExplicit: 'bool' = ...
    IsNamed: 'bool' = ...
    @staticmethod
    def CreateFromOid(curveOid: 'System.Security.Cryptography.Oid') -> 'System.Security.Cryptography.ECCurve': ...
    @staticmethod
    def CreateFromFriendlyName(oidFriendlyName: 'str') -> 'System.Security.Cryptography.ECCurve': ...
    @staticmethod
    def CreateFromValue(oidValue: 'str') -> 'System.Security.Cryptography.ECCurve': ...
    def Validate(self) -> None: ...

class ECDiffieHellman(System.Security.Cryptography.ECAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(curve: 'System.Security.Cryptography.ECCurve') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.ECParameters') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    @staticmethod
    @overload
    def Create(algorithm: 'str') -> 'System.Security.Cryptography.ECDiffieHellman': ...
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]') -> 'List[int]': ...
    @overload
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyTls(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', prfLabel: 'List[int]', prfSeed: 'List[int]') -> 'List[int]': ...
    def DeriveRawSecretAgreement(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class ECDiffieHellmanKeyDerivationFunction(enum.Enum):
    Hash = ...
    Hmac = ...
    Tls = ...

class ECDiffieHellmanPublicKey(System.IDisposable):
    def Dispose(self) -> None: ...
    def ToByteArray(self) -> 'List[int]': ...
    def ToXmlString(self) -> 'str': ...
    def ExportParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def ExportExplicitParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportSubjectPublicKeyInfo(self) -> 'List[int]': ...

class ECDsa(System.Security.Cryptography.ECAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(curve: 'System.Security.Cryptography.ECCurve') -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.ECParameters') -> 'System.Security.Cryptography.ECDsa': ...
    @staticmethod
    @overload
    def Create(algorithm: 'str') -> 'System.Security.Cryptography.ECDsa': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'bool': ...
    @overload
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> Tuple['bool', 'System.Int32']: ...
    def GetMaxSignatureSize(self, signatureFormat: 'System.Security.Cryptography.DSASignatureFormat') -> 'int': ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class ECKeyXmlFormat(enum.Enum):
    Rfc4050 = ...

class ECParameters(System.ValueType):
    Q: 'System.Security.Cryptography.ECPoint' = ...
    D: 'List[int]' = ...
    Curve: 'System.Security.Cryptography.ECCurve' = ...
    def Validate(self) -> None: ...

class ECPoint(System.ValueType):
    X: 'List[int]' = ...
    Y: 'List[int]' = ...

class HashAlgorithm(System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSize: 'int' = ...
    Hash: 'List[int]' = ...
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.HashAlgorithm': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.HashAlgorithm': ...
    @overload
    def ComputeHash(self, buffer: 'List[int]') -> 'List[int]': ...
    @overload
    def ComputeHash(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    @overload
    def ComputeHash(self, inputStream: 'System.IO.Stream') -> 'List[int]': ...
    def TryComputeHash(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ComputeHashAsync(self, inputStream: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[List[int]]': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...
    def Initialize(self) -> None: ...

class HashAlgorithmName(System.ValueType, System.IEquatable[System.Security.Cryptography.HashAlgorithmName]):
    def __init__(self, name: 'str') -> None: ...
    MD5: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA1: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA256: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA384: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA512: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_256: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_384: 'System.Security.Cryptography.HashAlgorithmName' = ...
    SHA3_512: 'System.Security.Cryptography.HashAlgorithmName' = ...
    Name: 'str' = ...
    def ToString(self) -> 'str': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.HashAlgorithmName') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    @staticmethod
    def TryFromOid(oidValue: 'str') -> Tuple['bool', 'System.Security.Cryptography.HashAlgorithmName']: ...
    @staticmethod
    def FromOid(oidValue: 'str') -> 'System.Security.Cryptography.HashAlgorithmName': ...

class HKDF:
    @staticmethod
    @overload
    def Extract(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'List[int]', salt: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def Extract(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', prk: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def Expand(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', prk: 'List[int]', outputLength: 'int', info: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def Expand(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', prk: 'System.ReadOnlySpan[int]', output: 'System.Span[int]', info: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def DeriveKey(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'List[int]', outputLength: 'int', salt: 'List[int]', info: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def DeriveKey(hashAlgorithmName: 'System.Security.Cryptography.HashAlgorithmName', ikm: 'System.ReadOnlySpan[int]', output: 'System.Span[int]', salt: 'System.ReadOnlySpan[int]', info: 'System.ReadOnlySpan[int]') -> None: ...

class HMAC(System.Security.Cryptography.KeyedHashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashName: 'str' = ...
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.HMAC': ...
    @staticmethod
    @overload
    def Create(algorithmName: 'str') -> 'System.Security.Cryptography.HMAC': ...
    def Initialize(self) -> None: ...

class HMACMD5(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA1(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'List[int]', useManagedSha1: 'bool') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA256(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA384(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    ProduceLegacyHmacValues: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA512(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    ProduceLegacyHmacValues: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_256(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_384(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class HMACSHA3_512(System.Security.Cryptography.HMAC, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'List[int]') -> None: ...
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    Key: 'List[int]' = ...
    def Initialize(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class ICryptoTransform(System.IDisposable):
    InputBlockSize: 'int' = ...
    OutputBlockSize: 'int' = ...
    CanTransformMultipleBlocks: 'bool' = ...
    CanReuseTransform: 'bool' = ...
    def TransformBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int', outputBuffer: 'List[int]', outputOffset: 'int') -> 'int': ...
    def TransformFinalBlock(self, inputBuffer: 'List[int]', inputOffset: 'int', inputCount: 'int') -> 'List[int]': ...

class ICspAsymmetricAlgorithm:
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ImportCspBlob(self, rawData: 'List[int]') -> None: ...

class IncrementalHash(System.IDisposable):
    HashLengthInBytes: 'int' = ...
    AlgorithmName: 'System.Security.Cryptography.HashAlgorithmName' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self) -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> 'int': ...
    def TryGetHashAndReset(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def GetCurrentHash(self) -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> 'int': ...
    def TryGetCurrentHash(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def Clone(self) -> 'System.Security.Cryptography.IncrementalHash': ...
    def Dispose(self) -> None: ...
    @staticmethod
    def CreateHash(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'System.Security.Cryptography.IncrementalHash': ...
    @staticmethod
    @overload
    def CreateHMAC(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'List[int]') -> 'System.Security.Cryptography.IncrementalHash': ...
    @staticmethod
    @overload
    def CreateHMAC(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', key: 'System.ReadOnlySpan[int]') -> 'System.Security.Cryptography.IncrementalHash': ...

class KeyedHashAlgorithm(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.KeyedHashAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.KeyedHashAlgorithm': ...

class KeyNumber(enum.Enum):
    Exchange = ...
    Signature = ...

class KeySizes:
    def __init__(self, minSize: 'int', maxSize: 'int', skipSize: 'int') -> None: ...
    MinSize: 'int' = ...
    MaxSize: 'int' = ...
    SkipSize: 'int' = ...

class Kmac128(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Kmac128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class Kmac256(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Kmac256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class KmacXof128(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.KmacXof128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class KmacXof256(System.IDisposable):
    @overload
    def __init__(self, key: 'List[int]', customizationString: 'List[int]') -> None: ...
    @overload
    def __init__(self, key: 'System.ReadOnlySpan[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.KmacXof256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'List[int]', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(key: 'System.ReadOnlySpan[int]', source: 'System.IO.Stream', destination: 'System.Span[int]', customizationString: 'System.ReadOnlySpan[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'List[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'List[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', outputLength: 'int', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(key: 'System.ReadOnlyMemory[int]', source: 'System.IO.Stream', destination: 'System.Memory[int]', customizationString: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...

class MaskGenerationMethod:
    def GenerateMask(self, rgbSeed: 'List[int]', cbReturn: 'int') -> 'List[int]': ...

class MD5(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.MD5': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.MD5': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class MD5CryptoServiceProvider(System.Security.Cryptography.MD5, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class Oid:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, oid: 'str') -> None: ...
    @overload
    def __init__(self, value: 'str', friendlyName: 'str') -> None: ...
    @overload
    def __init__(self, oid: 'System.Security.Cryptography.Oid') -> None: ...
    Value: 'str' = ...
    FriendlyName: 'str' = ...
    @staticmethod
    def FromFriendlyName(friendlyName: 'str', group: 'System.Security.Cryptography.OidGroup') -> 'System.Security.Cryptography.Oid': ...
    @staticmethod
    def FromOidValue(oidValue: 'str', group: 'System.Security.Cryptography.OidGroup') -> 'System.Security.Cryptography.Oid': ...

class OidCollection(System.Collections.ICollection, System.Collections.IEnumerable):
    def __init__(self) -> None: ...
    __getitem__: 'System.Security.Cryptography.Oid' = ...
    __getitem__: 'System.Security.Cryptography.Oid' = ...
    Count: 'int' = ...
    IsSynchronized: 'bool' = ...
    SyncRoot: 'Any' = ...
    def Add(self, oid: 'System.Security.Cryptography.Oid') -> 'int': ...
    def GetEnumerator(self) -> 'System.Security.Cryptography.OidEnumerator': ...
    def CopyTo(self, array: 'List[System.Security.Cryptography.Oid]', index: 'int') -> None: ...

class OidEnumerator(System.Collections.IEnumerator):
    Current: 'System.Security.Cryptography.Oid' = ...
    def MoveNext(self) -> 'bool': ...
    def Reset(self) -> None: ...

class OidGroup(enum.Enum):
    All = ...
    HashAlgorithm = ...
    EncryptionAlgorithm = ...
    PublicKeyAlgorithm = ...
    SignatureAlgorithm = ...
    Attribute = ...
    ExtensionOrAttribute = ...
    EnhancedKeyUsage = ...
    Policy = ...
    Template = ...
    KeyDerivationFunction = ...

class PaddingMode(enum.Enum):
    None = ...
    PKCS7 = ...
    Zeros = ...
    ANSIX923 = ...
    ISO10126 = ...

class PasswordDeriveBytes(System.Security.Cryptography.DeriveBytes, System.IDisposable):
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', strHashName: 'str', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', hashName: 'str', iterations: 'int') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, strPassword: 'str', rgbSalt: 'List[int]', strHashName: 'str', iterations: 'int', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', hashName: 'str', iterations: 'int', cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    HashName: 'str' = ...
    IterationCount: 'int' = ...
    Salt: 'List[int]' = ...
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def Reset(self) -> None: ...
    def CryptDeriveKey(self, algname: 'str', alghashname: 'str', keySize: 'int', rgbIV: 'List[int]') -> 'List[int]': ...

class PbeEncryptionAlgorithm(enum.Enum):
    Unknown = ...
    Aes128Cbc = ...
    Aes192Cbc = ...
    Aes256Cbc = ...
    TripleDes3KeyPkcs12 = ...

class PbeParameters:
    def __init__(self, encryptionAlgorithm: 'System.Security.Cryptography.PbeEncryptionAlgorithm', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', iterationCount: 'int') -> None: ...
    EncryptionAlgorithm: 'System.Security.Cryptography.PbeEncryptionAlgorithm' = ...
    HashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    IterationCount: 'int' = ...

class PemEncoding:
    @staticmethod
    def Find(pemData: 'System.ReadOnlySpan[System.Char]') -> 'System.Security.Cryptography.PemFields': ...
    @staticmethod
    def TryFind(pemData: 'System.ReadOnlySpan[System.Char]') -> Tuple['bool', 'System.Security.Cryptography.PemFields']: ...
    @staticmethod
    def GetEncodedSize(labelLength: 'int', dataLength: 'int') -> 'int': ...
    @staticmethod
    def TryWrite(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]', destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    def Write(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]') -> 'List[System.Char]': ...
    @staticmethod
    def WriteString(label: 'System.ReadOnlySpan[System.Char]', data: 'System.ReadOnlySpan[int]') -> 'str': ...

class PemFields(System.ValueType):
    Location: 'System.Range' = ...
    Label: 'System.Range' = ...
    Base64Data: 'System.Range' = ...
    DecodedDataLength: 'int' = ...

class PKCS1MaskGenerationMethod(System.Security.Cryptography.MaskGenerationMethod):
    def __init__(self) -> None: ...
    HashName: 'str' = ...
    def GenerateMask(self, rgbSeed: 'List[int]', cbReturn: 'int') -> 'List[int]': ...

class RandomNumberGenerator(System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RandomNumberGenerator': ...
    @staticmethod
    @overload
    def Create(rngName: 'str') -> 'System.Security.Cryptography.RandomNumberGenerator': ...
    def Dispose(self) -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def GetBytes(self, data: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def GetBytes(count: 'int') -> 'List[int]': ...
    @overload
    def GetNonZeroBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'System.Span[int]') -> None: ...
    @staticmethod
    def Fill(data: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def GetInt32(fromInclusive: 'int', toExclusive: 'int') -> 'int': ...
    @staticmethod
    @overload
    def GetInt32(toExclusive: 'int') -> 'int': ...
    @staticmethod
    @overload
    def GetItems(choices: 'System.ReadOnlySpan[T]', destination: 'System.Span[T]') -> None: ...
    @staticmethod
    @overload
    def GetItems(choices: 'System.ReadOnlySpan[T]', length: 'int') -> 'List[T]': ...
    @staticmethod
    def GetString(choices: 'System.ReadOnlySpan[System.Char]', length: 'int') -> 'str': ...
    @staticmethod
    @overload
    def GetHexString(destination: 'System.Span[System.Char]', lowercase: 'bool') -> None: ...
    @staticmethod
    @overload
    def GetHexString(stringLength: 'int', lowercase: 'bool') -> 'str': ...
    @staticmethod
    def Shuffle(values: 'System.Span[T]') -> None: ...

class RC2(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    KeySize: 'int' = ...
    EffectiveKeySize: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RC2': ...
    @staticmethod
    @overload
    def Create(AlgName: 'str') -> 'System.Security.Cryptography.RC2': ...

class Rijndael(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.Rijndael': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.Rijndael': ...

class RijndaelManaged(System.Security.Cryptography.Rijndael, System.IDisposable):
    def __init__(self) -> None: ...
    BlockSize: 'int' = ...
    FeedbackSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class Rfc2898DeriveBytes(System.Security.Cryptography.DeriveBytes, System.IDisposable):
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'List[int]', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int', iterations: 'int') -> None: ...
    @overload
    def __init__(self, password: 'str', saltSize: 'int', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    HashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    IterationCount: 'int' = ...
    Salt: 'List[int]' = ...
    def GetBytes(self, cb: 'int') -> 'List[int]': ...
    def CryptDeriveKey(self, algname: 'str', alghashname: 'str', keySize: 'int', rgbIV: 'List[int]') -> 'List[int]': ...
    def Reset(self) -> None: ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'List[int]', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[int]', salt: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'str', salt: 'List[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[System.Char]', salt: 'System.ReadOnlySpan[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def Pbkdf2(password: 'System.ReadOnlySpan[System.Char]', salt: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', iterations: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> None: ...

class RNGCryptoServiceProvider(System.Security.Cryptography.RandomNumberGenerator, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, str: 'str') -> None: ...
    @overload
    def __init__(self, rgb: 'List[int]') -> None: ...
    @overload
    def __init__(self, cspParams: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetBytes(self, data: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def GetBytes(self, data: 'System.Span[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'List[int]') -> None: ...
    @overload
    def GetNonZeroBytes(self, data: 'System.Span[int]') -> None: ...

class RSA(System.Security.Cryptography.AsymmetricAlgorithm, System.IDisposable):
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(keySizeInBits: 'int') -> 'System.Security.Cryptography.RSA': ...
    @staticmethod
    @overload
    def Create(parameters: 'System.Security.Cryptography.RSAParameters') -> 'System.Security.Cryptography.RSA': ...
    def GetMaxOutputSize(self) -> 'int': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'System.ReadOnlySpan[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'int': ...
    @overload
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'System.ReadOnlySpan[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'int': ...
    @overload
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'int': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def TryDecrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TryEncrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    def DecryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    def EncryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'int': ...
    def TrySignData(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def ExportRSAPrivateKey(self) -> 'List[int]': ...
    def TryExportRSAPrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportRSAPublicKey(self) -> 'List[int]': ...
    def TryExportRSAPublicKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportSubjectPublicKeyInfo(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ImportSubjectPublicKeyInfo(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportRSAPublicKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportRSAPrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    def ImportFromPem(self, input: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', password: 'System.ReadOnlySpan[System.Char]') -> None: ...
    @overload
    def ImportFromEncryptedPem(self, input: 'System.ReadOnlySpan[System.Char]', passwordBytes: 'System.ReadOnlySpan[int]') -> None: ...
    def ExportRSAPrivateKeyPem(self) -> 'str': ...
    def ExportRSAPublicKeyPem(self) -> 'str': ...
    def TryExportRSAPrivateKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportRSAPublicKeyPem(self, destination: 'System.Span[System.Char]') -> Tuple['bool', 'System.Int32']: ...
    def FromXmlString(self, xmlString: 'str') -> None: ...
    def ToXmlString(self, includePrivateParameters: 'bool') -> 'str': ...

class RSAEncryptionPadding(System.IEquatable[System.Security.Cryptography.RSAEncryptionPadding]):
    Pkcs1: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA1: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA256: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA384: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA512: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_256: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_384: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    OaepSHA3_512: 'System.Security.Cryptography.RSAEncryptionPadding' = ...
    Mode: 'System.Security.Cryptography.RSAEncryptionPaddingMode' = ...
    OaepHashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName' = ...
    @staticmethod
    def CreateOaep(hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName') -> 'System.Security.Cryptography.RSAEncryptionPadding': ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'bool': ...
    def ToString(self) -> 'str': ...

class RSAEncryptionPaddingMode(enum.Enum):
    Pkcs1 = ...
    Oaep = ...

class RSAOAEPKeyExchangeDeformatter(System.Security.Cryptography.AsymmetricKeyExchangeDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameters: 'str' = ...
    def DecryptKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...

class RSAOAEPKeyExchangeFormatter(System.Security.Cryptography.AsymmetricKeyExchangeFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameter: 'List[int]' = ...
    Parameters: 'str' = ...
    Rng: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...

class RSAParameters(System.ValueType):
    D: 'List[int]' = ...
    DP: 'List[int]' = ...
    DQ: 'List[int]' = ...
    Exponent: 'List[int]' = ...
    InverseQ: 'List[int]' = ...
    Modulus: 'List[int]' = ...
    P: 'List[int]' = ...
    Q: 'List[int]' = ...

class RSAPKCS1KeyExchangeDeformatter(System.Security.Cryptography.AsymmetricKeyExchangeDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    RNG: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    Parameters: 'str' = ...
    def DecryptKeyExchange(self, rgbIn: 'List[int]') -> 'List[int]': ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...

class RSAPKCS1KeyExchangeFormatter(System.Security.Cryptography.AsymmetricKeyExchangeFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    Parameters: 'str' = ...
    Rng: 'System.Security.Cryptography.RandomNumberGenerator' = ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]', symAlgType: 'System.Type') -> 'List[int]': ...
    @overload
    def CreateKeyExchange(self, rgbData: 'List[int]') -> 'List[int]': ...

class RSAPKCS1SignatureDeformatter(System.Security.Cryptography.AsymmetricSignatureDeformatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class RSAPKCS1SignatureFormatter(System.Security.Cryptography.AsymmetricSignatureFormatter):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetKey(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> None: ...
    def SetHashAlgorithm(self, strName: 'str') -> None: ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...

class RSASignaturePadding(System.IEquatable[System.Security.Cryptography.RSASignaturePadding]):
    Pkcs1: 'System.Security.Cryptography.RSASignaturePadding' = ...
    Pss: 'System.Security.Cryptography.RSASignaturePadding' = ...
    Mode: 'System.Security.Cryptography.RSASignaturePaddingMode' = ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def ToString(self) -> 'str': ...

class RSASignaturePaddingMode(enum.Enum):
    Pkcs1 = ...
    Pss = ...

class SHA1(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA1': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA1': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA1CryptoServiceProvider(System.Security.Cryptography.SHA1, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA1Managed(System.Security.Cryptography.SHA1, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA256(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA256': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA256': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA256CryptoServiceProvider(System.Security.Cryptography.SHA256, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA256Managed(System.Security.Cryptography.SHA256, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA384(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA384': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA384': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA384CryptoServiceProvider(System.Security.Cryptography.SHA384, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA384Managed(System.Security.Cryptography.SHA384, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA512(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SHA512': ...
    @staticmethod
    @overload
    def Create(hashName: 'str') -> 'System.Security.Cryptography.SHA512': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA512CryptoServiceProvider(System.Security.Cryptography.SHA512, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA512Managed(System.Security.Cryptography.SHA512, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...

class SHA3_256(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_256': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA3_384(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_384': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class SHA3_512(System.Security.Cryptography.HashAlgorithm, System.IDisposable, System.Security.Cryptography.ICryptoTransform):
    HashSizeInBits: 'int' = ...
    HashSizeInBytes: 'int' = ...
    IsSupported: 'bool' = ...
    @staticmethod
    def Create() -> 'System.Security.Cryptography.SHA3_512': ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> 'int': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream') -> 'List[int]': ...
    @staticmethod
    def TryHashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...

class Shake128(System.IDisposable):
    def __init__(self) -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def Read(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def Read(self, destination: 'System.Span[int]') -> None: ...
    def Reset(self) -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Shake128': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', outputLength: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class Shake256(System.IDisposable):
    def __init__(self) -> None: ...
    IsSupported: 'bool' = ...
    @overload
    def AppendData(self, data: 'List[int]') -> None: ...
    @overload
    def AppendData(self, data: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetHashAndReset(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetHashAndReset(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def GetCurrentHash(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def GetCurrentHash(self, destination: 'System.Span[int]') -> None: ...
    @overload
    def Read(self, outputLength: 'int') -> 'List[int]': ...
    @overload
    def Read(self, destination: 'System.Span[int]') -> None: ...
    def Reset(self) -> None: ...
    def Clone(self) -> 'System.Security.Cryptography.Shake256': ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'List[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', outputLength: 'int') -> 'List[int]': ...
    @staticmethod
    @overload
    def HashData(source: 'System.IO.Stream', destination: 'System.Span[int]') -> None: ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', destination: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def HashDataAsync(source: 'System.IO.Stream', outputLength: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[List[int]]': ...

class SignatureDescription:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, el: 'System.Security.SecurityElement') -> None: ...
    KeyAlgorithm: 'str' = ...
    DigestAlgorithm: 'str' = ...
    FormatterAlgorithm: 'str' = ...
    DeformatterAlgorithm: 'str' = ...
    def CreateDeformatter(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> 'System.Security.Cryptography.AsymmetricSignatureDeformatter': ...
    def CreateFormatter(self, key: 'System.Security.Cryptography.AsymmetricAlgorithm') -> 'System.Security.Cryptography.AsymmetricSignatureFormatter': ...
    def CreateDigest(self) -> 'System.Security.Cryptography.HashAlgorithm': ...

class SymmetricAlgorithm(System.IDisposable):
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.SymmetricAlgorithm': ...
    @staticmethod
    @overload
    def Create(algName: 'str') -> 'System.Security.Cryptography.SymmetricAlgorithm': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def Dispose(self) -> None: ...
    def Clear(self) -> None: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    def ValidKeySize(self, bitLength: 'int') -> 'bool': ...
    def GetCiphertextLengthEcb(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def GetCiphertextLengthCbc(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def GetCiphertextLengthCfb(self, plaintextLength: 'int', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    @overload
    def DecryptEcb(self, ciphertext: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryDecryptEcb(self, ciphertext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptEcb(self, plaintext: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryEncryptEcb(self, plaintext: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DecryptCbc(self, ciphertext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def DecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryDecryptCbc(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptCbc(self, plaintext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'List[int]': ...
    @overload
    def EncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> 'int': ...
    def TryEncryptCbc(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DecryptCfb(self, ciphertext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def DecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def DecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    def TryDecryptCfb(self, ciphertext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def EncryptCfb(self, plaintext: 'List[int]', iv: 'List[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def EncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'List[int]': ...
    @overload
    def EncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> 'int': ...
    def TryEncryptCfb(self, plaintext: 'System.ReadOnlySpan[int]', iv: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', paddingMode: 'System.Security.Cryptography.PaddingMode', feedbackSizeInBits: 'int') -> Tuple['bool', 'System.Int32']: ...

class TripleDES(System.Security.Cryptography.SymmetricAlgorithm, System.IDisposable):
    Key: 'List[int]' = ...
    @staticmethod
    @overload
    def Create() -> 'System.Security.Cryptography.TripleDES': ...
    @staticmethod
    @overload
    def Create(str: 'str') -> 'System.Security.Cryptography.TripleDES': ...
    @staticmethod
    def IsWeakKey(rgbKey: 'List[int]') -> 'bool': ...

class DSACng(System.Security.Cryptography.DSA, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    SignatureAlgorithm: 'str' = ...
    KeyExchangeAlgorithm: 'str' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class ECDiffieHellmanCng(System.Security.Cryptography.ECDiffieHellman, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    HashAlgorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    KeyDerivationFunction: 'System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction' = ...
    HmacKey: 'List[int]' = ...
    Label: 'List[int]' = ...
    SecretAppend: 'List[int]' = ...
    SecretPrepend: 'List[int]' = ...
    Seed: 'List[int]' = ...
    UseSecretAgreementAsHmacKey: 'bool' = ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def DeriveKeyFromHash(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyFromHmac(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', hmacKey: 'List[int]', secretPrepend: 'List[int]', secretAppend: 'List[int]') -> 'List[int]': ...
    def DeriveKeyTls(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey', prfLabel: 'List[int]', prfSeed: 'List[int]') -> 'List[int]': ...
    def DeriveRawSecretAgreement(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'List[int]': ...
    @overload
    def DeriveKeyMaterial(self, otherPartyPublicKey: 'System.Security.Cryptography.CngKey') -> 'List[int]': ...
    @overload
    def DeriveSecretAgreementHandle(self, otherPartyPublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey') -> 'Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle': ...
    @overload
    def DeriveSecretAgreementHandle(self, otherPartyPublicKey: 'System.Security.Cryptography.CngKey') -> 'Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle': ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    def FromXmlString(self, xml: 'str', format: 'System.Security.Cryptography.ECKeyXmlFormat') -> None: ...
    def ToXmlString(self, format: 'System.Security.Cryptography.ECKeyXmlFormat') -> 'str': ...

class ECDsaCng(System.Security.Cryptography.ECDsa, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    HashAlgorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...
    def ExportExplicitParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    def TrySignHash(self, source: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def FromXmlString(self, xml: 'str', format: 'System.Security.Cryptography.ECKeyXmlFormat') -> None: ...
    @overload
    def SignData(self, data: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    @overload
    def SignData(self, data: 'System.IO.Stream') -> 'List[int]': ...
    def ToXmlString(self, format: 'System.Security.Cryptography.ECKeyXmlFormat') -> 'str': ...
    @overload
    def VerifyData(self, data: 'List[int]', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'List[int]', offset: 'int', count: 'int', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyData(self, data: 'System.IO.Stream', signature: 'List[int]') -> 'bool': ...
    def GenerateKey(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...

class RSACng(System.Security.Cryptography.RSA, System.IDisposable, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, key: 'System.Security.Cryptography.CngKey') -> None: ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    Key: 'System.Security.Cryptography.CngKey' = ...
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def TryEncrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def TryDecrypt(self, data: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> Tuple['bool', 'System.Int32']: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    def ImportPkcs8PrivateKey(self, source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def ExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters') -> 'List[int]': ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def TryExportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', pbeParameters: 'System.Security.Cryptography.PbeParameters', destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    def TrySignHash(self, hash: 'System.ReadOnlySpan[int]', destination: 'System.Span[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> Tuple['bool', 'System.Int32']: ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'System.ReadOnlySpan[int]', signature: 'System.ReadOnlySpan[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...
    def TryExportPkcs8PrivateKey(self, destination: 'System.Span[int]') -> Tuple['bool', 'System.Int32']: ...

class AesCng(System.Security.Cryptography.Aes, System.IDisposable, System.Security.Cryptography.ICngSymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keyName: 'str') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> None: ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class CngKey(System.IDisposable):
    Algorithm: 'System.Security.Cryptography.CngAlgorithm' = ...
    AlgorithmGroup: 'System.Security.Cryptography.CngAlgorithmGroup' = ...
    ExportPolicy: 'System.Security.Cryptography.CngExportPolicies' = ...
    Handle: 'Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle' = ...
    IsEphemeral: 'bool' = ...
    IsMachineKey: 'bool' = ...
    KeyName: 'str' = ...
    KeySize: 'int' = ...
    KeyUsage: 'System.Security.Cryptography.CngKeyUsages' = ...
    ParentWindowHandle: 'System.IntPtr' = ...
    Provider: 'System.Security.Cryptography.CngProvider' = ...
    ProviderHandle: 'Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle' = ...
    UIPolicy: 'System.Security.Cryptography.CngUIPolicy' = ...
    UniqueName: 'str' = ...
    def Dispose(self) -> None: ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm', keyName: 'str') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Create(algorithm: 'System.Security.Cryptography.CngAlgorithm', keyName: 'str', creationParameters: 'System.Security.Cryptography.CngKeyCreationParameters') -> 'System.Security.Cryptography.CngKey': ...
    def Delete(self) -> None: ...
    @staticmethod
    @overload
    def Exists(keyName: 'str') -> 'bool': ...
    @staticmethod
    @overload
    def Exists(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> 'bool': ...
    @staticmethod
    @overload
    def Exists(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', options: 'System.Security.Cryptography.CngKeyOpenOptions') -> 'bool': ...
    def Export(self, format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'List[int]': ...
    @staticmethod
    @overload
    def Import(keyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Import(keyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat', provider: 'System.Security.Cryptography.CngProvider') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> 'System.Security.Cryptography.CngKey': ...
    @staticmethod
    @overload
    def Open(keyHandle: 'Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle', keyHandleOpenOptions: 'System.Security.Cryptography.CngKeyHandleOpenOptions') -> 'System.Security.Cryptography.CngKey': ...
    def GetProperty(self, name: 'str', options: 'System.Security.Cryptography.CngPropertyOptions') -> 'System.Security.Cryptography.CngProperty': ...
    def HasProperty(self, name: 'str', options: 'System.Security.Cryptography.CngPropertyOptions') -> 'bool': ...
    def SetProperty(self, property: 'System.Security.Cryptography.CngProperty') -> None: ...

class CspKeyContainerInfo:
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    Accessible: 'bool' = ...
    Exportable: 'bool' = ...
    HardwareDevice: 'bool' = ...
    KeyContainerName: 'str' = ...
    KeyNumber: 'System.Security.Cryptography.KeyNumber' = ...
    MachineKeyStore: 'bool' = ...
    Protected: 'bool' = ...
    ProviderName: 'str' = ...
    ProviderType: 'int' = ...
    RandomlyGenerated: 'bool' = ...
    Removable: 'bool' = ...
    UniqueKeyContainerName: 'str' = ...

class DESCryptoServiceProvider(System.Security.Cryptography.DES, System.IDisposable):
    def __init__(self) -> None: ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...

class DSACryptoServiceProvider(System.Security.Cryptography.DSA, System.IDisposable, System.Security.Cryptography.ICspAsymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int', parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    PersistKeyInCsp: 'bool' = ...
    PublicOnly: 'bool' = ...
    UseMachineKeyStore: 'bool' = ...
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportCspBlob(self, keyBlob: 'List[int]') -> None: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def SignData(self, inputStream: 'System.IO.Stream') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'List[int]': ...
    def VerifyData(self, rgbData: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...
    def SignHash(self, rgbHash: 'List[int]', str: 'str') -> 'List[int]': ...
    def VerifyHash(self, rgbHash: 'List[int]', str: 'str', rgbSignature: 'List[int]') -> 'bool': ...

class ECDiffieHellmanCngPublicKey(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.IDisposable):
    BlobFormat: 'System.Security.Cryptography.CngKeyBlobFormat' = ...
    def ToXmlString(self) -> 'str': ...
    @staticmethod
    def FromXmlString(xml: 'str') -> 'System.Security.Cryptography.ECDiffieHellmanCngPublicKey': ...
    @staticmethod
    def FromByteArray(publicKeyBlob: 'List[int]', format: 'System.Security.Cryptography.CngKeyBlobFormat') -> 'System.Security.Cryptography.ECDiffieHellmanPublicKey': ...
    def Import(self) -> 'System.Security.Cryptography.CngKey': ...
    def ExportExplicitParameters(self) -> 'System.Security.Cryptography.ECParameters': ...
    def ExportParameters(self) -> 'System.Security.Cryptography.ECParameters': ...

class DSAOpenSsl(System.Security.Cryptography.DSA, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def CreateSignature(self, rgbHash: 'List[int]') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.DSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.DSAParameters') -> None: ...
    def VerifySignature(self, rgbHash: 'List[int]', rgbSignature: 'List[int]') -> 'bool': ...

class ECDiffieHellmanOpenSsl(System.Security.Cryptography.ECDiffieHellman, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    PublicKey: 'System.Security.Cryptography.ECDiffieHellmanPublicKey' = ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.ECParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.ECParameters') -> None: ...

class ECDsaOpenSsl(System.Security.Cryptography.ECDsa, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, curve: 'System.Security.Cryptography.ECCurve') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def SignHash(self, hash: 'List[int]') -> 'List[int]': ...
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]') -> 'bool': ...

class RSAOpenSsl(System.Security.Cryptography.RSA, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keySize: 'int') -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def __init__(self, pkeyHandle: 'System.Security.Cryptography.SafeEvpPKeyHandle') -> None: ...
    def DuplicateKeyHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...

class SafeEvpPKeyHandle(System.Runtime.InteropServices.SafeHandle, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, handle: 'System.IntPtr', ownsHandle: 'bool') -> None: ...
    OpenSslVersion: 'int' = ...
    IsInvalid: 'bool' = ...
    @staticmethod
    def OpenPrivateKeyFromEngine(engineName: 'str', keyId: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    @staticmethod
    def OpenPublicKeyFromEngine(engineName: 'str', keyId: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    @staticmethod
    def OpenKeyFromProvider(providerName: 'str', keyUri: 'str') -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...
    def DuplicateHandle(self) -> 'System.Security.Cryptography.SafeEvpPKeyHandle': ...

class RC2CryptoServiceProvider(System.Security.Cryptography.RC2, System.IDisposable):
    def __init__(self) -> None: ...
    EffectiveKeySize: 'int' = ...
    UseSalt: 'bool' = ...
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class RSACryptoServiceProvider(System.Security.Cryptography.RSA, System.IDisposable, System.Security.Cryptography.ICspAsymmetricAlgorithm, System.Security.Cryptography.IRuntimeAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int') -> None: ...
    @overload
    def __init__(self, dwKeySize: 'int', parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    @overload
    def __init__(self, parameters: 'System.Security.Cryptography.CspParameters') -> None: ...
    CspKeyContainerInfo: 'System.Security.Cryptography.CspKeyContainerInfo' = ...
    KeySize: 'int' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    PersistKeyInCsp: 'bool' = ...
    PublicOnly: 'bool' = ...
    UseMachineKeyStore: 'bool' = ...
    KeyExchangeAlgorithm: 'str' = ...
    SignatureAlgorithm: 'str' = ...
    @overload
    def Decrypt(self, rgb: 'List[int]', fOAEP: 'bool') -> 'List[int]': ...
    @overload
    def Decrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def DecryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    @overload
    def Encrypt(self, rgb: 'List[int]', fOAEP: 'bool') -> 'List[int]': ...
    @overload
    def Encrypt(self, data: 'List[int]', padding: 'System.Security.Cryptography.RSAEncryptionPadding') -> 'List[int]': ...
    def EncryptValue(self, rgb: 'List[int]') -> 'List[int]': ...
    def ExportCspBlob(self, includePrivateParameters: 'bool') -> 'List[int]': ...
    def ExportParameters(self, includePrivateParameters: 'bool') -> 'System.Security.Cryptography.RSAParameters': ...
    def ImportCspBlob(self, keyBlob: 'List[int]') -> None: ...
    def ImportParameters(self, parameters: 'System.Security.Cryptography.RSAParameters') -> None: ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, passwordBytes: 'System.ReadOnlySpan[int]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def ImportEncryptedPkcs8PrivateKey(self, password: 'System.ReadOnlySpan[System.Char]', source: 'System.ReadOnlySpan[int]') -> 'System.Int32': ...
    @overload
    def SignData(self, buffer: 'List[int]', offset: 'int', count: 'int', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignData(self, buffer: 'List[int]', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignData(self, inputStream: 'System.IO.Stream', halg: 'Any') -> 'List[int]': ...
    @overload
    def SignHash(self, rgbHash: 'List[int]', str: 'str') -> 'List[int]': ...
    @overload
    def SignHash(self, hash: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'List[int]': ...
    def VerifyData(self, buffer: 'List[int]', halg: 'Any', signature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, rgbHash: 'List[int]', str: 'str', rgbSignature: 'List[int]') -> 'bool': ...
    @overload
    def VerifyHash(self, hash: 'List[int]', signature: 'List[int]', hashAlgorithm: 'System.Security.Cryptography.HashAlgorithmName', padding: 'System.Security.Cryptography.RSASignaturePadding') -> 'bool': ...

class TripleDESCng(System.Security.Cryptography.TripleDES, System.IDisposable, System.Security.Cryptography.ICngSymmetricAlgorithm):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, keyName: 'str') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider') -> None: ...
    @overload
    def __init__(self, keyName: 'str', provider: 'System.Security.Cryptography.CngProvider', openOptions: 'System.Security.Cryptography.CngKeyOpenOptions') -> None: ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateKey(self) -> None: ...
    def GenerateIV(self) -> None: ...

class TripleDESCryptoServiceProvider(System.Security.Cryptography.TripleDES, System.IDisposable):
    def __init__(self) -> None: ...
    FeedbackSize: 'int' = ...
    BlockSize: 'int' = ...
    IV: 'List[int]' = ...
    Key: 'List[int]' = ...
    KeySize: 'int' = ...
    Mode: 'System.Security.Cryptography.CipherMode' = ...
    Padding: 'System.Security.Cryptography.PaddingMode' = ...
    LegalBlockSizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    LegalKeySizes: 'List[System.Security.Cryptography.KeySizes]' = ...
    @overload
    def CreateEncryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateEncryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self) -> 'System.Security.Cryptography.ICryptoTransform': ...
    @overload
    def CreateDecryptor(self, rgbKey: 'List[int]', rgbIV: 'List[int]') -> 'System.Security.Cryptography.ICryptoTransform': ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

from . import X509Certificates as X509Certificates
from . import Pkcs as Pkcs
from . import Asn1 as Asn1
