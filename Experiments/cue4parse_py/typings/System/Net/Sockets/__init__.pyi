from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class SocketException(System.ComponentModel.Win32Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self, errorCode: 'int') -> None: ...
    @overload
    def __init__(self, errorCode: 'int', message: 'str') -> None: ...
    @overload
    def __init__(self) -> None: ...
    Message: 'str' = ...
    SocketErrorCode: 'System.Net.Sockets.SocketError' = ...
    ErrorCode: 'int' = ...

class AddressFamily(enum.Enum):
    Unspecified = ...
    Unix = ...
    InterNetwork = ...
    ImpLink = ...
    Pup = ...
    Chaos = ...
    NS = ...
    Ipx = ...
    Iso = ...
    Osi = ...
    Ecma = ...
    DataKit = ...
    Ccitt = ...
    Sna = ...
    DecNet = ...
    DataLink = ...
    Lat = ...
    HyperChannel = ...
    AppleTalk = ...
    NetBios = ...
    VoiceView = ...
    FireFox = ...
    Banyan = ...
    Atm = ...
    InterNetworkV6 = ...
    Cluster = ...
    Ieee12844 = ...
    Irda = ...
    NetworkDesigners = ...
    Max = ...
    Packet = ...
    ControllerAreaNetwork = ...
    Unknown = ...

class SocketError(enum.Enum):
    Success = ...
    OperationAborted = ...
    IOPending = ...
    Interrupted = ...
    AccessDenied = ...
    Fault = ...
    InvalidArgument = ...
    TooManyOpenSockets = ...
    WouldBlock = ...
    InProgress = ...
    AlreadyInProgress = ...
    NotSocket = ...
    DestinationAddressRequired = ...
    MessageSize = ...
    ProtocolType = ...
    ProtocolOption = ...
    ProtocolNotSupported = ...
    SocketNotSupported = ...
    OperationNotSupported = ...
    ProtocolFamilyNotSupported = ...
    AddressFamilyNotSupported = ...
    AddressAlreadyInUse = ...
    AddressNotAvailable = ...
    NetworkDown = ...
    NetworkUnreachable = ...
    NetworkReset = ...
    ConnectionAborted = ...
    ConnectionReset = ...
    NoBufferSpaceAvailable = ...
    IsConnected = ...
    NotConnected = ...
    Shutdown = ...
    TimedOut = ...
    ConnectionRefused = ...
    HostDown = ...
    HostUnreachable = ...
    ProcessLimit = ...
    SystemNotReady = ...
    VersionNotSupported = ...
    NotInitialized = ...
    Disconnecting = ...
    TypeNotFound = ...
    HostNotFound = ...
    TryAgain = ...
    NoRecovery = ...
    NoData = ...
    SocketError = ...

class SocketReceiveFromResult(System.ValueType):
    ReceivedBytes: 'int' = ...
    RemoteEndPoint: 'System.Net.EndPoint' = ...

class SocketReceiveMessageFromResult(System.ValueType):
    ReceivedBytes: 'int' = ...
    SocketFlags: 'System.Net.Sockets.SocketFlags' = ...
    RemoteEndPoint: 'System.Net.EndPoint' = ...
    PacketInformation: 'System.Net.Sockets.IPPacketInformation' = ...

class SocketTaskExtensions:
    @staticmethod
    @overload
    def AcceptAsync(socket: 'System.Net.Sockets.Socket') -> 'System.Threading.Tasks.Task[System.Net.Sockets.Socket]': ...
    @staticmethod
    @overload
    def AcceptAsync(socket: 'System.Net.Sockets.Socket', acceptSocket: 'System.Net.Sockets.Socket') -> 'System.Threading.Tasks.Task[System.Net.Sockets.Socket]': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', remoteEP: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', remoteEP: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', address: 'System.Net.IPAddress', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', address: 'System.Net.IPAddress', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', addresses: 'List[System.Net.IPAddress]', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', addresses: 'List[System.Net.IPAddress]', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', host: 'str', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @staticmethod
    @overload
    def ConnectAsync(socket: 'System.Net.Sockets.Socket', host: 'str', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    @overload
    def ReceiveAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @staticmethod
    @overload
    def ReceiveAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.Memory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def ReceiveAsync(socket: 'System.Net.Sockets.Socket', buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @staticmethod
    def ReceiveFromAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveFromResult]': ...
    @staticmethod
    def ReceiveMessageFromAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveMessageFromResult]': ...
    @staticmethod
    @overload
    def SendAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @staticmethod
    @overload
    def SendAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ReadOnlyMemory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @staticmethod
    @overload
    def SendAsync(socket: 'System.Net.Sockets.Socket', buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @staticmethod
    def SendToAsync(socket: 'System.Net.Sockets.Socket', buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[int]': ...

class IOControlCode(enum.Enum):
    EnableCircularQueuing = ...
    Flush = ...
    AddressListChange = ...
    DataToRead = ...
    OobDataRead = ...
    GetBroadcastAddress = ...
    AddressListQuery = ...
    QueryTargetPnpHandle = ...
    AsyncIO = ...
    NonBlockingIO = ...
    AssociateHandle = ...
    MultipointLoopback = ...
    MulticastScope = ...
    SetQos = ...
    SetGroupQos = ...
    RoutingInterfaceChange = ...
    NamespaceChange = ...
    ReceiveAll = ...
    ReceiveAllMulticast = ...
    ReceiveAllIgmpMulticast = ...
    KeepAliveValues = ...
    AbsorbRouterAlert = ...
    UnicastInterface = ...
    LimitBroadcasts = ...
    BindToInterface = ...
    MulticastInterface = ...
    AddMulticastGroupOnInterface = ...
    DeleteMulticastGroupFromInterface = ...
    GetExtensionFunctionPointer = ...
    GetQos = ...
    GetGroupQos = ...
    TranslateHandle = ...
    RoutingInterfaceQuery = ...
    AddressListSort = ...

class IPPacketInformation(System.ValueType, System.IEquatable[System.Net.Sockets.IPPacketInformation]):
    Address: 'System.Net.IPAddress' = ...
    Interface: 'int' = ...
    @overload
    def Equals(self, comparand: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Net.Sockets.IPPacketInformation') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class IPProtectionLevel(enum.Enum):
    Unrestricted = ...
    EdgeRestricted = ...
    Restricted = ...
    Unspecified = ...

class LingerOption:
    def __init__(self, enable: 'bool', seconds: 'int') -> None: ...
    Enabled: 'bool' = ...
    LingerTime: 'int' = ...
    def Equals(self, comparand: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class MulticastOption:
    @overload
    def __init__(self, group: 'System.Net.IPAddress', mcint: 'System.Net.IPAddress') -> None: ...
    @overload
    def __init__(self, group: 'System.Net.IPAddress', interfaceIndex: 'int') -> None: ...
    @overload
    def __init__(self, group: 'System.Net.IPAddress') -> None: ...
    Group: 'System.Net.IPAddress' = ...
    LocalAddress: 'System.Net.IPAddress' = ...
    InterfaceIndex: 'int' = ...

class IPv6MulticastOption:
    @overload
    def __init__(self, group: 'System.Net.IPAddress', ifindex: 'int') -> None: ...
    @overload
    def __init__(self, group: 'System.Net.IPAddress') -> None: ...
    Group: 'System.Net.IPAddress' = ...
    InterfaceIndex: 'int' = ...

class NetworkStream(System.IO.Stream, System.IDisposable, System.IAsyncDisposable):
    @overload
    def __init__(self, socket: 'System.Net.Sockets.Socket') -> None: ...
    @overload
    def __init__(self, socket: 'System.Net.Sockets.Socket', ownsSocket: 'bool') -> None: ...
    @overload
    def __init__(self, socket: 'System.Net.Sockets.Socket', access: 'System.IO.FileAccess') -> None: ...
    @overload
    def __init__(self, socket: 'System.Net.Sockets.Socket', access: 'System.IO.FileAccess', ownsSocket: 'bool') -> None: ...
    Socket: 'System.Net.Sockets.Socket' = ...
    CanRead: 'bool' = ...
    CanSeek: 'bool' = ...
    CanWrite: 'bool' = ...
    CanTimeout: 'bool' = ...
    ReadTimeout: 'int' = ...
    WriteTimeout: 'int' = ...
    DataAvailable: 'bool' = ...
    Length: 'int' = ...
    Position: 'int' = ...
    def Seek(self, offset: 'int', origin: 'System.IO.SeekOrigin') -> 'int': ...
    @overload
    def Read(self, buffer: 'List[int]', offset: 'int', count: 'int') -> 'int': ...
    @overload
    def Read(self, buffer: 'System.Span[int]') -> 'int': ...
    def ReadByte(self) -> 'int': ...
    @overload
    def Write(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def Write(self, buffer: 'System.ReadOnlySpan[int]') -> None: ...
    def WriteByte(self, value: 'int') -> None: ...
    @overload
    def Close(self, timeout: 'int') -> None: ...
    @overload
    def Close(self, timeout: 'System.TimeSpan') -> None: ...
    def BeginRead(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndRead(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def BeginWrite(self, buffer: 'List[int]', offset: 'int', count: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndWrite(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def ReadAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReadAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def WriteAsync(self, buffer: 'List[int]', offset: 'int', count: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    @overload
    def WriteAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.Task': ...
    def SetLength(self, value: 'int') -> None: ...

class SafeSocketHandle(Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, preexistingHandle: 'System.IntPtr', ownsHandle: 'bool') -> None: ...
    IsInvalid: 'bool' = ...

class SelectMode(enum.Enum):
    SelectRead = ...
    SelectWrite = ...
    SelectError = ...

class SendPacketsElement:
    @overload
    def __init__(self, filepath: 'str') -> None: ...
    @overload
    def __init__(self, filepath: 'str', offset: 'int', count: 'int') -> None: ...
    @overload
    def __init__(self, filepath: 'str', offset: 'int', count: 'int', endOfPacket: 'bool') -> None: ...
    @overload
    def __init__(self, filepath: 'str', offset: 'int', count: 'int') -> None: ...
    @overload
    def __init__(self, filepath: 'str', offset: 'int', count: 'int', endOfPacket: 'bool') -> None: ...
    @overload
    def __init__(self, fileStream: 'System.IO.FileStream') -> None: ...
    @overload
    def __init__(self, fileStream: 'System.IO.FileStream', offset: 'int', count: 'int') -> None: ...
    @overload
    def __init__(self, fileStream: 'System.IO.FileStream', offset: 'int', count: 'int', endOfPacket: 'bool') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def __init__(self, buffer: 'List[int]', offset: 'int', count: 'int', endOfPacket: 'bool') -> None: ...
    @overload
    def __init__(self, buffer: 'System.ReadOnlyMemory[int]') -> None: ...
    @overload
    def __init__(self, buffer: 'System.ReadOnlyMemory[int]', endOfPacket: 'bool') -> None: ...
    FilePath: 'str' = ...
    FileStream: 'System.IO.FileStream' = ...
    Buffer: 'List[int]' = ...
    Count: 'int' = ...
    MemoryBuffer: 'Optional[System.ReadOnlyMemory[int]]' = ...
    Offset: 'int' = ...
    OffsetLong: 'int' = ...
    EndOfPacket: 'bool' = ...

class Socket(System.IDisposable):
    @overload
    def __init__(self, socketType: 'System.Net.Sockets.SocketType', protocolType: 'System.Net.Sockets.ProtocolType') -> None: ...
    @overload
    def __init__(self, addressFamily: 'System.Net.Sockets.AddressFamily', socketType: 'System.Net.Sockets.SocketType', protocolType: 'System.Net.Sockets.ProtocolType') -> None: ...
    @overload
    def __init__(self, handle: 'System.Net.Sockets.SafeSocketHandle') -> None: ...
    @overload
    def __init__(self, socketInformation: 'System.Net.Sockets.SocketInformation') -> None: ...
    SupportsIPv4: 'bool' = ...
    SupportsIPv6: 'bool' = ...
    OSSupportsIPv4: 'bool' = ...
    OSSupportsIPv6: 'bool' = ...
    OSSupportsUnixDomainSockets: 'bool' = ...
    Available: 'int' = ...
    LocalEndPoint: 'System.Net.EndPoint' = ...
    RemoteEndPoint: 'System.Net.EndPoint' = ...
    Handle: 'System.IntPtr' = ...
    SafeHandle: 'System.Net.Sockets.SafeSocketHandle' = ...
    Blocking: 'bool' = ...
    UseOnlyOverlappedIO: 'bool' = ...
    Connected: 'bool' = ...
    AddressFamily: 'System.Net.Sockets.AddressFamily' = ...
    SocketType: 'System.Net.Sockets.SocketType' = ...
    ProtocolType: 'System.Net.Sockets.ProtocolType' = ...
    IsBound: 'bool' = ...
    ExclusiveAddressUse: 'bool' = ...
    ReceiveBufferSize: 'int' = ...
    SendBufferSize: 'int' = ...
    ReceiveTimeout: 'int' = ...
    SendTimeout: 'int' = ...
    LingerState: 'System.Net.Sockets.LingerOption' = ...
    NoDelay: 'bool' = ...
    Ttl: 'System.Int16' = ...
    DontFragment: 'bool' = ...
    MulticastLoopback: 'bool' = ...
    EnableBroadcast: 'bool' = ...
    DualMode: 'bool' = ...
    def Bind(self, localEP: 'System.Net.EndPoint') -> None: ...
    @overload
    def Connect(self, remoteEP: 'System.Net.EndPoint') -> None: ...
    @overload
    def Connect(self, address: 'System.Net.IPAddress', port: 'int') -> None: ...
    @overload
    def Connect(self, host: 'str', port: 'int') -> None: ...
    @overload
    def Connect(self, addresses: 'List[System.Net.IPAddress]', port: 'int') -> None: ...
    @overload
    def Close(self) -> None: ...
    @overload
    def Close(self, timeout: 'int') -> None: ...
    @overload
    def Listen(self) -> None: ...
    @overload
    def Listen(self, backlog: 'int') -> None: ...
    def Accept(self) -> 'System.Net.Sockets.Socket': ...
    @overload
    def Send(self, buffer: 'List[int]', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Send(self, buffer: 'List[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Send(self, buffer: 'List[int]') -> 'int': ...
    @overload
    def Send(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]') -> 'int': ...
    @overload
    def Send(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Send(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def Send(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Send(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def Send(self, buffer: 'System.ReadOnlySpan[int]') -> 'int': ...
    @overload
    def Send(self, buffer: 'System.ReadOnlySpan[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Send(self, buffer: 'System.ReadOnlySpan[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def SendFile(self, fileName: 'str') -> None: ...
    @overload
    def SendFile(self, fileName: 'str', preBuffer: 'List[int]', postBuffer: 'List[int]', flags: 'System.Net.Sockets.TransmitFileOptions') -> None: ...
    @overload
    def SendFile(self, fileName: 'str', preBuffer: 'System.ReadOnlySpan[int]', postBuffer: 'System.ReadOnlySpan[int]', flags: 'System.Net.Sockets.TransmitFileOptions') -> None: ...
    @overload
    def SendTo(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'List[int]', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'List[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'List[int]', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'System.ReadOnlySpan[int]', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'System.ReadOnlySpan[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'int': ...
    @overload
    def SendTo(self, buffer: 'System.ReadOnlySpan[int]', socketFlags: 'System.Net.Sockets.SocketFlags', socketAddress: 'System.Net.SocketAddress') -> 'int': ...
    @overload
    def Receive(self, buffer: 'List[int]', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Receive(self, buffer: 'List[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Receive(self, buffer: 'List[int]') -> 'int': ...
    @overload
    def Receive(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Receive(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def Receive(self, buffer: 'System.Span[int]') -> 'int': ...
    @overload
    def Receive(self, buffer: 'System.Span[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Receive(self, buffer: 'System.Span[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def Receive(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]') -> 'int': ...
    @overload
    def Receive(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'int': ...
    @overload
    def Receive(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def ReceiveMessageFrom(self, buffer: 'List[int]', offset: 'int', size: 'int') -> Tuple['int', 'System.Net.Sockets.SocketFlags', 'System.Net.EndPoint', 'System.Net.Sockets.IPPacketInformation']: ...
    @overload
    def ReceiveMessageFrom(self, buffer: 'System.Span[int]') -> Tuple['int', 'System.Net.Sockets.SocketFlags', 'System.Net.EndPoint', 'System.Net.Sockets.IPPacketInformation']: ...
    @overload
    def ReceiveFrom(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'List[int]', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'List[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'List[int]') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'System.Span[int]') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'System.Span[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def ReceiveFrom(self, buffer: 'System.Span[int]', socketFlags: 'System.Net.Sockets.SocketFlags', receivedAddress: 'System.Net.SocketAddress') -> 'int': ...
    @overload
    def IOControl(self, ioControlCode: 'int', optionInValue: 'List[int]', optionOutValue: 'List[int]') -> 'int': ...
    @overload
    def IOControl(self, ioControlCode: 'System.Net.Sockets.IOControlCode', optionInValue: 'List[int]', optionOutValue: 'List[int]') -> 'int': ...
    @overload
    def SetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionValue: 'int') -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionValue: 'List[int]') -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionValue: 'bool') -> None: ...
    @overload
    def SetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionValue: 'Any') -> None: ...
    def SetRawSocketOption(self, optionLevel: 'int', optionName: 'int', optionValue: 'System.ReadOnlySpan[int]') -> None: ...
    @overload
    def GetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName') -> 'Any': ...
    @overload
    def GetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionValue: 'List[int]') -> None: ...
    @overload
    def GetSocketOption(self, optionLevel: 'System.Net.Sockets.SocketOptionLevel', optionName: 'System.Net.Sockets.SocketOptionName', optionLength: 'int') -> 'List[int]': ...
    def GetRawSocketOption(self, optionLevel: 'int', optionName: 'int', optionValue: 'System.Span[int]') -> 'int': ...
    def SetIPProtectionLevel(self, level: 'System.Net.Sockets.IPProtectionLevel') -> None: ...
    @overload
    def Poll(self, microSeconds: 'int', mode: 'System.Net.Sockets.SelectMode') -> 'bool': ...
    @overload
    def Poll(self, timeout: 'System.TimeSpan', mode: 'System.Net.Sockets.SelectMode') -> 'bool': ...
    @staticmethod
    @overload
    def Select(checkRead: 'System.Collections.IList', checkWrite: 'System.Collections.IList', checkError: 'System.Collections.IList', microSeconds: 'int') -> None: ...
    @staticmethod
    @overload
    def Select(checkRead: 'System.Collections.IList', checkWrite: 'System.Collections.IList', checkError: 'System.Collections.IList', timeout: 'System.TimeSpan') -> None: ...
    @overload
    def BeginConnect(self, remoteEP: 'System.Net.EndPoint', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginConnect(self, host: 'str', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginConnect(self, address: 'System.Net.IPAddress', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginConnect(self, addresses: 'List[System.Net.IPAddress]', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndConnect(self, asyncResult: 'System.IAsyncResult') -> None: ...
    def BeginDisconnect(self, reuseSocket: 'bool', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def Disconnect(self, reuseSocket: 'bool') -> None: ...
    def EndDisconnect(self, asyncResult: 'System.IAsyncResult') -> None: ...
    @overload
    def BeginSend(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginSend(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.Sockets.SocketError']: ...
    @overload
    def BeginSend(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginSend(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.Sockets.SocketError']: ...
    @overload
    def EndSend(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def EndSend(self, asyncResult: 'System.IAsyncResult') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    @overload
    def BeginSendFile(self, fileName: 'str', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginSendFile(self, fileName: 'str', preBuffer: 'List[int]', postBuffer: 'List[int]', flags: 'System.Net.Sockets.TransmitFileOptions', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndSendFile(self, asyncResult: 'System.IAsyncResult') -> None: ...
    def BeginSendTo(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndSendTo(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def BeginReceive(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginReceive(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.Sockets.SocketError']: ...
    @overload
    def BeginReceive(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginReceive(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.Sockets.SocketError']: ...
    @overload
    def EndReceive(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    @overload
    def EndReceive(self, asyncResult: 'System.IAsyncResult') -> Tuple['int', 'System.Net.Sockets.SocketError']: ...
    def BeginReceiveMessageFrom(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.EndPoint']: ...
    def EndReceiveMessageFrom(self, asyncResult: 'System.IAsyncResult') -> Tuple['int', 'System.Net.Sockets.SocketFlags', 'System.Net.EndPoint', 'System.Net.Sockets.IPPacketInformation']: ...
    def BeginReceiveFrom(self, buffer: 'List[int]', offset: 'int', size: 'int', socketFlags: 'System.Net.Sockets.SocketFlags', callback: 'System.AsyncCallback', state: 'Any') -> Tuple['System.IAsyncResult', 'System.Net.EndPoint']: ...
    def EndReceiveFrom(self, asyncResult: 'System.IAsyncResult') -> Tuple['int', 'System.Net.EndPoint']: ...
    @overload
    def BeginAccept(self, callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginAccept(self, receiveSize: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginAccept(self, acceptSocket: 'System.Net.Sockets.Socket', receiveSize: 'int', callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def EndAccept(self, asyncResult: 'System.IAsyncResult') -> 'System.Net.Sockets.Socket': ...
    @overload
    def EndAccept(self, asyncResult: 'System.IAsyncResult') -> Tuple['System.Net.Sockets.Socket', 'System.Byte[]']: ...
    @overload
    def EndAccept(self, asyncResult: 'System.IAsyncResult') -> Tuple['System.Net.Sockets.Socket', 'System.Byte[]', 'System.Int32']: ...
    def Shutdown(self, how: 'System.Net.Sockets.SocketShutdown') -> None: ...
    @overload
    def AcceptAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def AcceptAsync(self) -> 'System.Threading.Tasks.Task[System.Net.Sockets.Socket]': ...
    @overload
    def AcceptAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.Socket]': ...
    @overload
    def AcceptAsync(self, acceptSocket: 'System.Net.Sockets.Socket') -> 'System.Threading.Tasks.Task[System.Net.Sockets.Socket]': ...
    @overload
    def AcceptAsync(self, acceptSocket: 'System.Net.Sockets.Socket', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.Socket]': ...
    @overload
    def ConnectAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @staticmethod
    @overload
    def ConnectAsync(socketType: 'System.Net.Sockets.SocketType', protocolType: 'System.Net.Sockets.ProtocolType', e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def ConnectAsync(self, remoteEP: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, remoteEP: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, address: 'System.Net.IPAddress', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, address: 'System.Net.IPAddress', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, addresses: 'List[System.Net.IPAddress]', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, addresses: 'List[System.Net.IPAddress]', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, host: 'str', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, host: 'str', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @staticmethod
    def CancelConnectAsync(e: 'System.Net.Sockets.SocketAsyncEventArgs') -> None: ...
    @overload
    def DisconnectAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def DisconnectAsync(self, reuseSocket: 'bool', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ReceiveAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def ReceiveAsync(self, buffer: 'System.ArraySegment[int]') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReceiveAsync(self, buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReceiveAsync(self, buffer: 'System.Memory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReceiveAsync(self, buffer: 'System.Memory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReceiveAsync(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReceiveAsync(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def ReceiveFromAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def ReceiveFromAsync(self, buffer: 'System.ArraySegment[int]', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveFromResult]': ...
    @overload
    def ReceiveFromAsync(self, buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveFromResult]': ...
    @overload
    def ReceiveFromAsync(self, buffer: 'System.Memory[int]', remoteEndPoint: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.SocketReceiveFromResult]': ...
    @overload
    def ReceiveFromAsync(self, buffer: 'System.Memory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.SocketReceiveFromResult]': ...
    @overload
    def ReceiveFromAsync(self, buffer: 'System.Memory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', receivedAddress: 'System.Net.SocketAddress', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReceiveMessageFromAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: 'System.ArraySegment[int]', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveMessageFromResult]': ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[System.Net.Sockets.SocketReceiveMessageFromResult]': ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: 'System.Memory[int]', remoteEndPoint: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.SocketReceiveMessageFromResult]': ...
    @overload
    def ReceiveMessageFromAsync(self, buffer: 'System.Memory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEndPoint: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.SocketReceiveMessageFromResult]': ...
    @overload
    def SendAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def SendAsync(self, buffer: 'System.ArraySegment[int]') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, buffer: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendAsync(self, buffer: 'System.ReadOnlyMemory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendAsync(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, buffers: 'System.Collections.Generic.IList[System.ArraySegment[int]]', socketFlags: 'System.Net.Sockets.SocketFlags') -> 'System.Threading.Tasks.Task[int]': ...
    def SendPacketsAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def SendToAsync(self, e: 'System.Net.Sockets.SocketAsyncEventArgs') -> 'bool': ...
    @overload
    def SendToAsync(self, buffer: 'System.ArraySegment[int]', remoteEP: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendToAsync(self, buffer: 'System.ArraySegment[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendToAsync(self, buffer: 'System.ReadOnlyMemory[int]', remoteEP: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendToAsync(self, buffer: 'System.ReadOnlyMemory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', remoteEP: 'System.Net.EndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendToAsync(self, buffer: 'System.ReadOnlyMemory[int]', socketFlags: 'System.Net.Sockets.SocketFlags', socketAddress: 'System.Net.SocketAddress', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    def Dispose(self) -> None: ...
    @overload
    def SendFileAsync(self, fileName: 'str', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def SendFileAsync(self, fileName: 'str', preBuffer: 'System.ReadOnlyMemory[int]', postBuffer: 'System.ReadOnlyMemory[int]', flags: 'System.Net.Sockets.TransmitFileOptions', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    def DuplicateAndClose(self, targetProcessId: 'int') -> 'System.Net.Sockets.SocketInformation': ...

class SocketAsyncEventArgs(System.EventArgs, System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, unsafeSuppressExecutionContextFlow: 'bool') -> None: ...
    AcceptSocket: 'System.Net.Sockets.Socket' = ...
    ConnectSocket: 'System.Net.Sockets.Socket' = ...
    Buffer: 'List[int]' = ...
    MemoryBuffer: 'System.Memory[int]' = ...
    Offset: 'int' = ...
    Count: 'int' = ...
    SendPacketsFlags: 'System.Net.Sockets.TransmitFileOptions' = ...
    BufferList: 'System.Collections.Generic.IList[System.ArraySegment[int]]' = ...
    BytesTransferred: 'int' = ...
    DisconnectReuseSocket: 'bool' = ...
    LastOperation: 'System.Net.Sockets.SocketAsyncOperation' = ...
    ReceiveMessageFromPacketInfo: 'System.Net.Sockets.IPPacketInformation' = ...
    RemoteEndPoint: 'System.Net.EndPoint' = ...
    SendPacketsElements: 'List[System.Net.Sockets.SendPacketsElement]' = ...
    SendPacketsSendSize: 'int' = ...
    SocketError: 'System.Net.Sockets.SocketError' = ...
    ConnectByNameError: 'System.Exception' = ...
    SocketFlags: 'System.Net.Sockets.SocketFlags' = ...
    UserToken: 'Any' = ...
    @overload
    def SetBuffer(self, offset: 'int', count: 'int') -> None: ...
    @overload
    def SetBuffer(self, buffer: 'List[int]', offset: 'int', count: 'int') -> None: ...
    @overload
    def SetBuffer(self, buffer: 'System.Memory[int]') -> None: ...
    def Dispose(self) -> None: ...

class SocketAsyncOperation(enum.Enum):
    None = ...
    Accept = ...
    Connect = ...
    Disconnect = ...
    Receive = ...
    ReceiveFrom = ...
    ReceiveMessageFrom = ...
    Send = ...
    SendPackets = ...
    SendTo = ...

class SocketFlags(enum.Enum):
    None = ...
    OutOfBand = ...
    Peek = ...
    DontRoute = ...
    Truncated = ...
    ControlDataTruncated = ...
    Broadcast = ...
    Multicast = ...
    Partial = ...

class SocketInformationOptions(enum.Enum):
    NonBlocking = ...
    Connected = ...
    Listening = ...
    UseOnlyOverlappedIO = ...

class SocketInformation(System.ValueType):
    ProtocolInformation: 'List[int]' = ...
    Options: 'System.Net.Sockets.SocketInformationOptions' = ...

class SocketOptionLevel(enum.Enum):
    IP = ...
    Tcp = ...
    Udp = ...
    IPv6 = ...
    Socket = ...

class SocketOptionName(enum.Enum):
    Debug = ...
    NoChecksum = ...
    NoDelay = ...
    IPOptions = ...
    AcceptConnection = ...
    Expedited = ...
    BsdUrgent = ...
    HeaderIncluded = ...
    TcpKeepAliveTime = ...
    TypeOfService = ...
    IpTimeToLive = ...
    ReuseAddress = ...
    KeepAlive = ...
    MulticastInterface = ...
    MulticastTimeToLive = ...
    MulticastLoopback = ...
    AddMembership = ...
    DropMembership = ...
    DontFragment = ...
    FastOpen = ...
    AddSourceMembership = ...
    TcpKeepAliveRetryCount = ...
    DontRoute = ...
    DropSourceMembership = ...
    BlockSource = ...
    TcpKeepAliveInterval = ...
    UnblockSource = ...
    PacketInformation = ...
    ChecksumCoverage = ...
    HopLimit = ...
    IPProtectionLevel = ...
    IPv6Only = ...
    Broadcast = ...
    UseLoopback = ...
    Linger = ...
    OutOfBandInline = ...
    SendBuffer = ...
    ReceiveBuffer = ...
    SendLowWater = ...
    ReceiveLowWater = ...
    SendTimeout = ...
    ReceiveTimeout = ...
    Error = ...
    Type = ...
    ReuseUnicastPort = ...
    UpdateAcceptContext = ...
    UpdateConnectContext = ...
    MaxConnections = ...
    DontLinger = ...
    ExclusiveAddressUse = ...

class SocketShutdown(enum.Enum):
    Receive = ...
    Send = ...
    Both = ...

class TcpClient(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, family: 'System.Net.Sockets.AddressFamily') -> None: ...
    @overload
    def __init__(self, localEP: 'System.Net.IPEndPoint') -> None: ...
    @overload
    def __init__(self, hostname: 'str', port: 'int') -> None: ...
    Available: 'int' = ...
    Client: 'System.Net.Sockets.Socket' = ...
    Connected: 'bool' = ...
    ExclusiveAddressUse: 'bool' = ...
    ReceiveBufferSize: 'int' = ...
    SendBufferSize: 'int' = ...
    ReceiveTimeout: 'int' = ...
    SendTimeout: 'int' = ...
    LingerState: 'System.Net.Sockets.LingerOption' = ...
    NoDelay: 'bool' = ...
    @overload
    def Connect(self, hostname: 'str', port: 'int') -> None: ...
    @overload
    def Connect(self, address: 'System.Net.IPAddress', port: 'int') -> None: ...
    @overload
    def Connect(self, remoteEP: 'System.Net.IPEndPoint') -> None: ...
    @overload
    def Connect(self, ipAddresses: 'List[System.Net.IPAddress]', port: 'int') -> None: ...
    @overload
    def ConnectAsync(self, address: 'System.Net.IPAddress', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, host: 'str', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, addresses: 'List[System.Net.IPAddress]', port: 'int') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, remoteEP: 'System.Net.IPEndPoint') -> 'System.Threading.Tasks.Task': ...
    @overload
    def ConnectAsync(self, address: 'System.Net.IPAddress', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, host: 'str', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, addresses: 'List[System.Net.IPAddress]', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def ConnectAsync(self, remoteEP: 'System.Net.IPEndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask': ...
    @overload
    def BeginConnect(self, address: 'System.Net.IPAddress', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginConnect(self, host: 'str', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginConnect(self, addresses: 'List[System.Net.IPAddress]', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndConnect(self, asyncResult: 'System.IAsyncResult') -> None: ...
    def GetStream(self) -> 'System.Net.Sockets.NetworkStream': ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...

class TcpListener(System.IDisposable):
    @overload
    def __init__(self, localEP: 'System.Net.IPEndPoint') -> None: ...
    @overload
    def __init__(self, localaddr: 'System.Net.IPAddress', port: 'int') -> None: ...
    @overload
    def __init__(self, port: 'int') -> None: ...
    Server: 'System.Net.Sockets.Socket' = ...
    LocalEndpoint: 'System.Net.EndPoint' = ...
    ExclusiveAddressUse: 'bool' = ...
    def AllowNatTraversal(self, allowed: 'bool') -> None: ...
    @overload
    def Start(self) -> None: ...
    @overload
    def Start(self, backlog: 'int') -> None: ...
    def Stop(self) -> None: ...
    def Dispose(self) -> None: ...
    def Pending(self) -> 'bool': ...
    def AcceptSocket(self) -> 'System.Net.Sockets.Socket': ...
    def AcceptTcpClient(self) -> 'System.Net.Sockets.TcpClient': ...
    def BeginAcceptSocket(self, callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndAcceptSocket(self, asyncResult: 'System.IAsyncResult') -> 'System.Net.Sockets.Socket': ...
    def BeginAcceptTcpClient(self, callback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndAcceptTcpClient(self, asyncResult: 'System.IAsyncResult') -> 'System.Net.Sockets.TcpClient': ...
    @overload
    def AcceptSocketAsync(self) -> 'System.Threading.Tasks.Task[System.Net.Sockets.Socket]': ...
    @overload
    def AcceptSocketAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.Socket]': ...
    @overload
    def AcceptTcpClientAsync(self) -> 'System.Threading.Tasks.Task[System.Net.Sockets.TcpClient]': ...
    @overload
    def AcceptTcpClientAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.TcpClient]': ...
    @staticmethod
    def Create(port: 'int') -> 'System.Net.Sockets.TcpListener': ...

class TransmitFileOptions(enum.Enum):
    UseDefaultWorkerThread = ...
    Disconnect = ...
    ReuseSocket = ...
    WriteBehind = ...
    UseSystemThread = ...
    UseKernelApc = ...

class UdpClient(System.IDisposable):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, family: 'System.Net.Sockets.AddressFamily') -> None: ...
    @overload
    def __init__(self, port: 'int') -> None: ...
    @overload
    def __init__(self, port: 'int', family: 'System.Net.Sockets.AddressFamily') -> None: ...
    @overload
    def __init__(self, localEP: 'System.Net.IPEndPoint') -> None: ...
    @overload
    def __init__(self, hostname: 'str', port: 'int') -> None: ...
    Available: 'int' = ...
    Client: 'System.Net.Sockets.Socket' = ...
    Ttl: 'System.Int16' = ...
    DontFragment: 'bool' = ...
    MulticastLoopback: 'bool' = ...
    EnableBroadcast: 'bool' = ...
    ExclusiveAddressUse: 'bool' = ...
    def AllowNatTraversal(self, allowed: 'bool') -> None: ...
    def Dispose(self) -> None: ...
    @overload
    def BeginSend(self, datagram: 'List[int]', bytes: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginSend(self, datagram: 'List[int]', bytes: 'int', hostname: 'str', port: 'int', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    @overload
    def BeginSend(self, datagram: 'List[int]', bytes: 'int', endPoint: 'System.Net.IPEndPoint', requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndSend(self, asyncResult: 'System.IAsyncResult') -> 'int': ...
    def BeginReceive(self, requestCallback: 'System.AsyncCallback', state: 'Any') -> 'System.IAsyncResult': ...
    def EndReceive(self, asyncResult: 'System.IAsyncResult') -> Tuple['List[int]', 'System.Net.IPEndPoint']: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: 'System.Net.IPAddress') -> None: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: 'System.Net.IPAddress', localAddress: 'System.Net.IPAddress') -> None: ...
    @overload
    def JoinMulticastGroup(self, ifindex: 'int', multicastAddr: 'System.Net.IPAddress') -> None: ...
    @overload
    def JoinMulticastGroup(self, multicastAddr: 'System.Net.IPAddress', timeToLive: 'int') -> None: ...
    @overload
    def DropMulticastGroup(self, multicastAddr: 'System.Net.IPAddress') -> None: ...
    @overload
    def DropMulticastGroup(self, multicastAddr: 'System.Net.IPAddress', ifindex: 'int') -> None: ...
    @overload
    def SendAsync(self, datagram: 'List[int]', bytes: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, datagram: 'System.ReadOnlyMemory[int]', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendAsync(self, datagram: 'List[int]', bytes: 'int', hostname: 'str', port: 'int') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, datagram: 'System.ReadOnlyMemory[int]', hostname: 'str', port: 'int', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def SendAsync(self, datagram: 'List[int]', bytes: 'int', endPoint: 'System.Net.IPEndPoint') -> 'System.Threading.Tasks.Task[int]': ...
    @overload
    def SendAsync(self, datagram: 'System.ReadOnlyMemory[int]', endPoint: 'System.Net.IPEndPoint', cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[int]': ...
    @overload
    def ReceiveAsync(self) -> 'System.Threading.Tasks.Task[System.Net.Sockets.UdpReceiveResult]': ...
    @overload
    def ReceiveAsync(self, cancellationToken: 'System.Threading.CancellationToken') -> 'System.Threading.Tasks.ValueTask[System.Net.Sockets.UdpReceiveResult]': ...
    def Close(self) -> None: ...
    @overload
    def Connect(self, hostname: 'str', port: 'int') -> None: ...
    @overload
    def Connect(self, addr: 'System.Net.IPAddress', port: 'int') -> None: ...
    @overload
    def Connect(self, endPoint: 'System.Net.IPEndPoint') -> None: ...
    def Receive(self) -> Tuple['List[int]', 'System.Net.IPEndPoint']: ...
    @overload
    def Send(self, dgram: 'List[int]', bytes: 'int', endPoint: 'System.Net.IPEndPoint') -> 'int': ...
    @overload
    def Send(self, datagram: 'System.ReadOnlySpan[int]', endPoint: 'System.Net.IPEndPoint') -> 'int': ...
    @overload
    def Send(self, dgram: 'List[int]', bytes: 'int', hostname: 'str', port: 'int') -> 'int': ...
    @overload
    def Send(self, datagram: 'System.ReadOnlySpan[int]', hostname: 'str', port: 'int') -> 'int': ...
    @overload
    def Send(self, dgram: 'List[int]', bytes: 'int') -> 'int': ...
    @overload
    def Send(self, datagram: 'System.ReadOnlySpan[int]') -> 'int': ...

class UdpReceiveResult(System.ValueType, System.IEquatable[System.Net.Sockets.UdpReceiveResult]):
    def __init__(self, buffer: 'List[int]', remoteEndPoint: 'System.Net.IPEndPoint') -> None: ...
    Buffer: 'List[int]' = ...
    RemoteEndPoint: 'System.Net.IPEndPoint' = ...
    def GetHashCode(self) -> 'int': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'System.Net.Sockets.UdpReceiveResult') -> 'bool': ...

class UnixDomainSocketEndPoint(System.Net.EndPoint):
    def __init__(self, path: 'str') -> None: ...
    AddressFamily: 'System.Net.Sockets.AddressFamily' = ...
    def Serialize(self) -> 'System.Net.SocketAddress': ...
    def Create(self, socketAddress: 'System.Net.SocketAddress') -> 'System.Net.EndPoint': ...
    def ToString(self) -> 'str': ...
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class ProtocolFamily(enum.Enum):
    Unspecified = ...
    Unix = ...
    InterNetwork = ...
    ImpLink = ...
    Pup = ...
    Chaos = ...
    NS = ...
    Ipx = ...
    Iso = ...
    Osi = ...
    Ecma = ...
    DataKit = ...
    Ccitt = ...
    Sna = ...
    DecNet = ...
    DataLink = ...
    Lat = ...
    HyperChannel = ...
    AppleTalk = ...
    NetBios = ...
    VoiceView = ...
    FireFox = ...
    Banyan = ...
    Atm = ...
    InterNetworkV6 = ...
    Cluster = ...
    Ieee12844 = ...
    Irda = ...
    NetworkDesigners = ...
    Max = ...
    Packet = ...
    ControllerAreaNetwork = ...
    Unknown = ...

class ProtocolType(enum.Enum):
    IP = ...
    IPv6HopByHopOptions = ...
    Unspecified = ...
    Icmp = ...
    Igmp = ...
    Ggp = ...
    IPv4 = ...
    Tcp = ...
    Pup = ...
    Udp = ...
    Idp = ...
    IPv6 = ...
    IPv6RoutingHeader = ...
    IPv6FragmentHeader = ...
    IPSecEncapsulatingSecurityPayload = ...
    IPSecAuthenticationHeader = ...
    IcmpV6 = ...
    IPv6NoNextHeader = ...
    IPv6DestinationOptions = ...
    ND = ...
    Raw = ...
    Ipx = ...
    Spx = ...
    SpxII = ...
    Unknown = ...

class SocketType(enum.Enum):
    Stream = ...
    Dgram = ...
    Raw = ...
    Rdm = ...
    Seqpacket = ...
    Unknown = ...

class SocketException(System.ComponentModel.Win32Exception, System.Runtime.Serialization.ISerializable):
    @overload
    def __init__(self, errorCode: 'int') -> None: ...
    @overload
    def __init__(self, errorCode: 'int', message: 'str') -> None: ...
    @overload
    def __init__(self) -> None: ...
    Message: 'str' = ...
    SocketErrorCode: 'System.Net.Sockets.SocketError' = ...
    ErrorCode: 'int' = ...

class AddressFamily(enum.Enum):
    Unspecified = ...
    Unix = ...
    InterNetwork = ...
    ImpLink = ...
    Pup = ...
    Chaos = ...
    NS = ...
    Ipx = ...
    Iso = ...
    Osi = ...
    Ecma = ...
    DataKit = ...
    Ccitt = ...
    Sna = ...
    DecNet = ...
    DataLink = ...
    Lat = ...
    HyperChannel = ...
    AppleTalk = ...
    NetBios = ...
    VoiceView = ...
    FireFox = ...
    Banyan = ...
    Atm = ...
    InterNetworkV6 = ...
    Cluster = ...
    Ieee12844 = ...
    Irda = ...
    NetworkDesigners = ...
    Max = ...
    Packet = ...
    ControllerAreaNetwork = ...
    Unknown = ...

class SocketError(enum.Enum):
    Success = ...
    OperationAborted = ...
    IOPending = ...
    Interrupted = ...
    AccessDenied = ...
    Fault = ...
    InvalidArgument = ...
    TooManyOpenSockets = ...
    WouldBlock = ...
    InProgress = ...
    AlreadyInProgress = ...
    NotSocket = ...
    DestinationAddressRequired = ...
    MessageSize = ...
    ProtocolType = ...
    ProtocolOption = ...
    ProtocolNotSupported = ...
    SocketNotSupported = ...
    OperationNotSupported = ...
    ProtocolFamilyNotSupported = ...
    AddressFamilyNotSupported = ...
    AddressAlreadyInUse = ...
    AddressNotAvailable = ...
    NetworkDown = ...
    NetworkUnreachable = ...
    NetworkReset = ...
    ConnectionAborted = ...
    ConnectionReset = ...
    NoBufferSpaceAvailable = ...
    IsConnected = ...
    NotConnected = ...
    Shutdown = ...
    TimedOut = ...
    ConnectionRefused = ...
    HostDown = ...
    HostUnreachable = ...
    ProcessLimit = ...
    SystemNotReady = ...
    VersionNotSupported = ...
    NotInitialized = ...
    Disconnecting = ...
    TypeNotFound = ...
    HostNotFound = ...
    TryAgain = ...
    NoRecovery = ...
    NoData = ...
    SocketError = ...

