from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class BoundingArea(System.ValueType, FixedMathSharp.IBound, System.IEquatable[FixedMathSharp.BoundingArea]):
    @overload
    def __init__(self, c1x: 'FixedMathSharp.Fixed64', c1y: 'FixedMathSharp.Fixed64', c1z: 'FixedMathSharp.Fixed64', c2x: 'FixedMathSharp.Fixed64', c2y: 'FixedMathSharp.Fixed64', c2z: 'FixedMathSharp.Fixed64') -> None: ...
    @overload
    def __init__(self, corner1: 'FixedMathSharp.Vector3d', corner2: 'FixedMathSharp.Vector3d') -> None: ...
    Corner1: 'FixedMathSharp.Vector3d' = ...
    Corner2: 'FixedMathSharp.Vector3d' = ...
    Min: 'FixedMathSharp.Vector3d' = ...
    Max: 'FixedMathSharp.Vector3d' = ...
    MinX: 'FixedMathSharp.Fixed64' = ...
    MaxX: 'FixedMathSharp.Fixed64' = ...
    MinY: 'FixedMathSharp.Fixed64' = ...
    MaxY: 'FixedMathSharp.Fixed64' = ...
    MinZ: 'FixedMathSharp.Fixed64' = ...
    MaxZ: 'FixedMathSharp.Fixed64' = ...
    Width: 'FixedMathSharp.Fixed64' = ...
    Height: 'FixedMathSharp.Fixed64' = ...
    Depth: 'FixedMathSharp.Fixed64' = ...
    def Contains(self, point: 'FixedMathSharp.Vector3d') -> 'bool': ...
    def Intersects(self, other: 'FixedMathSharp.IBound') -> 'bool': ...
    def ProjectPoint(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.BoundingArea') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class BoundingBox(System.ValueType, FixedMathSharp.IBound, System.IEquatable[FixedMathSharp.BoundingBox], System.Runtime.Serialization.IDeserializationCallback):
    def __init__(self, center: 'FixedMathSharp.Vector3d', size: 'FixedMathSharp.Vector3d') -> None: ...
    Center: 'FixedMathSharp.Vector3d' = ...
    Scope: 'FixedMathSharp.Vector3d' = ...
    Min: 'FixedMathSharp.Vector3d' = ...
    Max: 'FixedMathSharp.Vector3d' = ...
    Vertices: 'List[FixedMathSharp.Vector3d]' = ...
    Proportions: 'FixedMathSharp.Vector3d' = ...
    def Orient(self, center: 'FixedMathSharp.Vector3d', size: 'Optional[FixedMathSharp.Vector3d]') -> None: ...
    def Resize(self, size: 'FixedMathSharp.Vector3d') -> None: ...
    def SetMinMax(self, min: 'FixedMathSharp.Vector3d', max: 'FixedMathSharp.Vector3d') -> None: ...
    def SetBoundingBox(self, center: 'FixedMathSharp.Vector3d', scope: 'FixedMathSharp.Vector3d') -> None: ...
    def Contains(self, point: 'FixedMathSharp.Vector3d') -> 'bool': ...
    def Intersects(self, other: 'FixedMathSharp.IBound') -> 'bool': ...
    def ProjectPoint(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    def DistanceToSurface(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    def GetPointOnSurfaceTowardsObject(self, objectPosition: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    def ClosestPointOnSurface(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Union(a: 'FixedMathSharp.BoundingBox', b: 'FixedMathSharp.BoundingBox') -> 'FixedMathSharp.BoundingBox': ...
    @staticmethod
    def FindClosestPointsBetweenBoxes(a: 'FixedMathSharp.BoundingBox', b: 'FixedMathSharp.BoundingBox') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.BoundingBox') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class BoundingSphere(System.ValueType, FixedMathSharp.IBound, System.IEquatable[FixedMathSharp.BoundingSphere]):
    def __init__(self, center: 'FixedMathSharp.Vector3d', radius: 'FixedMathSharp.Fixed64') -> None: ...
    Center: 'FixedMathSharp.Vector3d' = ...
    Radius: 'FixedMathSharp.Fixed64' = ...
    Min: 'FixedMathSharp.Vector3d' = ...
    Max: 'FixedMathSharp.Vector3d' = ...
    SqrRadius: 'FixedMathSharp.Fixed64' = ...
    def Contains(self, point: 'FixedMathSharp.Vector3d') -> 'bool': ...
    def Intersects(self, other: 'FixedMathSharp.IBound') -> 'bool': ...
    def ProjectPoint(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    def DistanceToSurface(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.BoundingSphere') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class IBound:
    Min: 'FixedMathSharp.Vector3d' = ...
    Max: 'FixedMathSharp.Vector3d' = ...
    def Contains(self, point: 'FixedMathSharp.Vector3d') -> 'bool': ...
    def Intersects(self, other: 'FixedMathSharp.IBound') -> 'bool': ...
    def ProjectPoint(self, point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...

class FixedMath:
    SCALE_FACTOR_M: 'System.Decimal' = ...
    Pow10Lookup: 'List[int]' = ...
    PI: 'FixedMathSharp.Fixed64' = ...
    TwoPI: 'FixedMathSharp.Fixed64' = ...
    PiOver2: 'FixedMathSharp.Fixed64' = ...
    PiOver3: 'FixedMathSharp.Fixed64' = ...
    PiOver4: 'FixedMathSharp.Fixed64' = ...
    PiOver6: 'FixedMathSharp.Fixed64' = ...
    Ln2: 'FixedMathSharp.Fixed64' = ...
    LOG_2_MAX: 'FixedMathSharp.Fixed64' = ...
    LOG_2_MIN: 'FixedMathSharp.Fixed64' = ...
    Deg2Rad: 'FixedMathSharp.Fixed64' = ...
    Rad2Deg: 'FixedMathSharp.Fixed64' = ...
    NUM_BITS: 'int' = ...
    SHIFT_AMOUNT_I: 'int' = ...
    MAX_SHIFTED_AMOUNT_UI: 'System.UInt32' = ...
    MASK_UL: 'System.UInt64' = ...
    MAX_VALUE_L: 'int' = ...
    MIN_VALUE_L: 'int' = ...
    ONE_L: 'int' = ...
    SCALE_FACTOR_F: 'float' = ...
    SCALE_FACTOR_D: 'float' = ...
    PRECISION_L: 'int' = ...
    EPSILON_L: 'int' = ...
    @staticmethod
    def CopySign(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Clamp01(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Clamp(f1: 'FixedMathSharp.Fixed64', min: 'FixedMathSharp.Fixed64', max: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Clamp(value: 'T', min: 'T', max: 'T') -> 'T': ...
    @staticmethod
    def ClampOne(f1: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Ceiling(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Floor(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Max(f1: 'FixedMathSharp.Fixed64', f2: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Min(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Round(value: 'FixedMathSharp.Fixed64', mode: 'System.MidpointRounding') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def RoundToPrecision(value: 'FixedMathSharp.Fixed64', decimalPlaces: 'int', mode: 'System.MidpointRounding') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Squared(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastAdd(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastSub(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastMul(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastMod(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def SmoothStep(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def CubicInterpolate(p0: 'FixedMathSharp.Fixed64', p1: 'FixedMathSharp.Fixed64', m0: 'FixedMathSharp.Fixed64', m1: 'FixedMathSharp.Fixed64', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def LinearInterpolate(from: 'FixedMathSharp.Fixed64', to: 'FixedMathSharp.Fixed64', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def MoveTowards(from: 'FixedMathSharp.Fixed64', to: 'FixedMathSharp.Fixed64', maxAmount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def AddOverflowHelper(x: 'int', y: 'int') -> Tuple['int', 'System.Boolean']: ...
    @staticmethod
    def Pow(b: 'FixedMathSharp.Fixed64', exp: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Pow2(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Log2(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Ln(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Sqrt(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def RadToDeg(rad: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def DegToRad(deg: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Sin(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Cos(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def SinToCos(sin: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Tan(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Asin(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Acos(x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Atan(z: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Atan2(y: 'FixedMathSharp.Fixed64', x: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...

class Fixed3x3Extensions:
    @staticmethod
    def ExtractScale(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def SetScale(localScale: 'FixedMathSharp.Vector3d') -> Tuple['FixedMathSharp.Fixed3x3', 'FixedMathSharp.Fixed3x3']: ...
    @staticmethod
    def SetGlobalScale(globalScale: 'FixedMathSharp.Vector3d') -> Tuple['FixedMathSharp.Fixed3x3', 'FixedMathSharp.Fixed3x3']: ...
    @staticmethod
    def FuzzyEqualAbsolute(f1: 'FixedMathSharp.Fixed3x3', f2: 'FixedMathSharp.Fixed3x3', allowedDifference: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FuzzyEqual(f1: 'FixedMathSharp.Fixed3x3', f2: 'FixedMathSharp.Fixed3x3', percentage: 'Optional[FixedMathSharp.Fixed64]') -> 'bool': ...

class Fixed4x4Extensions:
    @staticmethod
    def ExtractLossyScale(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def SetGlobalScale(globalScale: 'FixedMathSharp.Vector3d') -> Tuple['FixedMathSharp.Fixed4x4', 'FixedMathSharp.Fixed4x4']: ...
    @staticmethod
    def SetTranslation(position: 'FixedMathSharp.Vector3d') -> Tuple['FixedMathSharp.Fixed4x4', 'FixedMathSharp.Fixed4x4']: ...
    @staticmethod
    def SetRotation(rotation: 'FixedMathSharp.FixedQuaternion') -> Tuple['FixedMathSharp.Fixed4x4', 'FixedMathSharp.Fixed4x4']: ...
    @staticmethod
    def TransformPoint(matrix: 'FixedMathSharp.Fixed4x4', point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def InverseTransformPoint(matrix: 'FixedMathSharp.Fixed4x4', point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...

class Fixed64Extensions:
    @staticmethod
    def Sign(value: 'FixedMathSharp.Fixed64') -> 'int': ...
    @staticmethod
    def IsInteger(value: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def Squared(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Round(value: 'FixedMathSharp.Fixed64', mode: 'System.MidpointRounding') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def RoundToPrecision(value: 'FixedMathSharp.Fixed64', places: 'int', mode: 'System.MidpointRounding') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def ClampOne(f1: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Clamp01(f1: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def AbsLessThan(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FastAdd(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastSub(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastMul(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def FastMod(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Floor(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Ceiling(value: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def RoundToInt(x: 'FixedMathSharp.Fixed64') -> 'int': ...
    @staticmethod
    def CeilToInt(x: 'FixedMathSharp.Fixed64') -> 'int': ...
    @staticmethod
    def FloorToInt(x: 'FixedMathSharp.Fixed64') -> 'int': ...
    @staticmethod
    def ToFormattedString(f1: 'FixedMathSharp.Fixed64') -> 'str': ...
    @staticmethod
    def ToFormattedDouble(f1: 'FixedMathSharp.Fixed64', precision: 'int') -> 'float': ...
    @staticmethod
    def ToFormattedFloat(f1: 'FixedMathSharp.Fixed64') -> 'float': ...
    @staticmethod
    def ToPreciseFloat(f1: 'FixedMathSharp.Fixed64') -> 'float': ...
    @staticmethod
    def ToRadians(angleInDegrees: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def ToDegree(angleInRadians: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def MoreThanEpsilon(d: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def LessThanEpsilon(d: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FuzzyComponentEqual(a: 'FixedMathSharp.Fixed64', b: 'FixedMathSharp.Fixed64', percentage: 'FixedMathSharp.Fixed64') -> 'bool': ...

class FixedQuaternionExtensions:
    @staticmethod
    def ToAngularVelocity(currentRotation: 'FixedMathSharp.FixedQuaternion', previousRotation: 'FixedMathSharp.FixedQuaternion', deltaTime: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def FuzzyEqualAbsolute(q1: 'FixedMathSharp.FixedQuaternion', q2: 'FixedMathSharp.FixedQuaternion', allowedDifference: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FuzzyEqual(q1: 'FixedMathSharp.FixedQuaternion', q2: 'FixedMathSharp.FixedQuaternion', percentage: 'Optional[FixedMathSharp.Fixed64]') -> 'bool': ...

class Vector2dExtensions:
    @staticmethod
    def ClampOneInPlace(v: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def CheckDistance(me: 'FixedMathSharp.Vector2d', other: 'FixedMathSharp.Vector2d', factor: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def Rotate(vec: 'FixedMathSharp.Vector2d', angleInRadians: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Sign(value: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def ToDegrees(radians: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def ToRadians(degrees: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def FuzzyEqualAbsolute(me: 'FixedMathSharp.Vector2d', other: 'FixedMathSharp.Vector2d', allowedDifference: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FuzzyEqual(me: 'FixedMathSharp.Vector2d', other: 'FixedMathSharp.Vector2d', percentage: 'Optional[FixedMathSharp.Fixed64]') -> 'bool': ...

class Vector3dExtensions:
    @staticmethod
    def ClampOneInPlace(v: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ClampMagnitude(value: 'FixedMathSharp.Vector3d', maxMagnitude: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def CheckDistance(me: 'FixedMathSharp.Vector3d', other: 'FixedMathSharp.Vector3d', factor: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def Rotate(source: 'FixedMathSharp.Vector3d', position: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def InverseRotate(source: 'FixedMathSharp.Vector3d', position: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ToDegrees(radians: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ToRadians(degrees: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Sign(value: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def FuzzyEqualAbsolute(me: 'FixedMathSharp.Vector3d', other: 'FixedMathSharp.Vector3d', allowedDifference: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def FuzzyEqual(me: 'FixedMathSharp.Vector3d', other: 'FixedMathSharp.Vector3d', percentage: 'Optional[FixedMathSharp.Fixed64]') -> 'bool': ...

class Fixed3x3(System.ValueType, System.IEquatable[FixedMathSharp.Fixed3x3]):
    @overload
    def __init__(self, m00: 'FixedMathSharp.Fixed64', m01: 'FixedMathSharp.Fixed64', m02: 'FixedMathSharp.Fixed64', m10: 'FixedMathSharp.Fixed64', m11: 'FixedMathSharp.Fixed64', m12: 'FixedMathSharp.Fixed64', m20: 'FixedMathSharp.Fixed64', m21: 'FixedMathSharp.Fixed64', m22: 'FixedMathSharp.Fixed64') -> None: ...
    @overload
    def __init__(self, m00_m01_m02: 'FixedMathSharp.Vector3d', m10_m11_m12: 'FixedMathSharp.Vector3d', m20_m21_m22: 'FixedMathSharp.Vector3d') -> None: ...
    m00: 'FixedMathSharp.Fixed64' = ...
    m01: 'FixedMathSharp.Fixed64' = ...
    m02: 'FixedMathSharp.Fixed64' = ...
    m10: 'FixedMathSharp.Fixed64' = ...
    m11: 'FixedMathSharp.Fixed64' = ...
    m12: 'FixedMathSharp.Fixed64' = ...
    m20: 'FixedMathSharp.Fixed64' = ...
    m21: 'FixedMathSharp.Fixed64' = ...
    m22: 'FixedMathSharp.Fixed64' = ...
    Identity: 'FixedMathSharp.Fixed3x3' = ...
    Zero: 'FixedMathSharp.Fixed3x3' = ...
    __getitem__: 'FixedMathSharp.Fixed64' = ...
    @overload
    def Normalize(self) -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def Normalize(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Fixed3x3': ...
    @overload
    def ResetScaleToIdentity(self) -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def ResetScaleToIdentity(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Fixed3x3': ...
    def GetDeterminant(self) -> 'FixedMathSharp.Fixed64': ...
    def InvertDiagonal(self) -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def CreateRotationX(angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def CreateRotationY(angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def CreateRotationZ(angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def CreateShear(shX: 'FixedMathSharp.Fixed64', shY: 'FixedMathSharp.Fixed64', shZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def CreateScale(scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def CreateScale(scaleFactor: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def SetLossyScale(scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    @overload
    def SetLossyScale(x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64', z: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def SetScale(matrix: 'FixedMathSharp.Fixed3x3', localScale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def SetGlobalScale(matrix: 'FixedMathSharp.Fixed3x3', globalScale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def ExtractScale(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ExtractLossyScale(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Lerp(a: 'FixedMathSharp.Fixed3x3', b: 'FixedMathSharp.Fixed3x3', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def Transpose(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.Fixed3x3': ...
    @staticmethod
    def Invert(matrix: 'FixedMathSharp.Fixed3x3') -> Tuple['bool', 'System.Nullable_1[[FixedMathSharp.Fixed3x3, FixedMathSharp, Version=1.3.3.0, Culture=neutral, PublicKeyToken=null]]']: ...
    @staticmethod
    def TransformDirection(matrix: 'FixedMathSharp.Fixed3x3', direction: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def InverseTransformDirection(matrix: 'FixedMathSharp.Fixed3x3', direction: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.Fixed3x3') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class Fixed4x4(System.ValueType, System.IEquatable[FixedMathSharp.Fixed4x4]):
    def __init__(self, m00: 'FixedMathSharp.Fixed64', m01: 'FixedMathSharp.Fixed64', m02: 'FixedMathSharp.Fixed64', m03: 'FixedMathSharp.Fixed64', m10: 'FixedMathSharp.Fixed64', m11: 'FixedMathSharp.Fixed64', m12: 'FixedMathSharp.Fixed64', m13: 'FixedMathSharp.Fixed64', m20: 'FixedMathSharp.Fixed64', m21: 'FixedMathSharp.Fixed64', m22: 'FixedMathSharp.Fixed64', m23: 'FixedMathSharp.Fixed64', m30: 'FixedMathSharp.Fixed64', m31: 'FixedMathSharp.Fixed64', m32: 'FixedMathSharp.Fixed64', m33: 'FixedMathSharp.Fixed64') -> None: ...
    m00: 'FixedMathSharp.Fixed64' = ...
    m01: 'FixedMathSharp.Fixed64' = ...
    m02: 'FixedMathSharp.Fixed64' = ...
    m03: 'FixedMathSharp.Fixed64' = ...
    m10: 'FixedMathSharp.Fixed64' = ...
    m11: 'FixedMathSharp.Fixed64' = ...
    m12: 'FixedMathSharp.Fixed64' = ...
    m13: 'FixedMathSharp.Fixed64' = ...
    m20: 'FixedMathSharp.Fixed64' = ...
    m21: 'FixedMathSharp.Fixed64' = ...
    m22: 'FixedMathSharp.Fixed64' = ...
    m23: 'FixedMathSharp.Fixed64' = ...
    m30: 'FixedMathSharp.Fixed64' = ...
    m31: 'FixedMathSharp.Fixed64' = ...
    m32: 'FixedMathSharp.Fixed64' = ...
    m33: 'FixedMathSharp.Fixed64' = ...
    Identity: 'FixedMathSharp.Fixed4x4' = ...
    Zero: 'FixedMathSharp.Fixed4x4' = ...
    IsAffine: 'bool' = ...
    Translation: 'FixedMathSharp.Vector3d' = ...
    Up: 'FixedMathSharp.Vector3d' = ...
    Scale: 'FixedMathSharp.Vector3d' = ...
    Rotation: 'FixedMathSharp.FixedQuaternion' = ...
    __getitem__: 'FixedMathSharp.Fixed64' = ...
    def GetDeterminant(self) -> 'FixedMathSharp.Fixed64': ...
    @overload
    def ResetScaleToIdentity(self) -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    @overload
    def ResetScaleToIdentity(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Fixed4x4': ...
    def SetTransform(self, translation: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion', scale: 'FixedMathSharp.Vector3d') -> None: ...
    @staticmethod
    def CreateTranslation(position: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def CreateRotation(rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def CreateScale(scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def CreateTransform(translation: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion', scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def ScaleRotateTranslate(translation: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion', scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def TranslateRotateScale(translation: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion', scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def ExtractTranslation(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ExtractUp(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ExtractScale(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ExtractLossyScale(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ExtractRotation(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def Decompose(matrix: 'FixedMathSharp.Fixed4x4') -> Tuple['bool', 'FixedMathSharp.Vector3d', 'FixedMathSharp.FixedQuaternion', 'FixedMathSharp.Vector3d']: ...
    @staticmethod
    def SetTranslation(matrix: 'FixedMathSharp.Fixed4x4', translation: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def SetScale(matrix: 'FixedMathSharp.Fixed4x4', scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def ApplyScaleToRotation(matrix: 'FixedMathSharp.Fixed4x4', scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def SetGlobalScale(matrix: 'FixedMathSharp.Fixed4x4', globalScale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def SetRotation(matrix: 'FixedMathSharp.Fixed4x4', rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def NormalizeRotationMatrix(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.Fixed4x4': ...
    @staticmethod
    def Invert(matrix: 'FixedMathSharp.Fixed4x4') -> Tuple['bool', 'FixedMathSharp.Fixed4x4']: ...
    @staticmethod
    def TransformPoint(matrix: 'FixedMathSharp.Fixed4x4', point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def InverseTransformPoint(matrix: 'FixedMathSharp.Fixed4x4', point: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.Fixed4x4') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class Fixed64(System.ValueType, System.IEquatable[FixedMathSharp.Fixed64], System.IComparable[FixedMathSharp.Fixed64], System.Collections.Generic.IEqualityComparer[FixedMathSharp.Fixed64]):
    @overload
    def __init__(self, value: 'int') -> None: ...
    @overload
    def __init__(self, value: 'float') -> None: ...
    m_rawValue: 'int' = ...
    MAX_VALUE: 'FixedMathSharp.Fixed64' = ...
    MIN_VALUE: 'FixedMathSharp.Fixed64' = ...
    One: 'FixedMathSharp.Fixed64' = ...
    Two: 'FixedMathSharp.Fixed64' = ...
    Three: 'FixedMathSharp.Fixed64' = ...
    Half: 'FixedMathSharp.Fixed64' = ...
    Quarter: 'FixedMathSharp.Fixed64' = ...
    Eighth: 'FixedMathSharp.Fixed64' = ...
    Zero: 'FixedMathSharp.Fixed64' = ...
    Epsilon: 'FixedMathSharp.Fixed64' = ...
    Precision: 'FixedMathSharp.Fixed64' = ...
    def Offset(self, x: 'int') -> None: ...
    def RawToString(self) -> 'str': ...
    @staticmethod
    def Fraction(numerator: 'float', denominator: 'float') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def PostIncrement() -> Tuple['FixedMathSharp.Fixed64', 'FixedMathSharp.Fixed64']: ...
    @staticmethod
    def PostDecrement() -> Tuple['FixedMathSharp.Fixed64', 'FixedMathSharp.Fixed64']: ...
    @staticmethod
    def Sign(value: 'FixedMathSharp.Fixed64') -> 'int': ...
    @staticmethod
    def IsInteger(value: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @overload
    def ToString(self) -> 'str': ...
    @overload
    def ToString(self, format: 'str') -> 'str': ...
    @staticmethod
    def Parse(s: 'str') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def TryParse(s: 'str') -> Tuple['bool', 'FixedMathSharp.Fixed64']: ...
    @staticmethod
    def FromRaw(rawValue: 'int') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def ToDouble(f1: 'int') -> 'float': ...
    @staticmethod
    def ToFloat(f1: 'int') -> 'float': ...
    @staticmethod
    def ToDecimal(f1: 'int') -> 'System.Decimal': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @overload
    def Equals(self, x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @overload
    def GetHashCode(self) -> 'int': ...
    @overload
    def GetHashCode(self, obj: 'FixedMathSharp.Fixed64') -> 'int': ...
    def CompareTo(self, other: 'FixedMathSharp.Fixed64') -> 'int': ...

class FixedCurveMode(enum.Enum):
    Linear = ...
    Step = ...
    Smooth = ...
    Cubic = ...

class FixedCurve(System.IEquatable[FixedMathSharp.FixedCurve]):
    @overload
    def __init__(self, keyframes: 'List[FixedMathSharp.FixedCurveKey]') -> None: ...
    @overload
    def __init__(self, mode: 'FixedMathSharp.FixedCurveMode', keyframes: 'List[FixedMathSharp.FixedCurveKey]') -> None: ...
    Mode: 'FixedMathSharp.FixedCurveMode' = ...
    Keyframes: 'List[FixedMathSharp.FixedCurveKey]' = ...
    def Evaluate(self, time: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.FixedCurve') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class FixedCurveKey(System.ValueType, System.IEquatable[FixedMathSharp.FixedCurveKey]):
    @overload
    def __init__(self, time: 'float', value: 'float') -> None: ...
    @overload
    def __init__(self, time: 'float', value: 'float', inTangent: 'float', outTangent: 'float') -> None: ...
    @overload
    def __init__(self, time: 'FixedMathSharp.Fixed64', value: 'FixedMathSharp.Fixed64') -> None: ...
    @overload
    def __init__(self, time: 'FixedMathSharp.Fixed64', value: 'FixedMathSharp.Fixed64', inTangent: 'FixedMathSharp.Fixed64', outTangent: 'FixedMathSharp.Fixed64') -> None: ...
    Time: 'FixedMathSharp.Fixed64' = ...
    Value: 'FixedMathSharp.Fixed64' = ...
    InTangent: 'FixedMathSharp.Fixed64' = ...
    OutTangent: 'FixedMathSharp.Fixed64' = ...
    @overload
    def Equals(self, other: 'FixedMathSharp.FixedCurveKey') -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class FixedQuaternion(System.ValueType, System.IEquatable[FixedMathSharp.FixedQuaternion]):
    def __init__(self, x: 'FixedMathSharp.Fixed64', y: 'FixedMathSharp.Fixed64', z: 'FixedMathSharp.Fixed64', w: 'FixedMathSharp.Fixed64') -> None: ...
    x: 'FixedMathSharp.Fixed64' = ...
    y: 'FixedMathSharp.Fixed64' = ...
    z: 'FixedMathSharp.Fixed64' = ...
    w: 'FixedMathSharp.Fixed64' = ...
    Identity: 'FixedMathSharp.FixedQuaternion' = ...
    Zero: 'FixedMathSharp.FixedQuaternion' = ...
    Normal: 'FixedMathSharp.FixedQuaternion' = ...
    EulerAngles: 'FixedMathSharp.Vector3d' = ...
    __getitem__: 'FixedMathSharp.Fixed64' = ...
    def Set(self, newX: 'FixedMathSharp.Fixed64', newY: 'FixedMathSharp.Fixed64', newZ: 'FixedMathSharp.Fixed64', newW: 'FixedMathSharp.Fixed64') -> None: ...
    def Normalize(self) -> 'FixedMathSharp.FixedQuaternion': ...
    def Conjugate(self) -> 'FixedMathSharp.FixedQuaternion': ...
    def Inverse(self) -> 'FixedMathSharp.FixedQuaternion': ...
    def Rotate(self, v: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    def Rotated(self, sin: 'FixedMathSharp.Fixed64', cos: 'FixedMathSharp.Fixed64', axis: 'Optional[FixedMathSharp.Vector3d]') -> 'FixedMathSharp.FixedQuaternion': ...
    def IsNormalized(self) -> 'bool': ...
    @staticmethod
    def GetMagnitude(q: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def GetNormalized(q: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def LookRotation(forward: 'FixedMathSharp.Vector3d', upwards: 'Optional[FixedMathSharp.Vector3d]') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    @overload
    def FromMatrix(matrix: 'FixedMathSharp.Fixed3x3') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    @overload
    def FromMatrix(matrix: 'FixedMathSharp.Fixed4x4') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def FromDirection(direction: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def FromAxisAngle(axis: 'FixedMathSharp.Vector3d', angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def FromEulerAnglesInDegrees(pitch: 'FixedMathSharp.Fixed64', yaw: 'FixedMathSharp.Fixed64', roll: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def FromEulerAngles(pitch: 'FixedMathSharp.Fixed64', yaw: 'FixedMathSharp.Fixed64', roll: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def QuaternionLog(q: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ToAngularVelocity(currentRotation: 'FixedMathSharp.FixedQuaternion', previousRotation: 'FixedMathSharp.FixedQuaternion', deltaTime: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Lerp(a: 'FixedMathSharp.FixedQuaternion', b: 'FixedMathSharp.FixedQuaternion', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def Slerp(a: 'FixedMathSharp.FixedQuaternion', b: 'FixedMathSharp.FixedQuaternion', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def Angle(a: 'FixedMathSharp.FixedQuaternion', b: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def AngleAxis(angle: 'FixedMathSharp.Fixed64', axis: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.FixedQuaternion': ...
    @staticmethod
    def Dot(a: 'FixedMathSharp.FixedQuaternion', b: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Fixed64': ...
    def ToEulerAngles(self) -> 'FixedMathSharp.Vector3d': ...
    def ToDirection(self) -> 'FixedMathSharp.Vector3d': ...
    def ToMatrix3x3(self) -> 'FixedMathSharp.Fixed3x3': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.FixedQuaternion') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...
    def ToString(self) -> 'str': ...

class FixedRange(System.ValueType, System.IEquatable[FixedMathSharp.FixedRange]):
    def __init__(self, min: 'FixedMathSharp.Fixed64', max: 'FixedMathSharp.Fixed64', enforceOrder: 'bool') -> None: ...
    Min: 'FixedMathSharp.Fixed64' = ...
    Max: 'FixedMathSharp.Fixed64' = ...
    MinRange: 'FixedMathSharp.FixedRange' = ...
    MaxRange: 'FixedMathSharp.FixedRange' = ...
    Length: 'FixedMathSharp.Fixed64' = ...
    MidPoint: 'FixedMathSharp.Fixed64' = ...
    def SetMinMax(self, min: 'FixedMathSharp.Fixed64', max: 'FixedMathSharp.Fixed64') -> None: ...
    def AddInPlace(self, val: 'FixedMathSharp.Fixed64') -> None: ...
    @overload
    def InRange(self, x: 'FixedMathSharp.Fixed64', includeMax: 'bool') -> 'bool': ...
    @overload
    def InRange(self, x: 'float', includeMax: 'bool') -> 'bool': ...
    def Overlaps(self, other: 'FixedMathSharp.FixedRange') -> 'bool': ...
    @staticmethod
    def GetDirection(range1: 'FixedMathSharp.FixedRange', range2: 'FixedMathSharp.FixedRange') -> Tuple['bool', 'System.Nullable_1[[FixedMathSharp.Fixed64, FixedMathSharp, Version=1.3.3.0, Culture=neutral, PublicKeyToken=null]]']: ...
    @staticmethod
    def ComputeOverlapDepth(rangeA: 'FixedMathSharp.FixedRange', rangeB: 'FixedMathSharp.FixedRange') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def CheckOverlap(origin: 'FixedMathSharp.Vector3d', range1: 'FixedMathSharp.FixedRange', range2: 'FixedMathSharp.FixedRange', limit: 'FixedMathSharp.Fixed64', sign: 'FixedMathSharp.Fixed64') -> Tuple['bool', 'System.Nullable_1[[System.ValueTuple_2[[FixedMathSharp.Vector3d, FixedMathSharp, Version=1.3.3.0, Culture=neutral, PublicKeyToken=null],[FixedMathSharp.Fixed64, FixedMathSharp, Version=1.3.3.0, Culture=neutral, PublicKeyToken=null]], System.Private.CoreLib, Version=9.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]']: ...
    def ToString(self) -> 'str': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.FixedRange') -> 'bool': ...
    def GetHashCode(self) -> 'int': ...

class Vector2d(System.ValueType, System.IEquatable[FixedMathSharp.Vector2d], System.IComparable[FixedMathSharp.Vector2d], System.Collections.Generic.IEqualityComparer[FixedMathSharp.Vector2d]):
    @overload
    def __init__(self, xInt: 'int', yInt: 'int') -> None: ...
    @overload
    def __init__(self, xFloat: 'float', yFloat: 'float') -> None: ...
    @overload
    def __init__(self, xDoub: 'float', yDoub: 'float') -> None: ...
    @overload
    def __init__(self, xFixed: 'FixedMathSharp.Fixed64', yFixed: 'FixedMathSharp.Fixed64') -> None: ...
    x: 'FixedMathSharp.Fixed64' = ...
    y: 'FixedMathSharp.Fixed64' = ...
    DefaultRotation: 'FixedMathSharp.Vector2d' = ...
    Forward: 'FixedMathSharp.Vector2d' = ...
    Right: 'FixedMathSharp.Vector2d' = ...
    Down: 'FixedMathSharp.Vector2d' = ...
    Left: 'FixedMathSharp.Vector2d' = ...
    One: 'FixedMathSharp.Vector2d' = ...
    Negative: 'FixedMathSharp.Vector2d' = ...
    Zero: 'FixedMathSharp.Vector2d' = ...
    RotatedRight: 'FixedMathSharp.Vector2d' = ...
    RotatedLeft: 'FixedMathSharp.Vector2d' = ...
    RightHandNormal: 'FixedMathSharp.Vector2d' = ...
    LeftHandNormal: 'FixedMathSharp.Vector2d' = ...
    Normal: 'FixedMathSharp.Vector2d' = ...
    Magnitude: 'FixedMathSharp.Fixed64' = ...
    SqrMagnitude: 'FixedMathSharp.Fixed64' = ...
    LongStateHash: 'int' = ...
    StateHash: 'int' = ...
    __getitem__: 'FixedMathSharp.Fixed64' = ...
    def Set(self, newX: 'FixedMathSharp.Fixed64', newY: 'FixedMathSharp.Fixed64') -> None: ...
    @overload
    def AddInPlace(self, amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def AddInPlace(self, xAmount: 'FixedMathSharp.Fixed64', yAmount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def AddInPlace(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def SubtractInPlace(self, amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def SubtractInPlace(self, xAmount: 'FixedMathSharp.Fixed64', yAmount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def SubtractInPlace(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def ScaleInPlace(self, scaleFactor: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def ScaleInPlace(self, scale: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Normalize(self) -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Normalize(self) -> Tuple['FixedMathSharp.Vector2d', 'FixedMathSharp.Fixed64']: ...
    @overload
    def LerpInPlace(self, target: 'FixedMathSharp.Vector2d', amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def LerpInPlace(self, targetx: 'FixedMathSharp.Fixed64', targety: 'FixedMathSharp.Fixed64', amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Lerp(a: 'FixedMathSharp.Vector2d', b: 'FixedMathSharp.Vector2d', amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    def Lerped(self, target: 'FixedMathSharp.Vector2d', amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    def RotateInPlace(self, cos: 'FixedMathSharp.Fixed64', sin: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Rotated(self, cos: 'FixedMathSharp.Fixed64', sin: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Rotated(self, rotation: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    def RotateInverse(self, cos: 'FixedMathSharp.Fixed64', sin: 'FixedMathSharp.Fixed64') -> None: ...
    def RotateRightInPlace(self) -> 'FixedMathSharp.Vector2d': ...
    def RotateLeftInPlace(self) -> 'FixedMathSharp.Vector2d': ...
    @overload
    def ReflectInPlace(self, axis: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def ReflectInPlace(self, axisX: 'FixedMathSharp.Fixed64', axisY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def ReflectInPlace(self, axisX: 'FixedMathSharp.Fixed64', axisY: 'FixedMathSharp.Fixed64', projection: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Reflected(self, axisX: 'FixedMathSharp.Fixed64', axisY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Reflected(self, axis: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Dot(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Dot(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Dot(lhs: 'FixedMathSharp.Vector2d', rhs: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def CrossProduct(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def CrossProduct(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def CrossProduct(lhs: 'FixedMathSharp.Vector2d', rhs: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Distance(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Distance(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Distance(start: 'FixedMathSharp.Vector2d', end: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def SqrDistance(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def SqrDistance(self, other: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def SqrDistance(start: 'FixedMathSharp.Vector2d', end: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def GetNormalized(value: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def GetMagnitude(vector: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Sign(value: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def CreateRotation(angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def ForwardDirection(angle: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Scale(a: 'FixedMathSharp.Vector2d', b: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def Rotate(vec: 'FixedMathSharp.Vector2d', angleInRadians: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector2d': ...
    def ToString(self) -> 'str': ...
    def ToVector3d(self, z: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Deconstruct(self) -> Tuple['System.Single', 'System.Single']: ...
    @overload
    def Deconstruct(self) -> Tuple['System.Int32', 'System.Int32']: ...
    @staticmethod
    def ToDegrees(radians: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    @staticmethod
    def ToRadians(degrees: 'FixedMathSharp.Vector2d') -> 'FixedMathSharp.Vector2d': ...
    def EqualsZero(self) -> 'bool': ...
    def NotZero(self) -> 'bool': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.Vector2d') -> 'bool': ...
    @overload
    def Equals(self, x: 'FixedMathSharp.Vector2d', y: 'FixedMathSharp.Vector2d') -> 'bool': ...
    @overload
    def GetHashCode(self) -> 'int': ...
    @overload
    def GetHashCode(self, obj: 'FixedMathSharp.Vector2d') -> 'int': ...
    def CompareTo(self, other: 'FixedMathSharp.Vector2d') -> 'int': ...

class Vector3d(System.ValueType, System.IEquatable[FixedMathSharp.Vector3d], System.IComparable[FixedMathSharp.Vector3d], System.Collections.Generic.IEqualityComparer[FixedMathSharp.Vector3d]):
    @overload
    def __init__(self, xInt: 'int', yInt: 'int', zInt: 'int') -> None: ...
    @overload
    def __init__(self, xDoub: 'float', yDoub: 'float', zDoub: 'float') -> None: ...
    @overload
    def __init__(self, xLong: 'FixedMathSharp.Fixed64', yLong: 'FixedMathSharp.Fixed64', zLong: 'FixedMathSharp.Fixed64') -> None: ...
    x: 'FixedMathSharp.Fixed64' = ...
    y: 'FixedMathSharp.Fixed64' = ...
    z: 'FixedMathSharp.Fixed64' = ...
    Up: 'FixedMathSharp.Vector3d' = ...
    Right: 'FixedMathSharp.Vector3d' = ...
    Down: 'FixedMathSharp.Vector3d' = ...
    Left: 'FixedMathSharp.Vector3d' = ...
    Forward: 'FixedMathSharp.Vector3d' = ...
    Backward: 'FixedMathSharp.Vector3d' = ...
    One: 'FixedMathSharp.Vector3d' = ...
    Negative: 'FixedMathSharp.Vector3d' = ...
    Zero: 'FixedMathSharp.Vector3d' = ...
    RightHandNormal: 'FixedMathSharp.Vector3d' = ...
    LeftHandNormal: 'FixedMathSharp.Vector3d' = ...
    Normal: 'FixedMathSharp.Vector3d' = ...
    Magnitude: 'FixedMathSharp.Fixed64' = ...
    Direction: 'FixedMathSharp.Vector3d' = ...
    IsZero: 'bool' = ...
    SqrMagnitude: 'FixedMathSharp.Fixed64' = ...
    LongStateHash: 'int' = ...
    StateHash: 'int' = ...
    __getitem__: 'FixedMathSharp.Fixed64' = ...
    def Set(self, newX: 'FixedMathSharp.Fixed64', newY: 'FixedMathSharp.Fixed64', newZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def AddInPlace(self, amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def AddInPlace(self, xAmount: 'FixedMathSharp.Fixed64', yAmount: 'FixedMathSharp.Fixed64', zAmount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def AddInPlace(self, other: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def SubtractInPlace(self, amount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def SubtractInPlace(self, xAmount: 'FixedMathSharp.Fixed64', yAmount: 'FixedMathSharp.Fixed64', zAmount: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def SubtractInPlace(self, other: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def ScaleInPlace(self, scaleFactor: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def ScaleInPlace(self, scale: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Normalize(self) -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Normalize(self) -> Tuple['FixedMathSharp.Vector3d', 'FixedMathSharp.Fixed64']: ...
    def IsNormalized(self) -> 'bool': ...
    @overload
    def Distance(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64', otherZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Distance(start: 'FixedMathSharp.Vector3d', end: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def SqrDistance(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64', otherZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def SqrDistance(start: 'FixedMathSharp.Vector3d', end: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Dot(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64', otherZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def Dot(lhs: 'FixedMathSharp.Vector3d', rhs: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def CrossProduct(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64', otherZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    @overload
    def CrossProduct(lhs: 'FixedMathSharp.Vector3d', rhs: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @overload
    def Cross(self, otherX: 'FixedMathSharp.Fixed64', otherY: 'FixedMathSharp.Fixed64', otherZ: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    @overload
    def Cross(lhs: 'FixedMathSharp.Vector3d', rhs: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Lerp(a: 'FixedMathSharp.Vector3d', b: 'FixedMathSharp.Vector3d', mag: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def UnclampedLerp(a: 'FixedMathSharp.Vector3d', b: 'FixedMathSharp.Vector3d', t: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def SpeedLerp(a: 'FixedMathSharp.Vector3d', b: 'FixedMathSharp.Vector3d', speed: 'FixedMathSharp.Fixed64', dt: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Slerp(start: 'FixedMathSharp.Vector3d', end: 'FixedMathSharp.Vector3d', percent: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def GetNormalized(value: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def GetMagnitude(vector: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Abs(value: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Sign(value: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Clamp(value: 'FixedMathSharp.Vector3d', min: 'FixedMathSharp.Vector3d', max: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ClampMagnitude(value: 'FixedMathSharp.Vector3d', maxMagnitude: 'FixedMathSharp.Fixed64') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def AreParallel(v1: 'FixedMathSharp.Vector3d', v2: 'FixedMathSharp.Vector3d') -> 'bool': ...
    @staticmethod
    def AreAlmostParallel(v1: 'FixedMathSharp.Vector3d', v2: 'FixedMathSharp.Vector3d', cosThreshold: 'FixedMathSharp.Fixed64') -> 'bool': ...
    @staticmethod
    def Midpoint(v1: 'FixedMathSharp.Vector3d', v2: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ClosestPointsOnTwoLines(line1Start: 'FixedMathSharp.Vector3d', line1End: 'FixedMathSharp.Vector3d', line2Start: 'FixedMathSharp.Vector3d', line2End: 'FixedMathSharp.Vector3d') -> 'System.ValueTuple[FixedMathSharp.Vector3d, FixedMathSharp.Vector3d]': ...
    @staticmethod
    def ClosestPointOnLineSegment(a: 'FixedMathSharp.Vector3d', b: 'FixedMathSharp.Vector3d', p: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Scale(a: 'FixedMathSharp.Vector3d', b: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Project(vector: 'FixedMathSharp.Vector3d', onNormal: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ProjectOnPlane(vector: 'FixedMathSharp.Vector3d', planeNormal: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Angle(from: 'FixedMathSharp.Vector3d', to: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Fixed64': ...
    @staticmethod
    def Max(value1: 'FixedMathSharp.Vector3d', value2: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Min(value1: 'FixedMathSharp.Vector3d', value2: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def Rotate(source: 'FixedMathSharp.Vector3d', position: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def InverseRotate(source: 'FixedMathSharp.Vector3d', position: 'FixedMathSharp.Vector3d', rotation: 'FixedMathSharp.FixedQuaternion') -> 'FixedMathSharp.Vector3d': ...
    def ToString(self) -> 'str': ...
    def ToVector2d(self) -> 'FixedMathSharp.Vector2d': ...
    @overload
    def Deconstruct(self) -> Tuple['System.Single', 'System.Single', 'System.Single']: ...
    @overload
    def Deconstruct(self) -> Tuple['System.Int32', 'System.Int32', 'System.Int32']: ...
    @staticmethod
    def ToDegrees(radians: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @staticmethod
    def ToRadians(degrees: 'FixedMathSharp.Vector3d') -> 'FixedMathSharp.Vector3d': ...
    @overload
    def Equals(self, obj: 'Any') -> 'bool': ...
    @overload
    def Equals(self, other: 'FixedMathSharp.Vector3d') -> 'bool': ...
    @overload
    def Equals(self, x: 'FixedMathSharp.Vector3d', y: 'FixedMathSharp.Vector3d') -> 'bool': ...
    @overload
    def GetHashCode(self) -> 'int': ...
    @overload
    def GetHashCode(self, obj: 'FixedMathSharp.Vector3d') -> 'int': ...
    def CompareTo(self, other: 'FixedMathSharp.Vector3d') -> 'int': ...

from . import Utility as Utility
