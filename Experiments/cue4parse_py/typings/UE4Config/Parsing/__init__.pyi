from __future__ import annotations
from typing import Any, List, Dict, Optional, overload, TypeVar, Generic, Tuple
import enum, System, CUE4Parse
T = TypeVar('T')
class Lazy(Generic[T]): value: T
Nullable = Optional

class CommentToken(UE4Config.Parsing.MultilineToken):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, lines: 'List[str]', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...

class ConfigIni:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: 'str') -> None: ...
    @overload
    def __init__(self, name: 'str', configFileReference: 'UE4Config.Hierarchy.ConfigFileReference') -> None: ...
    @overload
    def __init__(self, sections: 'List[UE4Config.Parsing.ConfigIniSection]') -> None: ...
    @overload
    def __init__(self, name: 'str', sections: 'List[UE4Config.Parsing.ConfigIniSection]') -> None: ...
    Sections: 'List[UE4Config.Parsing.ConfigIniSection]' = ...
    Name: 'str' = ...
    Reference: 'UE4Config.Hierarchy.ConfigFileReference' = ...
    def FindPropertyInstructions(self, sectionName: 'str', propertyKey: 'str', instructions: 'System.Collections.Generic.IList[UE4Config.Parsing.InstructionToken]') -> None: ...
    def Read(self, reader: 'System.IO.TextReader') -> None: ...
    def ReadLine(self, line: 'str', lineEnding: 'UE4Config.Parsing.LineEnding') -> 'UE4Config.Parsing.ConfigIniSection': ...
    def ReadLineWithoutLineEnding(self, line: 'str') -> 'UE4Config.Parsing.ConfigIniSection': ...
    @overload
    def AppendRawText(self, text: 'str') -> None: ...
    @overload
    def AppendRawText(self, textReader: 'System.IO.TextReader') -> None: ...
    def AppendCloneOf(self, other: 'UE4Config.Parsing.ConfigIni') -> None: ...
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...
    def EvaluatePropertyValues(self, sectionName: 'str', propertyKey: 'str', values: 'System.Collections.Generic.IList[str]', evaluator: 'UE4Config.Evaluation.PropertyEvaluator') -> None: ...
    def MergeDuplicateSections(self) -> None: ...
    def GroupPropertyInstructions(self) -> None: ...
    def CondenseWhitespace(self) -> None: ...
    def AutoDetectLineEnding(self) -> 'UE4Config.Parsing.LineEnding': ...
    @overload
    def NormalizeLineEndings(self) -> None: ...
    @overload
    def NormalizeLineEndings(self, lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    def Sanitize(self) -> None: ...
    def Cleanup(self) -> None: ...

class ConfigIniSection:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: 'str') -> None: ...
    @overload
    def __init__(self, tokens: 'List[UE4Config.Parsing.IniToken]') -> None: ...
    @overload
    def __init__(self, name: 'str', tokens: 'List[UE4Config.Parsing.IniToken]') -> None: ...
    Name: 'str' = ...
    Tokens: 'List[UE4Config.Parsing.IniToken]' = ...
    LineEnding: 'UE4Config.Parsing.LineEnding' = ...
    LineWastePrefix: 'str' = ...
    LineWasteSuffix: 'str' = ...
    @staticmethod
    def Clone(template: 'UE4Config.Parsing.ConfigIniSection') -> 'UE4Config.Parsing.ConfigIniSection': ...
    def FindPropertyInstructions(self, propertyKey: 'str', instructions: 'System.Collections.Generic.IList[UE4Config.Parsing.InstructionToken]') -> None: ...
    def GetLastToken(self) -> 'UE4Config.Parsing.IniToken': ...
    def GroupPropertyInstructions(self) -> None: ...
    def MergeConsecutiveTokens(self) -> None: ...
    def CondenseWhitespace(self) -> None: ...
    def NormalizeLineEndings(self, lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...
    def WriteHeader(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...
    def WriteTokens(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...

class ConfigIniWriter:
    def __init__(self, textContentWriter: 'System.IO.TextWriter') -> None: ...
    ContentWriter: 'System.IO.TextWriter' = ...
    LineEnding: 'UE4Config.Parsing.LineEnding' = ...
    AppendQuirkFileEnding: 'bool' = ...
    def Write(self, content: 'str') -> None: ...
    def ToString(self) -> 'str': ...
    def WriteLineEnding(self, lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...

class IniToken:
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...
    def CreateClone(self) -> 'UE4Config.Parsing.IniToken': ...

class InstructionToken(UE4Config.Parsing.LineToken):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, type: 'UE4Config.Parsing.InstructionType', key: 'str', value: 'str') -> None: ...
    @overload
    def __init__(self, type: 'UE4Config.Parsing.InstructionType', key: 'str', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    @overload
    def __init__(self, type: 'UE4Config.Parsing.InstructionType', key: 'str', value: 'str', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    InstructionType: 'UE4Config.Parsing.InstructionType' = ...
    Key: 'str' = ...
    Value: 'str' = ...
    def CreateClone(self) -> 'UE4Config.Parsing.IniToken': ...
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...

class InstructionType(enum.Enum):
    Set = ...
    Add = ...
    AddForce = ...
    Remove = ...
    RemoveAll = ...

class InstructionTypeExtensions:
    @staticmethod
    def AsPrefixString(type: 'UE4Config.Parsing.InstructionType') -> 'str': ...

class LineEnding(enum.Enum):
    Unknown = ...
    None = ...
    Unix = ...
    Windows = ...
    Mac = ...

class LineEndingExtensions:
    @staticmethod
    def AsString(lineEnding: 'UE4Config.Parsing.LineEnding') -> 'str': ...
    @staticmethod
    @overload
    def WriteTo(lineEnding: 'UE4Config.Parsing.LineEnding', writer: 'System.IO.TextWriter') -> None: ...
    @staticmethod
    @overload
    def WriteTo(lineEnding: 'UE4Config.Parsing.LineEnding', writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...

class LineToken(UE4Config.Parsing.IniToken):
    LineEnding: 'UE4Config.Parsing.LineEnding' = ...
    def CreateClone(self) -> 'UE4Config.Parsing.IniToken': ...

class MultilineToken(UE4Config.Parsing.IniToken):
    Lines: 'List[UE4Config.Parsing.TextLine]' = ...
    def AddLine(self, content: 'str', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    def AddLines(self, contents: 'List[str]', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    def GetStringLines(self) -> 'List[str]': ...
    def CreateClone(self) -> 'UE4Config.Parsing.IniToken': ...
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...

class TextLine(System.ValueType):
    def __init__(self, content: 'str', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    Content: 'str' = ...
    LineEnding: 'UE4Config.Parsing.LineEnding' = ...
    IsNull: 'bool' = ...
    def ToString(self) -> 'str': ...

class TextToken(UE4Config.Parsing.LineToken):
    def __init__(self) -> None: ...
    Text: 'str' = ...
    def Write(self, writer: 'UE4Config.Parsing.ConfigIniWriter') -> None: ...
    def CreateClone(self) -> 'UE4Config.Parsing.IniToken': ...

class WhitespaceToken(UE4Config.Parsing.MultilineToken):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, lines: 'List[str]', lineEnding: 'UE4Config.Parsing.LineEnding') -> None: ...
    def Condense(self) -> None: ...

